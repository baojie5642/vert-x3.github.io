<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<title>Vert.x Core Manual</title>
<style>
@font-face { font-family: 'TitilliumText22LThin'; src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L001-webfont.eot"); src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L001-webfont.eot?#iefix") format("embedded-opentype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L001-webfont.woff") format("woff"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L001-webfont.ttf") format("truetype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L001-webfont.svg#TitilliumText22LThin") format("svg"); font-weight: normal; font-style: normal; }

@font-face { font-family: 'TitilliumText22LLight'; src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L002-webfont.eot"); src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L002-webfont.eot?#iefix") format("embedded-opentype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L002-webfont.woff") format("woff"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L002-webfont.ttf") format("truetype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L002-webfont.svg#TitilliumText22LLight") format("svg"); font-weight: normal; font-style: normal; }

@font-face { font-family: 'TitilliumText22LRegular'; src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L003-webfont.eot"); src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L003-webfont.eot?#iefix") format("embedded-opentype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L003-webfont.woff") format("woff"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L003-webfont.ttf") format("truetype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L003-webfont.svg#TitilliumText22LRegular") format("svg"); font-weight: normal; font-style: normal; }

@font-face { font-family: 'TitilliumText22LMedium'; src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L004-webfont.eot"); src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L004-webfont.eot?#iefix") format("embedded-opentype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L004-webfont.woff") format("woff"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L004-webfont.ttf") format("truetype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L004-webfont.svg#TitilliumText22LMedium") format("svg"); font-weight: normal; font-style: normal; }

@font-face { font-family: 'TitilliumText22LBold'; src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L005-webfont.eot"); src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L005-webfont.eot?#iefix") format("embedded-opentype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L005-webfont.woff") format("woff"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L005-webfont.ttf") format("truetype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L005-webfont.svg#TitilliumText22LBold") format("svg"); font-weight: normal; font-style: normal; }

@font-face { font-family: 'TitilliumText22LXBold'; src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L006-webfont.eot"); src: url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L006-webfont.eot?#iefix") format("embedded-opentype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L006-webfont.woff") format("woff"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L006-webfont.ttf") format("truetype"), url("http://static.jboss.org/theme/fonts/titilliumtext/TitilliumText22L006-webfont.svg#TitilliumText22LXBold") format("svg"); font-weight: normal; font-style: normal; }

/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 15px; }

body { background: white; color: #656565; padding: 0; margin: 0; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased, body { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.4; color: #b2b2b2; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #336699; text-decoration: none; line-height: inherit; }
a:hover, a:focus { color: #204060; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: "Source Sans Pro", "TitilliumText22LMedium", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; color: #656565; text-rendering: optimizeLegibility; margin-top: 1.5em; margin-bottom: 0.5em; line-height: 0.9125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #b2b2b2; line-height: 0; }

h1 { font-size: 1.975em; }

h2 { font-size: 1.525em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.3875em; }

h4 { font-size: 0.9375em; }

h5 { font-size: 1em; }

h6 { font-size: 0.85em; }

hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-weight: normal; color: #c7254e; }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; }

ul, ol { margin-left: 0; }
ul.no-bullet, ol.no-bullet { margin-left: 0; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3em; font-weight: bold; }
dl dd { margin-bottom: 0.75em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #656565; border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: 0.8125em; color: #989898; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #989898; }

blockquote, blockquote p { line-height: 1.6; color: #b2b2b2; }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.1; }
  h1 { font-size: 2.6em; }
  h2 { font-size: 2.15em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.7em; }
  h4 { font-size: 1.25em; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: 0.875em; color: #656565; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: 0.875em; color: #656565; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.125em; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.1; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: inherit; font-style: normal !important; letter-spacing: 0; padding: 0; background-color: #f9f2f4; -webkit-border-radius: 4px; border-radius: 4px; line-height: inherit; }

pre, pre > code { line-height: 1.6; color: #656565; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }

.keyseq { color: #989898; }

kbd { display: inline-block; color: #656565; font-size: 0.75em; line-height: 1.4; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: #4c4c4c; }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: #656565; margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #dddddd; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #dddddd; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #dddddd; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: #989898; display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: #b2b2b2; }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: #b2b2b2; }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: #656565; border-bottom: 1px solid #dddddd; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 1px solid #dddddd; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: "Source Sans Pro", "TitilliumText22LMedium", Helvetica, Arial, sans-serif; list-style-type: none; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: #b2b2b2; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #f2f2f2; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #dddddd; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #dddddd; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: #656565; padding: 1.25em; }

#footer-text { color: #9a9a9a; line-height: 1.44; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { .sect1 { padding-bottom: 1.25em; } }
.sect1 + .sect1 { border-top: 1px solid #dddddd; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #656565; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #585858; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: #656565; }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: "Source Sans Pro", "TitilliumText22LMedium", Helvetica, Arial, sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #989898; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: #b2b2b2; margin-top: 0; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: whitesmoke; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { border: 1px solid #dddddd; -webkit-border-radius: 4px; border-radius: 4px; word-wrap: break-word; padding: 0.625em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: whitesmoke; background-color: #656565; }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 0.625em; -webkit-border-radius: 4px; border-radius: 4px; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 1.25em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: #b2b2b2; font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: #b2b2b2; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid #989898; }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 1.25em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: #b2b2b2; font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.8125em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.05em; color: #989898; }

.quoteblock.abstract { margin: 0 0 1.25em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.spread { width: 100%; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dddddd; }

table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }

table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }

table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }

table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }

table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }

table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.125em; background: whitesmoke; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #656565; font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 0.25em; }

ul li ol { margin-left: 0; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1em; font-size: 0.85em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { width: 1em; position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1 { padding-right: .75em; font-weight: bold; }

td.hdlist1, td.hdlist2 { vertical-align: top; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 0.75em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; }

span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
span.footnote a:active, span.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }

#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #bfbfbf; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: #656565; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: #656565; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 15px; }

body { -webkit-font-smoothing: subpixel-antialiased; }

#content { margin-top: 5em; }

.sect1 { margin-top: 5em; }

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Vert.x Core Manual</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_in_the_beginning_there_was_vert_x">In the beginning there was Vert.x</a>
<ul class="sectlevel2">
<li><a href="#_specifying_options_when_creating_a_vertx_object">Specifying options when creating a Vertx object</a></li>
<li><a href="#_creating_a_clustered_vert_x_object">Creating a clustered Vert.x object</a></li>
</ul>
</li>
<li><a href="#_are_you_fluent">Are you fluent?</a></li>
<li><a href="#_don_t_call_us_we_ll_call_you">Don&#8217;t call us, we&#8217;ll call you.</a></li>
<li><a href="#_don_t_block_me">Don&#8217;t block me!</a></li>
<li><a href="#_reactor_and_multi_reactor">Reactor and Multi-Reactor</a></li>
<li><a href="#golden_rule">The Golden Rule - Don&#8217;t Block the Event Loop</a></li>
<li><a href="#blocking_code">Running blocking code</a></li>
<li><a href="#_verticles">Verticles</a>
<ul class="sectlevel2">
<li><a href="#_writing_verticles">Writing Verticles</a></li>
<li><a href="#_verticle_types">Verticle Types</a></li>
<li><a href="#_standard_verticles">Standard verticles</a></li>
<li><a href="#worker_verticles">Worker verticles</a></li>
<li><a href="#_deploying_verticles_programmatically">Deploying verticles programmatically</a></li>
<li><a href="#_rules_for_mapping_a_verticle_name_to_a_verticle_factory">Rules for mapping a verticle name to a verticle factory</a></li>
<li><a href="#_how_are_verticle_factories_located">How are Verticle Factories located?</a></li>
<li><a href="#_waiting_for_deployment_to_complete">Waiting for deployment to complete</a></li>
<li><a href="#_undeploying_verticle_deployments">Undeploying verticle deployments</a></li>
<li><a href="#_specifying_number_of_verticle_instances">Specifying number of verticle instances</a></li>
<li><a href="#_passing_configuration_to_a_verticle">Passing configuration to a verticle</a></li>
<li><a href="#_accessing_environment_variables_in_a_verticle">Accessing environment variables in a Verticle</a></li>
<li><a href="#_verticle_isolation_groups">Verticle Isolation Groups</a></li>
<li><a href="#_high_availability">High Availability</a></li>
<li><a href="#_running_verticles_from_the_command_line">Running Verticles from the command line</a></li>
<li><a href="#_causing_vert_x_to_exit">Causing Vert.x to exit</a></li>
<li><a href="#_the_context_object">The Context object</a></li>
<li><a href="#_executing_periodic_and_delayed_actions">Executing periodic and delayed actions</a></li>
</ul>
</li>
<li><a href="#event_bus">The Event Bus</a>
<ul class="sectlevel2">
<li><a href="#_the_theory">The Theory</a></li>
<li><a href="#_the_event_bus_api">The Event Bus API</a></li>
<li><a href="#_automatic_clean_up_in_verticles_2">Automatic clean-up in verticles</a></li>
</ul>
</li>
<li><a href="#_json">JSON</a></li>
<li><a href="#_buffers">Buffers</a>
<ul class="sectlevel2">
<li><a href="#_creating_buffers">Creating buffers</a></li>
<li><a href="#_writing_to_a_buffer">Writing to a Buffer</a></li>
<li><a href="#_reading_from_a_buffer">Reading from a Buffer</a></li>
<li><a href="#_buffer_length">Buffer length</a></li>
<li><a href="#_copying_buffers">Copying buffers</a></li>
<li><a href="#_slicing_buffers">Slicing buffers</a></li>
<li><a href="#_buffer_re_use">Buffer re-use</a></li>
</ul>
</li>
<li><a href="#_writing_tcp_servers_and_clients">Writing TCP servers and clients</a>
<ul class="sectlevel2">
<li><a href="#_creating_a_tcp_server">Creating a TCP server</a></li>
<li><a href="#_configuring_a_tcp_server">Configuring a TCP server</a></li>
<li><a href="#_start_the_server_listening">Start the Server Listening</a></li>
<li><a href="#_listening_on_a_random_port">Listening on a random port</a></li>
<li><a href="#_getting_notified_of_incoming_connections">Getting notified of incoming connections</a></li>
<li><a href="#_reading_data_from_the_socket">Reading data from the socket</a></li>
<li><a href="#_writing_data_to_a_socket">Writing data to a socket</a></li>
<li><a href="#_closed_handler">Closed handler</a></li>
<li><a href="#_handling_exceptions">Handling exceptions</a></li>
<li><a href="#_event_bus_write_handler">Event bus write handler</a></li>
<li><a href="#_local_and_remote_addresses">Local and remote addresses</a></li>
<li><a href="#_sending_files">Sending files</a></li>
<li><a href="#_streaming_sockets">Streaming sockets</a></li>
<li><a href="#_upgrading_connections_to_ssl_tls">Upgrading connections to SSL/TLS</a></li>
<li><a href="#_closing_a_tcp_server">Closing a TCP Server</a></li>
<li><a href="#_automatic_clean_up_in_verticles_3">Automatic clean-up in verticles</a></li>
<li><a href="#_scaling_sharing_tcp_servers">Scaling - sharing TCP servers</a></li>
<li><a href="#_creating_a_tcp_client">Creating a TCP client</a></li>
<li><a href="#_configuring_a_tcp_client">Configuring a TCP client</a></li>
<li><a href="#_making_connections">Making connections</a></li>
<li><a href="#_configuring_connection_attempts">Configuring connection attempts</a></li>
<li><a href="#ssl">Configuring servers and clients to work with SSL/TLS</a></li>
</ul>
</li>
<li><a href="#_writing_http_servers_and_clients">Writing HTTP servers and clients</a>
<ul class="sectlevel2">
<li><a href="#_creating_an_http_server">Creating an HTTP Server</a></li>
<li><a href="#_configuring_an_http_server">Configuring an HTTP server</a></li>
<li><a href="#_start_the_server_listening_2">Start the Server Listening</a></li>
<li><a href="#_getting_notified_of_incoming_requests">Getting notified of incoming requests</a></li>
<li><a href="#_handling_requests">Handling requests</a></li>
<li><a href="#_sending_back_responses">Sending back responses</a></li>
<li><a href="#_http_compression">HTTP Compression</a></li>
<li><a href="#_creating_an_http_client">Creating an HTTP client</a></li>
<li><a href="#_making_requests">Making requests</a></li>
<li><a href="#_handling_http_responses">Handling http responses</a></li>
<li><a href="#_enabling_compression_on_the_client">Enabling compression on the client</a></li>
<li><a href="#_pooling_and_keep_alive">Pooling and keep alive</a></li>
<li><a href="#_pipe_lining">Pipe-lining</a></li>
<li><a href="#_server_sharing">Server sharing</a></li>
<li><a href="#_using_https_with_vert_x">Using HTTPS with Vert.x</a></li>
<li><a href="#_websockets">WebSockets</a></li>
<li><a href="#_automatic_clean_up_in_verticles_4">Automatic clean-up in verticles</a></li>
</ul>
</li>
<li><a href="#_using_shared_data_with_vert_x">Using Shared Data with Vert.x</a>
<ul class="sectlevel2">
<li><a href="#_local_shared_maps">Local shared maps</a></li>
<li><a href="#_cluster_wide_asynchronous_maps">Cluster-wide asynchronous maps</a></li>
<li><a href="#_cluster_wide_locks">Cluster-wide locks</a></li>
<li><a href="#_cluster_wide_counters">Cluster-wide counters</a></li>
</ul>
</li>
<li><a href="#_using_the_file_system_with_vert_x">Using the file system with Vert.x</a>
<ul class="sectlevel2">
<li><a href="#_asynchronous_files">Asynchronous files</a></li>
</ul>
</li>
<li><a href="#_datagram_sockets_udp">Datagram sockets (UDP)</a>
<ul class="sectlevel2">
<li><a href="#_creating_a_datagramsocket">Creating a DatagramSocket</a></li>
<li><a href="#_sending_datagram_packets">Sending Datagram packets</a></li>
<li><a href="#_receiving_datagram_packets">Receiving Datagram packets</a></li>
<li><a href="#_multicast">Multicast</a></li>
</ul>
</li>
<li><a href="#_dns_client">DNS client</a>
<ul class="sectlevel2">
<li><a href="#_lookup">lookup</a></li>
<li><a href="#_lookup4">lookup4</a></li>
<li><a href="#_lookup6">lookup6</a></li>
<li><a href="#_resolvea">resolveA</a></li>
<li><a href="#_resolveaaaa">resolveAAAA</a></li>
<li><a href="#_resolvecname">resolveCNAME</a></li>
<li><a href="#_resolvemx">resolveMX</a></li>
<li><a href="#_resolvetxt">resolveTXT</a></li>
<li><a href="#_resolvens">resolveNS</a></li>
<li><a href="#_resolvesrv">resolveSRV</a></li>
<li><a href="#_resolveptr">resolvePTR</a></li>
<li><a href="#_reverselookup">reverseLookup</a></li>
</ul>
</li>
<li><a href="#streams">Streams</a>
<ul class="sectlevel2">
<li><a href="#_readstream">ReadStream</a></li>
<li><a href="#_writestream">WriteStream</a></li>
<li><a href="#_pump">Pump</a></li>
</ul>
</li>
<li><a href="#_parse_tools">Parse tools</a></li>
<li><a href="#_thread_safety">Thread safety</a></li>
<li><a href="#_metrics_spi">Metrics SPI</a></li>
<li><a href="#_clustering">Clustering</a>
<ul class="sectlevel2">
<li><a href="#_trouble_shooting_clustering">Trouble-shooting clustering</a></li>
<li><a href="#_high_availability_2">High Availability</a></li>
</ul>
</li>
<li><a href="#_security_notes">Security notes</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>At the heart of Vert.x is a set of Java APIs that we call <strong>Vert.x Core</strong></p>
</div>
<div class="paragraph">
<p><a href="https://github.com/eclipse/vert.x">Repository</a>.</p>
</div>
<div class="paragraph">
<p>Vert.x core provides functionality for things like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Writing TCP clients and servers</p>
</li>
<li>
<p>Writing HTTP clients and servers including support for WebSockets</p>
</li>
<li>
<p>The Event bus</p>
</li>
<li>
<p>Shared data - local maps and clustered distributed maps</p>
</li>
<li>
<p>Periodic and delayed actions</p>
</li>
<li>
<p>Deploying and undeploying Verticles</p>
</li>
<li>
<p>Datagram Sockets</p>
</li>
<li>
<p>DNS client</p>
</li>
<li>
<p>File system access</p>
</li>
<li>
<p>High availability</p>
</li>
<li>
<p>Clustering</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The functionality in core is fairly low level - you won&#8217;t find stuff like database access, authorisation or high level
web functionality here - that kind of stuff you&#8217;ll find in <strong>Vert.x ext</strong> (extensions).</p>
</div>
<div class="paragraph">
<p>Vert.x core is small and lightweight. You just use the parts you want. It&#8217;s also entirely embeddable in your
existing applications - we don&#8217;t force you to structure your applications in a special way just so you can use
Vert.x.</p>
</div>
<div class="paragraph">
<p>You can use core from any of the other languages that Vert.x supports. But here&#8217;a a cool bit - we don&#8217;t force
you to use the Java API directly from, say, JavaScript or Ruby - after all, different languages have different conventions
and idioms, and it would be odd to force Java idioms on Ruby developers (for example).
Instead, we automatically generate an <strong>idiomatic</strong> equivalent of the core Java APIs for each language.</p>
</div>
<div class="paragraph">
<p>From now on we&#8217;ll just use the word <strong>core</strong> to refer to Vert.x core.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s discuss the different concepts and features in core.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_in_the_beginning_there_was_vert_x">In the beginning there was Vert.x</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Much of this is Java specific - need someway of swapping in language specific parts
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can&#8217;t do much in Vert.x-land unless you can commune with a <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html">Vertx</a></code> object!</p>
</div>
<div class="paragraph">
<p>It&#8217;s the control centre of Vert.x and is how you do pretty much everything, including creating clients and servers,
getting a reference to the event bus, setting timers, as well as many other things.</p>
</div>
<div class="paragraph">
<p>So how do you get an instance?</p>
</div>
<div class="paragraph">
<p>If you&#8217;re embedding Vert.x then you simply create an instance as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.Vertx
def vertx = Vertx.vertx()</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;re using Verticles</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Most applications will only need a single Vert.x instance, but it&#8217;s possible to create multiple Vert.x instances if you
require, for example, isolation between the event bus or different groups of servers and clients.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_specifying_options_when_creating_a_vertx_object">Specifying options when creating a Vertx object</h3>
<div class="paragraph">
<p>When creating a Vertx object you can also specify options if the defaults aren&#8217;t right for you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.Vertx
def vertx = Vertx.vertx([
  workerPoolSize:40
])</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code><a href="../cheatsheet/VertxOptions.html">VertxOptions</a></code> object has many settings and allows you to configure things like clustering,
high availability, pool sizes and various other settings. The Javadoc describes all the settings in detail.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_clustered_vert_x_object">Creating a clustered Vert.x object</h3>
<div class="paragraph">
<p>If you&#8217;re creating a <strong>clustered Vert.x</strong> (See the section on the <a href="#event_bus">event bus</a> for more information
on clustering the event bus), then you will normally use the asynchronous variant to create the Vertx object.</p>
</div>
<div class="paragraph">
<p>This is because it usually takes some time (maybe a few seconds) for the different Vert.x instances in a cluster to
group together. During that time, we don&#8217;t want to block the calling thread, so we give the result to you asynchronously.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_are_you_fluent">Are you fluent?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You may have noticed that in the previous examples a <strong>fluent</strong> API was used.</p>
</div>
<div class="paragraph">
<p>A fluent API is where multiple methods calls can be chained together. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">request.response().putHeader("Content-Type", "text/plain").write("some text").end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a common pattern throughout Vert.x APIs, so get used to it.</p>
</div>
<div class="paragraph">
<p>Chaining calls like this allows you to write code that&#8217;s a little bit less verbose. Of course, if you don&#8217;t
like the fluent approach <strong>we don&#8217;t force you</strong> to do it that way, you can happily ignore it if you prefer and write
your code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
response.putHeader("Content-Type", "text/plain")
response.write("some text")
response.end()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_don_t_call_us_we_ll_call_you">Don&#8217;t call us, we&#8217;ll call you.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Vert.x APIs are largely <em>event driven</em>. This means that when things happen in Vert.x that you are interested in,
Vert.x will call you by sending you events.</p>
</div>
<div class="paragraph">
<p>Some example events are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a timer has fired</p>
</li>
<li>
<p>some data has arrived on a socket,</p>
</li>
<li>
<p>some data has been read from disk</p>
</li>
<li>
<p>an exception has occurred</p>
</li>
<li>
<p>an HTTP server has received a request</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You handle events by providing <em>handlers</em> to the Vert.x APIs. For example to receive a timer event every second you
would do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">vertx.setPeriodic(1000, { id -&gt;
  // This handler will get called every second
  println("timer fired!")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or to receive an HTTP request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// Respond to each http request with "Hello World"
server.requestHandler({ request -&gt;
  // This handler will be called every time an HTTP request is received at the server
  request.response().end("hello world!")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some time later when Vert.x has an event to pass to your handler Vert.x will call it <strong>asynchronously</strong>.</p>
</div>
<div class="paragraph">
<p>This leads us to some important concepts in Vert.x:</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_don_t_block_me">Don&#8217;t block me!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With very few exceptions (i.e. some file system operations ending in 'Sync'), none of the APIs in Vert.x block the calling thread.</p>
</div>
<div class="paragraph">
<p>If a result can be provided immediately, it will be returned immediately, otherwise you will usually provide a handler
to receive events some time later.</p>
</div>
<div class="paragraph">
<p>Because none of the Vert.x APIs block threads that means you can use Vert.x to handle a lot of concurrency using
just a small number of threads.</p>
</div>
<div class="paragraph">
<p>With a conventional blocking API the calling thread might block when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reading data from a socket</p>
</li>
<li>
<p>Writing data to disk</p>
</li>
<li>
<p>Sending a message to a recipient and waiting for a reply.</p>
</li>
<li>
<p>&#8230;&#8203; Many other situations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In all the above cases, when your thread is waiting for a result it can&#8217;t do anything else - it&#8217;s effectively useless.</p>
</div>
<div class="paragraph">
<p>This means that if you want a lot of concurrency using blocking APIs then you need a lot of threads to prevent your
application grinding to a halt.</p>
</div>
<div class="paragraph">
<p>Threads have overhead in terms of the memory they require (e.g. for their stack) and in context switching.</p>
</div>
<div class="paragraph">
<p>For the levels of concurrency required in many modern applications, a blocking approach just doesn&#8217;t scale.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reactor_and_multi_reactor">Reactor and Multi-Reactor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We mentioned before that Vert.x APIs are event driven - Vert.x passes events to handlers when they are available.</p>
</div>
<div class="paragraph">
<p>In most cases Vert.x calls your handlers using a thread called an <strong>event loop</strong>.</p>
</div>
<div class="paragraph">
<p>As nothing in Vert.x or your application blocks, the event loop can merrily run around delivering events to different handlers in succession
as they arrive.</p>
</div>
<div class="paragraph">
<p>Because nothing blocks, an event loop can potentially deliver huge amounts of events in a short amount of time.
For example a single event loop can handle many thousands of HTTP requests very quickly.</p>
</div>
<div class="paragraph">
<p>We call this the <a href="http://en.wikipedia.org/wiki/Reactor_pattern">Reactor Pattern</a>.</p>
</div>
<div class="paragraph">
<p>You may have heard of this before - for example Node.js implements this pattern.</p>
</div>
<div class="paragraph">
<p>In a standard reactor implementation there is a <strong>single event loop</strong> thread which runs around in a loop delivering all
events to all handlers as they arrive.</p>
</div>
<div class="paragraph">
<p>The trouble with a single thread is it can only run on a single core at any one time, so if you want your single threaded
reactor application (e.g. your Node.js application) to scale over your multi-core server you have to start up and
manage many different processes.</p>
</div>
<div class="paragraph">
<p>Vert.x works differently here. Instead of a single event loop, each Vertx instance maintains <strong>several event loops</strong>.
By default we choose the number based on the number of available cores on the machine, but this can be overridden.</p>
</div>
<div class="paragraph">
<p>This means a single Vertx process can scale across your server, unlike Node.js.</p>
</div>
<div class="paragraph">
<p>We call this pattern the <strong>Multi-Reactor Pattern</strong> to distinguish it from the single threaded reactor pattern.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Even though a Vertx instance maintains multiple event loops, any particular handler will never be executed
concurrently, and in most cases (with the exception of <a href="#worker_verticles">worker verticles</a>) will always be called
using the <strong>exact same event loop</strong>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="golden_rule">The Golden Rule - Don&#8217;t Block the Event Loop</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We already know that the Vert.x APIs are non blocking and won&#8217;t block the event loop, but that&#8217;s not much help if
you block the event loop <strong>yourself</strong> in a handler.</p>
</div>
<div class="paragraph">
<p>If you do that, then that event loop will not be able to do anything else while it&#8217;s blocked. If you block all of the
event loops in Vertx instance then your application will grind to a complete halt!</p>
</div>
<div class="paragraph">
<p>So don&#8217;t do it! <strong>You have been warned</strong>.</p>
</div>
<div class="paragraph">
<p>Examples of blocking include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Thread.sleep()</p>
</li>
<li>
<p>Waiting on a lock</p>
</li>
<li>
<p>Waiting on a mutex or monitor (e.g. synchronized section)</p>
</li>
<li>
<p>Doing a long lived database operation and waiting for a result</p>
</li>
<li>
<p>Doing a complex calculation that takes some significant time.</p>
</li>
<li>
<p>Spinning in a loop</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If any of the above stop the event loop from doing anything else for a <strong>significant amount of time</strong> then you should
go immediately to the naughty step, and await further instructions.</p>
</div>
<div class="paragraph">
<p>So&#8230;&#8203; what is a <strong>significant amount of time</strong>?</p>
</div>
<div class="paragraph">
<p>How long is a piece of string? It really depends on your application and the amount of concurrency you require.</p>
</div>
<div class="paragraph">
<p>If you have a single event loop, and you want to handle 10000 http requests per second, then it&#8217;s clear that each request
can&#8217;t take more than 0.1 ms to process, so you can&#8217;t block for any more time than that.</p>
</div>
<div class="paragraph">
<p><strong>The maths is not hard and shall be left as an exercise for the reader.</strong></p>
</div>
<div class="paragraph">
<p>If your application is not responsive it might be a sign that you are blocking an event loop somewhere. To help
you diagnose such issues, Vert.x will automatically log warnings if it detects an event loop hasn&#8217;t returned for
some time. If you see warnings like these in your logs, then you should investigate.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Thread vertx-eventloop-thread-3 has been blocked for 20458 ms</pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x will also provide stack traces to pinpoint exactly where the blocking is occurring.</p>
</div>
<div class="paragraph">
<p>If you want to turn of these warnings or change the settings, you can do that in the
<code><a href="../cheatsheet/VertxOptions.html">VertxOptions</a></code> object before creating the Vertx object.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="blocking_code">Running blocking code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a perfect world, there will be no war or hunger, all APIs will be written asynchronously and bunny rabbits will
skip hand-in-hand with baby lambs across sunny green meadows.</p>
</div>
<div class="paragraph">
<p><strong>But.. the real world is not like that. (Have you watched the news lately?)</strong></p>
</div>
<div class="paragraph">
<p>Fact is, many, if not most libraries, especially in the JVM ecosystem have synchronous APIs and many of the methods are
likely to block. A good example is the JDBC API - it&#8217;s inherently asynchronous, and no matter how hard it tries, Vert.x
cannot sprinkle magic pixie dust on it to make it asynchronous.</p>
</div>
<div class="paragraph">
<p>We&#8217;re not going to rewrite everything to be asynchronous overnight so we need to provide you a way to use "traditional"
blocking APIs safely within a Vert.x application.</p>
</div>
<div class="paragraph">
<p>As discussed before, you can&#8217;t call blocking operations directly from an event loop, as that would prevent it
from doing any other useful work. So how can you do this?</p>
</div>
<div class="paragraph">
<p>It&#8217;s done by calling <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#executeBlocking(io.vertx.core.Handler,%20io.vertx.core.Handler)">executeBlocking</a></code> specifying both the blocking code to execute and a
result handler to be called back asynchronous when the blocking code has been executed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">vertx.executeBlocking({ future -&gt;
  // Call some blocking API that takes a significant amount of time to return
  def result = someAPI.blockingMethod("hello")
  future.complete(result)
}, { res -&gt;
  println("The result is: ${res.result()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative way to run blocking code is to use a <a href="#worker_verticles">worker verticle</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_verticles">Verticles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x comes with a simple, scalable, <em>actor-like</em> deployment and concurrency model out of the box that
you can use to save you writing your own.</p>
</div>
<div class="paragraph">
<p><strong>This model is entirely optional and Vert.x does not force you to create your applications in this way if you don&#8217;t
want to.</strong>.</p>
</div>
<div class="paragraph">
<p>The model does not claim to be a strict actor-model implementation, but it does share similarities especially
with respect to concurrency, scaling and deployment.</p>
</div>
<div class="paragraph">
<p>To use this model, you write your code as set of <strong>verticles</strong>.</p>
</div>
<div class="paragraph">
<p>Verticles are chunks of code that get deployed and
run by Vert.x. Verticles can be written in any of the languages that Vert.x supports and a single application
can include verticles written in multiple languages.</p>
</div>
<div class="paragraph">
<p>You can think of a verticle as a bit like an actor in the <a href="http://en.wikipedia.org/wiki/Actor_model">Actor Model</a>.</p>
</div>
<div class="paragraph">
<p>An application would typically be composed of many verticle instances running in the same Vert.x instance at the same
time. The different verticle instances communicate with each other by sending messages on the <a href="#event_bus">event bus</a>.</p>
</div>
<div class="sect2">
<h3 id="_writing_verticles">Writing Verticles</h3>
<div class="paragraph">
<p>Todo verticles for Groovy.</p>
</div>
</div>
<div class="sect2">
<h3 id="_verticle_types">Verticle Types</h3>
<div class="paragraph">
<p>There are three different types of verticles:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Standard Verticles</dt>
<dd>
<p>These are the most common and useful type - they are always executed using an event loop thread.
We&#8217;ll discuss this more in the next section.</p>
</dd>
<dt class="hdlist1">Worker Verticles</dt>
<dd>
<p>These run using a thread from the worker pool. An instance is never executed concurrently by more
than one thread.</p>
</dd>
<dt class="hdlist1">Multi-threaded worker verticles</dt>
<dd>
<p>These run using a thread from the worker pool. An instance can be executed concurrently by more
than one thread.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_standard_verticles">Standard verticles</h3>
<div class="paragraph">
<p>Standard verticles are assigned an event loop thread when they are created and the start method is called with that
event loop. When you call any other methods that takes a handler on a core API from an event loop then Vert.x
will guarantee that those handlers, when called, will be executed on the same event loop.</p>
</div>
<div class="paragraph">
<p>This means we can guarantee that all the code in your verticle instance is always executed on the same event loop (as
long as you don&#8217;t create your own threads and call it!).</p>
</div>
<div class="paragraph">
<p>This means you can write all the code in your application as single threaded and let Vert.x worrying about the threading
and scaling. No more worrying about synchronized and volatile any more, and you also avoid many other cases of race conditions
and deadlock so prevalent when doing hand-rolled 'traditional' multi-threaded application development.</p>
</div>
</div>
<div class="sect2">
<h3 id="worker_verticles">Worker verticles</h3>
<div class="paragraph">
<p>A worker verticle is just like a standard verticle but it&#8217;s executed not using an event loop, but using a thread from
the Vert.x worker thread pool.</p>
</div>
<div class="paragraph">
<p>Worker verticles are designed for calling blocking code, as they won&#8217;t block any event loops.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t want to use a worker verticle to run blocking code, you can also run <a href="#blocking_code">inline blocking code</a>
directly while on an event loop.</p>
</div>
<div class="paragraph">
<p>If you want to deploy a verticle as a worker verticle you do that with <code><a href="../cheatsheet/DeploymentOptions.html#worker">worker</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  worker:true
]
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Worker verticle instances are never executed concurrently by Vert.x by more than one thread, but can executed by
different threads at different times.</p>
</div>
<div class="sect3">
<h4 id="_multi_threaded_worker_verticles">Multi-threaded worker verticles</h4>
<div class="paragraph">
<p>A multi-threaded worker verticle is just like a normal worker verticle but it <strong>can</strong> be executed concurrently by
different threads.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Multi-threaded worker verticles are an advanced feature and most applications will have no need for them.
Because of the concurrency in these verticles you have to be very careful to keep the verticle in a consistent state
using standard Java techniques for multi-threaded programming.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deploying_verticles_programmatically">Deploying verticles programmatically</h3>
<div class="paragraph">
<p>You can deploy a verticle using one of the <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#deployVerticle(io.vertx.core.Verticle)">deployVerticle</a></code> method, specifying a verticle
name or you can pass in a verticle instance you have already created yourself.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Deploying Verticle <strong>instances</strong> is Java only.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">todo</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also deploy verticles by specifying the verticle <strong>name</strong>.</p>
</div>
<div class="paragraph">
<p>The verticle name is used to look up the specific <code><a href="groovydoc/io/vertx/groovy/core/spi/VerticleFactory.html">VerticleFactory</a></code> that will be used to
instantiate the actual verticle instance(s).</p>
</div>
<div class="paragraph">
<p>Different verticle factories are available for instantiating verticles in different languages and for various other
reasons such as loading services and getting verticles from Maven at run-time.</p>
</div>
<div class="paragraph">
<p>This allows you to deploy verticles written in any language from any other language that Vert.x supports.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of deploying some different types of verticles:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// Deploy a Java verticle - the name is the fully qualified class name of the verticle class
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle")

// Deploy a JavaScript verticle
vertx.deployVerticle("verticles/myverticle.js")

// Deploy a Ruby verticle verticle
vertx.deployVerticle("verticles/my_verticle.rb")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rules_for_mapping_a_verticle_name_to_a_verticle_factory">Rules for mapping a verticle name to a verticle factory</h3>
<div class="paragraph">
<p>When deploying verticle(s) using a name, the name is used to select the actual verticle factory that will instantiate
the verticle(s).</p>
</div>
<div class="paragraph">
<p>Verticle names can have a prefix - which is a string followed by a colon, which if present will be used to look-up the factory, e.g.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>js:foo.js // Use the JavaScript verticle factory
groovy:com.mycompany.SomeGroovyCompiledVerticle // Use the Groovy verticle factory
service:com.mycompany:myorderservice // Uses the service verticle factory</pre>
</div>
</div>
<div class="paragraph">
<p>If no prefix is present, Vert.x will look for a suffix and use that to lookup the factory, e.g.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>foo.js // Will also use the JavaScript verticle factory
SomeScript.groovy // Will use the Groovy verticle factory</pre>
</div>
</div>
<div class="paragraph">
<p>If no prefix or suffix is present, Vert.x will assume it&#8217;s a Java fully qualified class name (FQCN) and try
and instantiate that.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_are_verticle_factories_located">How are Verticle Factories located?</h3>
<div class="paragraph">
<p>Most Verticle factories are loaded from the classpath and registered at Vert.x startup.</p>
</div>
<div class="paragraph">
<p>You can also programmatically register and unregister verticle factories using <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#registerVerticleFactory(io.vertx.core.spi.VerticleFactory)">registerVerticleFactory</a></code>
and <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#unregisterVerticleFactory(io.vertx.core.spi.VerticleFactory)">unregisterVerticleFactory</a></code> if you wish.</p>
</div>
</div>
<div class="sect2">
<h3 id="_waiting_for_deployment_to_complete">Waiting for deployment to complete</h3>
<div class="paragraph">
<p>Verticle deployment is asynchronous and may complete some time after the call to deploy has returned.</p>
</div>
<div class="paragraph">
<p>If you want to be notified when deployment is complete you can deploy specifying a completion handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", { res -&gt;
  if (res.succeeded()) {
    println("Deployment id is: ${res.result()}")
  } else {
    println("Deployment failed!")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The completion handler will be passed a result containing the deployment ID string, if deployment succeeded.</p>
</div>
<div class="paragraph">
<p>This deployment ID can be used later if you want to undeploy the deployment.</p>
</div>
</div>
<div class="sect2">
<h3 id="_undeploying_verticle_deployments">Undeploying verticle deployments</h3>
<div class="paragraph">
<p>Deployments can be undeployed with <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#undeploy(java.lang.String)">undeploy</a></code>.</p>
</div>
<div class="paragraph">
<p>Un-deployment is itself asynchronous so if you want to be notified when un-deployment is complete you can deploy specifying a completion handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">vertx.undeploy(deploymentID, { res -&gt;
  if (res.succeeded()) {
    println("Undeployed ok")
  } else {
    println("Undeploy failed!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_specifying_number_of_verticle_instances">Specifying number of verticle instances</h3>
<div class="paragraph">
<p>When deploying a verticle using a verticle name, you can specify the number of verticle instances that you
want to deploy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  instances:16
]
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is useful for scaling easily across multiple cores. For example you might have a web-server verticle to deploy
and multiple cores on your machine, so you want to deploy multiple instances to take utilise all the cores.</p>
</div>
</div>
<div class="sect2">
<h3 id="_passing_configuration_to_a_verticle">Passing configuration to a verticle</h3>
<div class="paragraph">
<p>Configuration in the form of JSON can be passed to a verticle at deployment time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = [
  name:"tim",
  directory:"/blah"
]
def options = [
  config:config
]
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This configuration is then available via the <code><a href="groovydoc/io/vertx/groovy/core/Context.html">Context</a></code> object.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_accessing_environment_variables_in_a_verticle">Accessing environment variables in a Verticle</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_verticle_isolation_groups">Verticle Isolation Groups</h3>
<div class="paragraph">
<p>By default, Vert.x has a <em>flat classpath</em>. I.e, it does everything, including deploying verticles without messing
with class-loaders. In the majority of cases this is the simplest, clearest and sanest thing to do.</p>
</div>
<div class="paragraph">
<p>However, in some cases you may want to deploy a verticle so the classes of that verticle are isolated from others in
your application.</p>
</div>
<div class="paragraph">
<p>This might be the case, for example, if you want to deploy two different versions of a verticle with the same class name
in the same Vert.x instance, or if you have two different verticles which use different versions of the same jar library.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Use this feature with caution. Class-loaders can be a can of worms, and can make debugging difficult, amongst
other things.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of using an isolation group to isolate a verticle deployment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">todo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isolation groups are identified by a name, and the name can be used between different deployments if you want them
to share an isolated class-loader.</p>
</div>
<div class="paragraph">
<p>Extra classpath entries can also be provided with <code><a href="../cheatsheet/DeploymentOptions.html#extraClasspath">extraClasspath</a></code> so they
can locate resources that are isolated to them.</p>
</div>
</div>
<div class="sect2">
<h3 id="_high_availability">High Availability</h3>
<div class="paragraph">
<p>Verticles can be deployed with High Availability (HA) enabled.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_running_verticles_from_the_command_line">Running Verticles from the command line</h3>
<div class="paragraph">
<p>You can use Vert.x directly in your Maven or Gradle projects in the normal way by adding a dependency to the Vert.x
core library and hacking from there.</p>
</div>
<div class="paragraph">
<p>However you can also run Vert.x verticles directly from the command line if you wish.</p>
</div>
<div class="paragraph">
<p>To do this you need to download and install a Vert.x distribution, and add the <code>bin</code> directory of the installation
to your <code>PATH</code> environment variable. Also make sure you have a Java 8 JDK on your <code>PATH</code>.</p>
</div>
<div class="paragraph">
<p>You can now run verticles by using the <code>vertx run</code> command. Here are some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre># Run a JavaScript verticle
vertx run my_verticle.js

# Run a Ruby verticle
vertx run a_n_other_verticle.rb

# Run a Groovy script verticle, clustered
vertx run FooVerticle.groovy -cluster</pre>
</div>
</div>
<div class="paragraph">
<p>You can even run Java source verticles without compiling them first!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>vertx run SomeJavaSourceFile.java</pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x will compile the Java source file on the fly before running it. This is really useful for quickly
prototyping verticles and great for demos. No need to set-up a Maven or Gradle build first to get going!</p>
</div>
<div class="paragraph">
<p>For full information on the various options available when executing <code>vertx</code> on the command line,
type <code>vertx</code> at the command line.</p>
</div>
</div>
<div class="sect2">
<h3 id="_causing_vert_x_to_exit">Causing Vert.x to exit</h3>
<div class="paragraph">
<p>Threads maintained by Vert.x instances are not daemon threads so they will prevent the JVM from exiting.</p>
</div>
<div class="paragraph">
<p>If you are embedding Vert.x and you have finished with it, you can call <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#close()">close</a></code> to close it
down.</p>
</div>
<div class="paragraph">
<p>This will shut-down all internal thread pools and close other resources, and will allow the JVM to exit.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_context_object">The Context object</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_executing_periodic_and_delayed_actions">Executing periodic and delayed actions</h3>
<div class="paragraph">
<p>It&#8217;s very common in Vert.x to want to perform an action after a delay, or periodically.</p>
</div>
<div class="paragraph">
<p>In standard verticles you can&#8217;t just make the thread sleep to introduce a delay, as that will block the event loop thread.</p>
</div>
<div class="paragraph">
<p>Instead you use Vert.x timers. Timers can be <strong>one-shot</strong> or <strong>periodic</strong>. We&#8217;ll discuss both</p>
</div>
<div class="sect3">
<h4 id="_one_shot_timers">One-shot Timers</h4>
<div class="paragraph">
<p>A one shot timer calls an event handler after a certain delay, expressed in milliseconds.</p>
</div>
<div class="paragraph">
<p>To set a timer to fire once you use <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#setTimer(long,%20io.vertx.core.Handler)">setTimer</a></code> method passing in the delay and a handler</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def timerID = vertx.setTimer(1000, { id -&gt;
  println("And one second later this is printed")
})

println("First this is printed")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value is a unique timer id which can later be used to cancel the timer. The handler is also passed the timer id.</p>
</div>
</div>
<div class="sect3">
<h4 id="_periodic_timers">Periodic Timers</h4>
<div class="paragraph">
<p>You can also set a timer to fire periodically by using <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#setPeriodic(long,%20io.vertx.core.Handler)">setPeriodic</a></code>.</p>
</div>
<div class="paragraph">
<p>There will be an initial delay equal to the period.</p>
</div>
<div class="paragraph">
<p>The return value of <code>setPeriodic</code> is a unique timer id (long). This can be later used if the timer needs to be cancelled.</p>
</div>
<div class="paragraph">
<p>The argument passed into the timer event handler is also the unique timer id:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def timerID = vertx.setPeriodic(1000, { id -&gt;
  println("And every second this is printed")
})

println("First this is printed")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cancelling_timers">Cancelling timers</h4>
<div class="paragraph">
<p>To cancel a periodic timer, call <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#cancelTimer(long)">cancelTimer</a></code> specifying the timer id. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">vertx.cancelTimer(timerID)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_automatic_clean_up_in_verticles">Automatic clean-up in verticles</h4>
<div class="paragraph">
<p>If you&#8217;re creating timers from inside verticles, those timers will be automatically closed
when the verticle is undeployed.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="event_bus">The Event Bus</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code><a href="groovydoc/io/vertx/groovy/core/eventbus/EventBus.html">event bus</a></code> is the <strong>nervous system</strong> of Vert.x.</p>
</div>
<div class="paragraph">
<p>There is a single event bus instance for every Vert.x instance and it is obtained using the method <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#eventBus()">eventBus</a></code>.</p>
</div>
<div class="paragraph">
<p>The event bus allows different parts of your application to communicate with each other irrespective of what language they are written in,
and whether they&#8217;re in the same Vert.x instance, or in a different Vert.x instance.</p>
</div>
<div class="paragraph">
<p>It can even be bridged to allow client side JavaScript running in a browser to communicate on the same event bus.</p>
</div>
<div class="paragraph">
<p>The event bus forms a distributed peer-to-peer messaging system spanning multiple server nodes and multiple browsers.</p>
</div>
<div class="paragraph">
<p>The event bus supports publish/subscribe, point to point, and request-response messaging.</p>
</div>
<div class="paragraph">
<p>The event bus API is very simple. It basically involves registering handlers, unregistering handlers and
sending and publishing messages.</p>
</div>
<div class="paragraph">
<p>First some theory:</p>
</div>
<div class="sect2">
<h3 id="_the_theory">The Theory</h3>
<div class="sect3">
<h4 id="_addressing">Addressing</h4>
<div class="paragraph">
<p>Messages are sent on the event bus to an <strong>address</strong>.</p>
</div>
<div class="paragraph">
<p>Vert.x doesn&#8217;t bother with any fancy addressing schemes. In Vert.x an address is simply a string.
Any string is valid. However it is wise to use some kind of scheme, e.g. using periods to demarcate a namespace.</p>
</div>
<div class="paragraph">
<p>Some examples of valid addresses are europe.news.feed1, acme.games.pacman, sausages, and X.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handlers">Handlers</h4>
<div class="paragraph">
<p>Messages are received in handlers. You register a handler at an address.</p>
</div>
<div class="paragraph">
<p>Many different handlers can be registered at the same address.</p>
</div>
<div class="paragraph">
<p>A single handler can be registered at many different addresses.</p>
</div>
</div>
<div class="sect3">
<h4 id="_publish_subscribe_messaging">Publish / subscribe messaging</h4>
<div class="paragraph">
<p>The event bus supports <strong>publishing</strong> messages.</p>
</div>
<div class="paragraph">
<p>Messages are published to an address. Publishing means delivering the message
to all handlers that are registered at that address.</p>
</div>
<div class="paragraph">
<p>This is the familiar <strong>publish/subscribe</strong> messaging pattern.</p>
</div>
</div>
<div class="sect3">
<h4 id="_point_to_point_and_request_response_messaging">Point to point and Request-Response messaging</h4>
<div class="paragraph">
<p>The event bus also supports <strong>point to point</strong> messaging.</p>
</div>
<div class="paragraph">
<p>Messages are sent to an address. Vert.x will then route it to just one of the handlers registered at that address.</p>
</div>
<div class="paragraph">
<p>If there is more than one handler registered at the address,
one will be chosen using a non-strict round-robin algorithm.</p>
</div>
<div class="paragraph">
<p>With point to point messaging, an optional reply handler can be specified when sending the message.</p>
</div>
<div class="paragraph">
<p>When a message is received by a recipient, and has been handled, the recipient can optionally decide to reply to
the message. If they do so the reply handler will be called.</p>
</div>
<div class="paragraph">
<p>When the reply is received back at the sender, it too can be replied to. This can be repeated ad-infinitum,
and allows a dialog to be set-up between two different verticles.</p>
</div>
<div class="paragraph">
<p>This is a common messaging pattern called the <strong>request-response</strong> pattern.</p>
</div>
</div>
<div class="sect3">
<h4 id="_best_effort_delivery">Best-effort delivery</h4>
<div class="paragraph">
<p>Vert.x does it&#8217;s best to deliver messages and won&#8217;t consciously throw them away. This is called <strong>best-effort</strong> delivery.</p>
</div>
<div class="paragraph">
<p>However, in case of failure of all or parts of the event bus, there is a possibility messages will be lost.</p>
</div>
<div class="paragraph">
<p>If your application cares about lost messages, you should code your handlers to be idempotent, and your senders
to retry after recovery.</p>
</div>
</div>
<div class="sect3">
<h4 id="_types_of_messages">Types of messages</h4>
<div class="paragraph">
<p>Out of the box Vert.x allows any primitive/simple type, String, or <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html">buffers</a></code> to
be sent as messages.</p>
</div>
<div class="paragraph">
<p>However it&#8217;s a convention and common practice in Vert.x to send messages as <a href="http://json.org/">JSON</a></p>
</div>
<div class="paragraph">
<p>JSON is very easy to create, read and parse in all the languages that Vert.x supports so it has become a kind of
<em>lingua franca</em> for Vert.x.</p>
</div>
<div class="paragraph">
<p>However you are not forced to use JSON if you don&#8217;t want to.</p>
</div>
<div class="paragraph">
<p>The event bus is very flexible and also supports sending arbitrary objects over the event bus.
You do this by defining a <code><a href="groovydoc/io/vertx/groovy/core/eventbus/MessageCodec.html">codec</a></code> for the objects you want to send.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_event_bus_api">The Event Bus API</h3>
<div class="paragraph">
<p>Let&#8217;s jump into the API</p>
</div>
<div class="sect3">
<h4 id="_getting_the_event_bus">Getting the event bus</h4>
<div class="paragraph">
<p>You get a reference to the event bus as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def eb = vertx.eventBus()</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a single instance of the event bus per Vert.x instance.</p>
</div>
</div>
<div class="sect3">
<h4 id="_registering_handlers">Registering Handlers</h4>
<div class="paragraph">
<p>This simplest way to register a handler is using <code><a href="groovydoc/io/vertx/groovy/core/eventbus/EventBus.html#consumer(java.lang.String,%20io.vertx.core.Handler)">consumer</a></code>.
Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def eb = vertx.eventBus()

eb.consumer("news.uk.sport", { message -&gt;
  println("I have received a message: ${message.body()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a message arrives for your handler, your handler will be called, passing in the <code><a href="groovydoc/io/vertx/groovy/core/eventbus/Message.html">message</a></code>.</p>
</div>
<div class="paragraph">
<p>The object returned from call to consumer() is an instance of <code><a href="groovydoc/io/vertx/groovy/core/eventbus/MessageConsumer.html">MessageConsumer</a></code></p>
</div>
<div class="paragraph">
<p>This object can subsequently be used to unregister the handler, or use the handler as a stream.</p>
</div>
<div class="paragraph">
<p>Alternatively you can use <code><a href="groovydoc/io/vertx/groovy/core/eventbus/EventBus.html#consumer(java.lang.String,%20io.vertx.core.Handler)">consumer</a></code> to
to return a MessageConsumer with no handler set, and then set the handler on that. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def eb = vertx.eventBus()

def consumer = eb.consumer("news.uk.sport")
consumer.handler({ message -&gt;
  println("I have received a message: ${message.body()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>When registering a handler on a clustered event bus, it can take some time for the registration to reach all
nodes of the cluster.</p>
</div>
<div class="paragraph">
<p>If you want to be notified when this has completed, you can register a <code><a href="groovydoc/io/vertx/groovy/core/eventbus/MessageConsumer.html#completionHandler(io.vertx.core.Handler)">completion handler</a></code>
on the MessageConsumer object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">consumer.completionHandler({ res -&gt;
  if (res.succeeded()) {
    println("The handler registration has reached all nodes")
  } else {
    println("Registration failed!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_un_registering_handlers">Un-registering Handlers</h4>
<div class="paragraph">
<p>To unregister a handler, call <code><a href="groovydoc/io/vertx/groovy/core/eventbus/MessageConsumer.html#unregister()">unregister</a></code>.</p>
</div>
<div class="paragraph">
<p>If you are on a clustered event bus, un-registering can take some time to propagate across the nodes, if you want to
be notified when this is complete use <code><a href="groovydoc/io/vertx/groovy/core/eventbus/MessageConsumer.html#unregister(io.vertx.core.Handler)">unregister</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">consumer.unregister({ res -&gt;
  if (res.succeeded()) {
    println("The handler un-registration has reached all nodes")
  } else {
    println("Un-registration failed!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_publishing_messages">Publishing messages</h4>
<div class="paragraph">
<p>Publishing a message is simple. Just use <code><a href="groovydoc/io/vertx/groovy/core/eventbus/EventBus.html#publish(java.lang.String,%20java.lang.Object)">publish</a></code> specifying the
address to publish it to.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">eventBus.publish("news.uk.sport", "Yay! Someone kicked a ball")</code></pre>
</div>
</div>
<div class="paragraph">
<p>That message will then be delivered to all handlers registered against the address news.uk.sport.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sending_messages">Sending messages</h4>
<div class="paragraph">
<p>Sending a message will result in only one handler registered at the address receiving the message.
This is the point to point messaging pattern. The handler is chosen in a non-strict round-robin fashion.</p>
</div>
<div class="paragraph">
<p>You can send a message with <code><a href="groovydoc/io/vertx/groovy/core/eventbus/EventBus.html#send(java.lang.String,%20java.lang.Object)">send</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">eventBus.send("news.uk.sport", "Yay! Someone kicked a ball")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_setting_headers_on_messages">Setting headers on messages</h4>
<div class="paragraph">
<p>Messages sent over the event bus can also contain headers. This can be specified by providing a
<code><a href="../cheatsheet/DeliveryOptions.html">DeliveryOptions</a></code> when sending or publishing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">todo</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_message_object">The Message object</h4>
<div class="paragraph">
<p>The object you receive in a message handler is a <code><a href="groovydoc/io/vertx/groovy/core/eventbus/Message.html">Message</a></code>.</p>
</div>
<div class="paragraph">
<p>The <code><a href="groovydoc/io/vertx/groovy/core/eventbus/Message.html#body()">body</a></code> of the message corresponds to the object that was sent or published.</p>
</div>
<div class="paragraph">
<p>The headers of the message are available with <code><a href="groovydoc/io/vertx/groovy/core/eventbus/Message.html#headers()">headers</a></code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_replying_to_messages">Replying to messages</h4>
<div class="paragraph">
<p>Sometimes after you send a message you want to receive a reply from the recipient.
This is known as the <strong>request-response pattern</strong>.</p>
</div>
<div class="paragraph">
<p>To do this you can specify a reply handler when sending the message.</p>
</div>
<div class="paragraph">
<p>When the receiver receives the message they can reply to it by calling <code><a href="groovydoc/io/vertx/groovy/core/eventbus/Message.html#reply(java.lang.Object)">reply</a></code>.</p>
</div>
<div class="paragraph">
<p>When this happens it causes a reply to be sent back to the sender and the reply handler is invoked with the reply.</p>
</div>
<div class="paragraph">
<p>An example will make this clear:</p>
</div>
<div class="paragraph">
<p>The receiver:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def consumer = eventBus.consumer("news.uk.sport")
consumer.handler({ message -&gt;
  println("I have received a message: ${message.body()}")
  message.reply("how interesting!")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The sender:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">eventBus.send("news.uk.sport", "Yay! Someone kicked a ball across a patch of grass", { ar -&gt;
  if (ar.succeeded()) {
    println("Received reply: ${ar.result().body()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The replies themselves can also be replied to so you can create a dialog between two different parties
consisting of multiple rounds.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sending_with_timeouts">Sending with timeouts</h4>
<div class="paragraph">
<p>When sending a message with a reply handler you can specify a timeout in the <code><a href="../cheatsheet/DeliveryOptions.html">DeliveryOptions</a></code>.</p>
</div>
<div class="paragraph">
<p>If a reply is not received within that time, the reply handler will be called with a failure.</p>
</div>
<div class="paragraph">
<p>The default timeout is 30 seconds.</p>
</div>
</div>
<div class="sect3">
<h4 id="_send_failures">Send Failures</h4>
<div class="paragraph">
<p>Message sends can fail for other reasons, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are no handlers available to send the message to</p>
</li>
<li>
<p>The recipient has explicitly failed the message using <code><a href="groovydoc/io/vertx/groovy/core/eventbus/Message.html#fail(int,%20java.lang.String)">fail</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In all cases the reply handler will be called with the specific failure.</p>
</div>
</div>
<div class="sect3">
<h4 id="_message_codecs">Message Codecs</h4>
<div class="paragraph">
<p>Message codecs are available exclusively with the Java api.</p>
</div>
</div>
<div class="sect3">
<h4 id="_clustered_event_bus">Clustered Event Bus</h4>
<div class="paragraph">
<p>The event bus doesn&#8217;t just exist in a single Vert.x instance. By clustering different Vert.x instances together on
your network they can form a single, distributed, event bus.</p>
</div>
</div>
<div class="sect3">
<h4 id="_clustering_programmatically">Clustering programmatically</h4>
<div class="paragraph">
<p>If you&#8217;re creating your Vert.x instance programmatically you get a clustered event bus by configuring the Vert.x
instance as clustered;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.Vertx
def options = [:]
Vertx.clusteredVertx(options, { res -&gt;
  if (res.succeeded()) {
    def vertx = res.result()
    def eventBus = vertx.eventBus()
    println("We now have a clustered event bus: ${eventBus}")
  } else {
    println("Failed: ${res.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should also make sure you have a <code><a href="groovydoc/io/vertx/groovy/core/spi/cluster/ClusterManager.html">ClusterManager</a></code> implementation on your classpath,
for example the default .</p>
</div>
</div>
<div class="sect3">
<h4 id="_clustering_on_the_command_line">Clustering on the command line</h4>
<div class="paragraph">
<p>You can run Vert.x clustered on the command line with</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vertx run MyVerticle -cluster</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_automatic_clean_up_in_verticles_2">Automatic clean-up in verticles</h3>
<div class="paragraph">
<p>If you&#8217;re registering event bus handlers from inside verticles, those handlers will be automatically unregistered
when the verticle is undeployed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_json">JSON</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Todo json for Groovy.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_buffers">Buffers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most data is shuffled around inside Vert.x using buffers.</p>
</div>
<div class="paragraph">
<p>A buffer is a sequence of zero or more bytes that can read from or written to and which expands automatically as
necessary to accommodate any bytes written to it. You can perhaps think of a buffer as smart byte array.</p>
</div>
<div class="sect2">
<h3 id="_creating_buffers">Creating buffers</h3>
<div class="paragraph">
<p>Buffers can create by using one of the static <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html#buffer()">Buffer.buffer</a></code> methods.</p>
</div>
<div class="paragraph">
<p>Buffers can be initialised from strings or byte arrays, or empty buffers can be created.</p>
</div>
<div class="paragraph">
<p>Here are some examples of creating buffers:</p>
</div>
<div class="paragraph">
<p>Create a new empty buffer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
def buff = Buffer.buffer()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create a buffer from a String. The String will be encoded in the buffer using UTF-8.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
def buff = Buffer.buffer("some string")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create a buffer from a String: The String will be encoded using the specified encoding, e.g:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
def buff = Buffer.buffer("some string", "UTF-16")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create a buffer with an initial size hint. If you know your buffer will have a certain amount of data written to it
you can create the buffer and specify this size. This makes the buffer initially allocate that much memory and is
more efficient than the buffer automatically resizing multiple times as data is written to it.</p>
</div>
<div class="paragraph">
<p>Note that buffers created this way <strong>are empty</strong>. It does not create a buffer filled with zeros up to the specified size.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
def buff = Buffer.buffer(10000)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_writing_to_a_buffer">Writing to a Buffer</h3>
<div class="paragraph">
<p>There are two ways to write to a buffer: appending, and random access.
In either case buffers will always expand automatically to encompass the bytes. It&#8217;s not possible to get
an  with a buffer.</p>
</div>
<div class="sect3">
<h4 id="_appending_to_a_buffer">Appending to a Buffer</h4>
<div class="paragraph">
<p>To append to a buffer, you use the  methods.
Append methods exist for appending various different types.</p>
</div>
<div class="paragraph">
<p>The return value of the  methods is the buffer itself, so these can be chained:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
def buff = Buffer.buffer()

buff.appendInt(123).appendString("hello\n")

socket.write(buff)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_random_access_buffer_writes">Random access buffer writes</h4>
<div class="paragraph">
<p>You can also write into the buffer at a specific index, by using the  methods.
Set methods exist for various different data types. All the set methods take an index as the first argument - this
represents the position in the buffer where to start writing the data.</p>
</div>
<div class="paragraph">
<p>The buffer will always expand as necessary to accommodate the data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
def buff = Buffer.buffer()

buff.setInt(1000, 123)
buff.setString(0, "hello")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reading_from_a_buffer">Reading from a Buffer</h3>
<div class="paragraph">
<p>Data is read from a buffer using the  methods. Get methods exist for various datatypes.
The first argument to these methods is an index in the buffer from where to get the data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
def buff = Buffer.buffer()
for (def i = 0;i &lt; buff.length();4) {
  println("int value at ${i} is ${buff.getInt(i)}")
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_buffer_length">Buffer length</h3>
<div class="paragraph">
<p>Use <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html#length()">length</a></code> to obtain the length of the buffer.
The length of a buffer is the index of the byte in the buffer with the largest index + 1.</p>
</div>
</div>
<div class="sect2">
<h3 id="_copying_buffers">Copying buffers</h3>
<div class="paragraph">
<p>Use <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html#copy()">copy</a></code> to make a copy of the buffer</p>
</div>
</div>
<div class="sect2">
<h3 id="_slicing_buffers">Slicing buffers</h3>
<div class="paragraph">
<p>A sliced buffer is a new buffer which backs onto the original buffer, i.e. it does not copy the underlying data.
Use <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html#slice()">slice</a></code> to create a sliced buffers</p>
</div>
</div>
<div class="sect2">
<h3 id="_buffer_re_use">Buffer re-use</h3>
<div class="paragraph">
<p>After writing a buffer to a socket or other similar place, they cannot be re-used.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_tcp_servers_and_clients">Writing TCP servers and clients</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x allows you to easily write non blocking TCP clients and servers.</p>
</div>
<div class="sect2">
<h3 id="_creating_a_tcp_server">Creating a TCP server</h3>
<div class="paragraph">
<p>The simplest way to create a TCP server, using all default options is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_a_tcp_server">Configuring a TCP server</h3>
<div class="paragraph">
<p>If you don&#8217;t want the default, a server can be configured by passing in a <code><a href="../cheatsheet/NetServerOptions.html">NetServerOptions</a></code>
instance when creating it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  port:4321
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_start_the_server_listening">Start the Server Listening</h3>
<div class="paragraph">
<p>To tell the server to listen for incoming requests you use one of the <code><a href="groovydoc/io/vertx/groovy/core/net/NetServer.html#listen()">listen</a></code>
alternatives.</p>
</div>
<div class="paragraph">
<p>To tell the server to listen at the host and port as specified in the options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer()
server.listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or to specify the host and port in the call to listen, ignoring what is configured in the options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer()
server.listen(1234, "localhost")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default host is <code>0.0.0.0</code> which means 'listen on all available addresses' and the default port is <code>0</code>, which is a
special value that instructs the server to find a random unused local port and use that.</p>
</div>
<div class="paragraph">
<p>The actual bind is asynchronous so the server might not actually be listening until some time <strong>after</strong> the call to
listen has returned.</p>
</div>
<div class="paragraph">
<p>If you want to be notified when the server is actually listening you can provide a handler to the <code>listen</code> call.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer()
server.listen(1234, "localhost", { res -&gt;
  if (res.succeeded()) {
    println("Server is now listening!")
  } else {
    println("Failed to bind!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_listening_on_a_random_port">Listening on a random port</h3>
<div class="paragraph">
<p>If <code>0</code> is used as the listening port, the server will find an unused random port to listen on.</p>
</div>
<div class="paragraph">
<p>To find out the real port the server is listening on you can call <code><a href="groovydoc/io/vertx/groovy/core/net/NetServer.html#actualPort()">actualPort</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer()
server.listen(0, "localhost", { res -&gt;
  if (res.succeeded()) {
    println("Server is now listening on actual port: ${server.actualPort()}")
  } else {
    println("Failed to bind!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_getting_notified_of_incoming_connections">Getting notified of incoming connections</h3>
<div class="paragraph">
<p>To be notified when a connection is made you need to set a <code><a href="groovydoc/io/vertx/groovy/core/net/NetServer.html#connectHandler(io.vertx.core.Handler)">connectHandler</a></code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer()
server.connectHandler({ socket -&gt;
  // Handle the connection in here
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a connection is made the handler will be called with an instance of <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html">NetSocket</a></code>.</p>
</div>
<div class="paragraph">
<p>This is a socket-like interface to the actual connection, and allows you to read and write data as well as do various
other things like close the socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reading_data_from_the_socket">Reading data from the socket</h3>
<div class="paragraph">
<p>To read data from the socket you set the <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html#handler(io.vertx.core.Handler)">handler</a></code> on the
socket.</p>
</div>
<div class="paragraph">
<p>This handler will be called with an instance of <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html">Buffer</a></code> every time data is received on
the socket.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer()
server.connectHandler({ socket -&gt;
  socket.handler({ buffer -&gt;
    println("I received some bytes: ${buffer.length()}")
  })
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_writing_data_to_a_socket">Writing data to a socket</h3>
<div class="paragraph">
<p>You write to a socket using one of <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html#write(io.vertx.core.buffer.Buffer)">write</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer

// Write a buffer
def buffer = Buffer.buffer().appendFloat(12.34f).appendInt(123)
socket.write(buffer)

// Write a string in UTF-8 encoding
socket.write("some data")

// Write a string using the specified encoding
socket.write("some data", "UTF-16")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Write operations are asynchronous and may not occur until some time after the call to write has returned.</p>
</div>
</div>
<div class="sect2">
<h3 id="_closed_handler">Closed handler</h3>
<div class="paragraph">
<p>If you want to be notified when a socket is closed, you can set a <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html#closeHandler(io.vertx.core.Handler)">closeHandler</a></code>
on it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">socket.closeHandler({ v -&gt;
  println("The socket has been closed")
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_exceptions">Handling exceptions</h3>
<div class="paragraph">
<p>You can set an <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html#exceptionHandler(io.vertx.core.Handler)">exceptionHandler</a></code> to receive any
exceptions that happen on the socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_event_bus_write_handler">Event bus write handler</h3>
<div class="paragraph">
<p>Every socket automatically registers a handler on the event bus, and when any buffers are received in this handler,
it writes them to itself.</p>
</div>
<div class="paragraph">
<p>This enables you to write data to a socket which is potentially in a completely different verticle or even in a
different Vert.x instance by sending the buffer to the address of that handler.</p>
</div>
<div class="paragraph">
<p>The address of the handler is given by <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html#writeHandlerID()">writeHandlerID</a></code></p>
</div>
</div>
<div class="sect2">
<h3 id="_local_and_remote_addresses">Local and remote addresses</h3>
<div class="paragraph">
<p>The local address of a <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html">NetSocket</a></code> can be retrieved using <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html#localAddress()">localAddress</a></code>.</p>
</div>
<div class="paragraph">
<p>The remote address, (i.e. the address of the other end of the connection) of a <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html">NetSocket</a></code>
can be retrieved using <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html#remoteAddress()">remoteAddress</a></code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sending_files">Sending files</h3>
<div class="paragraph">
<p>Files can be written to the socket directly using <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html#sendFile(java.lang.String)">sendFile</a></code>. This can be a very
efficient way to send files, as it can be handled by the OS kernel directly where supported by the operating system.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">socket.sendFile("myfile.dat")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_streaming_sockets">Streaming sockets</h3>
<div class="paragraph">
<p>Instances of <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html">NetSocket</a></code> are also <code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html">ReadStream</a></code> and
<code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html">WriteStream</a></code> instances so they can be used to pump data to or from other
read and write streams.</p>
</div>
<div class="paragraph">
<p>See the chapter on <a href="#streams">streams and pumps</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading_connections_to_ssl_tls">Upgrading connections to SSL/TLS</h3>
<div class="paragraph">
<p>A non SSL/TLS connection can be upgraded to SSL/TLS using <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html#upgradeToSsl(io.vertx.core.Handler)">upgradeToSsl</a></code>.</p>
</div>
<div class="paragraph">
<p>The server or client must be configured for SSL/TLS for this to work correctly. Please see the <a href="#ssl">chapter on SSL/TLS</a>
for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_closing_a_tcp_server">Closing a TCP Server</h3>
<div class="paragraph">
<p>Call <code><a href="groovydoc/io/vertx/groovy/core/net/NetServer.html#close()">close</a></code> to close the server. Closing the server closes any open connections
and releases all server resources.</p>
</div>
<div class="paragraph">
<p>The close is actually asynchronous and might not complete until some time after the call has returned.
If you want to be notified when the actual close has completed then you can pass in a handler.</p>
</div>
<div class="paragraph">
<p>This handler will then be called when the close has fully completed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">server.close({ res -&gt;
  if (res.succeeded()) {
    println("Server is now closed")
  } else {
    println("close failed")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_automatic_clean_up_in_verticles_3">Automatic clean-up in verticles</h3>
<div class="paragraph">
<p>If you&#8217;re creating TCP servers and clients from inside verticles, those servers and clients will be automatically closed
when the verticle is undeployed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_scaling_sharing_tcp_servers">Scaling - sharing TCP servers</h3>
<div class="paragraph">
<p>The handlers of any TCP server are always executed on the same event loop thread.</p>
</div>
<div class="paragraph">
<p>This means that if you are running on a server with a lot of cores, and you only have this one instance
deployed then you will have at most one core utilised on your server.</p>
</div>
<div class="paragraph">
<p>In order to utilise more cores of your server you will need to deploy more instances of the server.</p>
</div>
<div class="paragraph">
<p>You can instantiate more instances programmatically in your code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// Create a few instances so we can utilise cores

for (def i = 0;i &lt; 10;i++) {
  def server = vertx.createNetServer()
  server.connectHandler({ socket -&gt;
    socket.handler({ buffer -&gt;
      // Just echo back the data
      socket.write(buffer)
    })
  })
  server.listen(1234, "localhost")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or, if you are using verticles you can simply deploy more instances of your server verticle by using the <code>-instances</code> option
on the command line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vertx run com.mycompany.MyVerticle -instances 10</pre>
</div>
</div>
<div class="paragraph">
<p>or when programmatically deploying your verticle</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  instances:10
]
vertx.deployVerticle("com.mycompany.MyVerticle", options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you do this you will find the echo server works functionally identically to before, but all your cores on your
server can be utilised and more work can be handled.</p>
</div>
<div class="paragraph">
<p>At this point you might be asking yourself <strong>'How can you have more than one server listening on the
same host and port? Surely you will get port conflicts as soon as you try and deploy more than one instance?'</strong></p>
</div>
<div class="paragraph">
<p><em>Vert.x does a little magic here.*</em></p>
</div>
<div class="paragraph">
<p>When you deploy another server on the same host and port as an existing server it doesn&#8217;t actually try and create a
new server listening on the same host/port.</p>
</div>
<div class="paragraph">
<p>Instead it internally maintains just a single server, and, as incoming connections arrive it distributes
them in a round-robin fashion to any of the connect handlers.</p>
</div>
<div class="paragraph">
<p>Consequently Vert.x TCP servers can scale over available cores while each instance remains single threaded.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_tcp_client">Creating a TCP client</h3>
<div class="paragraph">
<p>The simplest way to create a TCP client, using all default options is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createNetClient()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_a_tcp_client">Configuring a TCP client</h3>
<div class="paragraph">
<p>If you don&#8217;t want the default, a client can be configured by passing in a <code><a href="../cheatsheet/NetClientOptions.html">NetClientOptions</a></code>
instance when creating it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  connectTimeout:10000
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_making_connections">Making connections</h3>
<div class="paragraph">
<p>To make a connection to a server you use <code><a href="groovydoc/io/vertx/groovy/core/net/NetClient.html#connect(int,%20java.lang.String,%20io.vertx.core.Handler)">connect</a></code>,
specifying the port and host of the server and a handler that will be called with a result containing the
<code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html">NetSocket</a></code> when connection is successful or with a failure if connection failed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  connectTimeout:10000
]
def client = vertx.createNetClient(options)
client.connect(4321, "localhost", { res -&gt;
  if (res.succeeded()) {
    println("Connected!")
    def socket = res.result()
  } else {
    println("Failed to connect: ${res.cause().getMessage()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_connection_attempts">Configuring connection attempts</h3>
<div class="paragraph">
<p>A client can be configured to automatically retry connecting to the server in the event that it cannot connect.
This is configured with <code><a href="../cheatsheet/NetClientOptions.html#reconnectInterval">reconnectInterval</a></code> and
<code><a href="../cheatsheet/NetClientOptions.html#reconnectAttempts">reconnectAttempts</a></code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Currently Vert.x will not attempt to reconnect if a connection fails, reconnect attempts and interval
only apply to creating initial connections.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [:]
options.reconnectAttempts = 10.reconnectInterval = 500

def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, multiple connection attempts are disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="ssl">Configuring servers and clients to work with SSL/TLS</h3>
<div class="paragraph">
<p>TCP clients and servers can be configured to use <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a>
- earlier versions of TLS were known as SSL.</p>
</div>
<div class="paragraph">
<p>The APIs of the servers and clients are identical whether or not SSL/TLS is used, and it&#8217;s enabled by configuring
the <code><a href="../cheatsheet/NetClientOptions.html">NetClientOptions</a></code> or <code><a href="../cheatsheet/NetServerOptions.html">NetServerOptions</a></code> instances used
to create the servers or clients.</p>
</div>
<div class="sect3">
<h4 id="_enabling_ssl_tls_on_the_server">Enabling SSL/TLS on the server</h4>
<div class="paragraph">
<p>SSL/TLS is enabled with  <code><a href="../cheatsheet/NetServerOptions.html#ssl">ssl</a></code>.</p>
</div>
<div class="paragraph">
<p>By default it is disabled.</p>
</div>
</div>
<div class="sect3">
<h4 id="_specifying_key_certificate_for_the_server">Specifying key/certificate for the server</h4>
<div class="paragraph">
<p>SSL/TLS servers usually provide certificates to clients in order verify their identity to clients.</p>
</div>
<div class="paragraph">
<p>Certificates/keys can be configured for servers in several ways:</p>
</div>
<div class="paragraph">
<p>The first method is by specifying the location of a Java key-store which contains the certificate and private key.</p>
</div>
<div class="paragraph">
<p>Java key stores can be managed with the <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool</a>
utility which ships with the JDK.</p>
</div>
<div class="paragraph">
<p>The password for the key store should also be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  keyStoreOptions:[
    path:"/path/to/your/server-keystore.jks",
    password:"password-of-your-keystore"
  ]
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively you can read the key store yourself as a buffer and provide that directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-keystore.jks")
def jksOptions = [
  value:myKeyStoreAsABuffer,
  password:"password-of-your-keystore"
]
def options = [
  ssl:true,
  keyStoreOptions:jksOptions
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Key/certificate in PKCS#12 format (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>), usually with the <code>.pfx</code>  or the <code>.p12</code>
extension can also be loaded in a similar fashion than JKS key stores:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  pfxKeyCertOptions:[
    path:"/path/to/your/server-keystore.pfx",
    password:"password-of-your-keystore"
  ]
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-keystore.pfx")
def pfxOptions = [
  value:myKeyStoreAsABuffer,
  password:"password-of-your-keystore"
]
def options = [
  ssl:true,
  pfxKeyCertOptions:pfxOptions
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way of providing server private key and certificate separately using <code>.pem</code> files.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  pemKeyCertOptions:[
    keyPath:"/path/to/your/server-key.pem",
    certPath:"/path/to/your/server-cert.pem"
  ]
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myKeyAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-key.pem")
def myCertAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-cert.pem")
def pemOptions = [
  keyValue:myKeyAsABuffer,
  certValue:myCertAsABuffer
]
def options = [
  ssl:true,
  pemKeyCertOptions:pemOptions
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind that pem configuration, the private key is not crypted.</p>
</div>
</div>
<div class="sect3">
<h4 id="_specifying_trust_for_the_server">Specifying trust for the server</h4>
<div class="paragraph">
<p>SSL/TLS servers can use a certificate authority in order to verify the identity of the clients.</p>
</div>
<div class="paragraph">
<p>Certificate authorities can be configured for servers in several ways:</p>
</div>
<div class="paragraph">
<p>Java trust stores can be managed with the <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool</a>
utility which ships with the JDK.</p>
</div>
<div class="paragraph">
<p>The password for the trust store should also be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  clientAuthRequired:true,
  trustStoreOptions:[
    path:"/path/to/your/truststore.jks",
    password:"password-of-your-truststore"
  ]
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively you can read the trust store yourself as a buffer and provide that directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.jks")
def options = [
  ssl:true,
  clientAuthRequired:true,
  trustStoreOptions:[
    value:myTrustStoreAsABuffer,
    password:"password-of-your-truststore"
  ]
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Certificate authority in PKCS#12 format (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>), usually with the <code>.pfx</code>  or the <code>.p12</code>
extension can also be loaded in a similar fashion than JKS trust stores:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  clientAuthRequired:true,
  pfxTrustOptions:[
    path:"/path/to/your/truststore.pfx",
    password:"password-of-your-truststore"
  ]
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.pfx")
def options = [
  ssl:true,
  clientAuthRequired:true,
  pfxTrustOptions:[
    value:myTrustStoreAsABuffer,
    password:"password-of-your-truststore"
  ]
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way of providing server certificate authority using a list <code>.pem</code> files.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  clientAuthRequired:true,
  pemTrustOptions:[
    certPaths:[
      "/path/to/your/server-ca.pem"
    ]
  ]
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myCaAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-ca.pfx")
def options = [
  ssl:true,
  clientAuthRequired:true,
  pemTrustOptions:[
    certValues:[
      myCaAsABuffer
    ]
  ]
]
def server = vertx.createNetServer(options)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_enabling_ssl_tls_on_the_client">Enabling SSL/TLS on the client</h4>
<div class="paragraph">
<p>Net Clients can also be easily configured to use SSL. They have the exact same API when using SSL as when using standard sockets.</p>
</div>
<div class="paragraph">
<p>To enable SSL on a NetClient the function setSSL(true) is called.</p>
</div>
</div>
<div class="sect3">
<h4 id="_client_trust_configuration">Client trust configuration</h4>
<div class="paragraph">
<p>If the <code><a href="groovydoc/io/vertx/groovy/core/net/ClientOptionsBase.html#setTrustAll(boolean)">trustALl</a></code> is set to true on the client, then the client will
trust all server certificates. The connection will still be encrypted but this mode is vulnerable to 'man in the middle' attacks. I.e. you can&#8217;t
be sure who you are connecting to. Use this with caution. Default value is false.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  trustAll:true
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code><a href="groovydoc/io/vertx/groovy/core/net/ClientOptionsBase.html#setTrustAll(boolean)">trustAll</a></code> is not set then a client trust store must be
configured and should contain the certificates of the servers that the client trusts.</p>
</div>
<div class="paragraph">
<p>Likewise server configuration, the client trust can be configured in several ways:</p>
</div>
<div class="paragraph">
<p>The first method is by specifying the location of a Java trust-store which contains the certificate authority.</p>
</div>
<div class="paragraph">
<p>It is just a standard Java key store, the same as the key stores on the server side. The client
trust store location is set by using the function <code><a href="../cheatsheet/JksOptions.html#path">path</a></code> on the
<code><a href="../cheatsheet/JksOptions.html">jks options</a></code>. If a server presents a certificate during connection which is not
in the client trust store, the connection attempt will not succeed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  trustStoreOptions:[
    path:"/path/to/your/truststore.jks",
    password:"password-of-your-truststore"
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.jks")
def options = [
  ssl:true,
  trustStoreOptions:[
    value:myTrustStoreAsABuffer,
    password:"password-of-your-truststore"
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Certificate authority in PKCS#12 format (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>), usually with the <code>.pfx</code>  or the <code>.p12</code>
extension can also be loaded in a similar fashion than JKS trust stores:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  pfxTrustOptions:[
    path:"/path/to/your/truststore.pfx",
    password:"password-of-your-truststore"
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.pfx")
def options = [
  ssl:true,
  pfxTrustOptions:[
    value:myTrustStoreAsABuffer,
    password:"password-of-your-truststore"
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way of providing server certificate authority using a list <code>.pem</code> files.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  pemTrustOptions:[
    certPaths:[
      "/path/to/your/ca-cert.pem"
    ]
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/ca-cert.pem")
def options = [
  ssl:true,
  pemTrustOptions:[
    certValues:[
      myTrustStoreAsABuffer
    ]
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_specifying_key_certificate_for_the_client">Specifying key/certificate for the client</h4>
<div class="paragraph">
<p>If the server requires client authentication then the client must present its own certificate to the server when
connecting. The client can be configured in several ways:</p>
</div>
<div class="paragraph">
<p>The first method is by specifying the location of a Java key-store which contains the key and certificate.
Again it&#8217;s just a regular Java key store. The client keystore location is set by using the function
<code><a href="../cheatsheet/JksOptions.html#path">path</a></code> on the
<code><a href="../cheatsheet/JksOptions.html">jks options</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  keyStoreOptions:[
    path:"/path/to/your/client-keystore.jks",
    password:"password-of-your-keystore"
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-keystore.jks")
def jksOptions = [
  value:myKeyStoreAsABuffer,
  password:"password-of-your-keystore"
]
def options = [
  ssl:true,
  keyStoreOptions:jksOptions
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Key/certificate in PKCS#12 format (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>), usually with the <code>.pfx</code>  or the <code>.p12</code>
extension can also be loaded in a similar fashion than JKS key stores:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  pfxKeyCertOptions:[
    path:"/path/to/your/client-keystore.pfx",
    password:"password-of-your-keystore"
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-keystore.pfx")
def pfxOptions = [
  value:myKeyStoreAsABuffer,
  password:"password-of-your-keystore"
]
def options = [
  ssl:true,
  pfxKeyCertOptions:pfxOptions
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way of providing server private key and certificate separately using <code>.pem</code> files.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  pemKeyCertOptions:[
    keyPath:"/path/to/your/client-key.pem",
    certPath:"/path/to/your/client-cert.pem"
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myKeyAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-key.pem")
def myCertAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-cert.pem")
def pemOptions = [
  keyValue:myKeyAsABuffer,
  certValue:myCertAsABuffer
]
def options = [
  ssl:true,
  pemKeyCertOptions:pemOptions
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind that pem configuration, the private key is not crypted.</p>
</div>
</div>
<div class="sect3">
<h4 id="_revoking_certificate_authorities">Revoking certificate authorities</h4>
<div class="paragraph">
<p>Trust can be configured to use a certificate revocation list (CRL) for revoked certificates that should no
longer be trusted. The <code><a href="../cheatsheet/NetClientOptions.html#crlPath">crlPath</a></code> configures
the crl list to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  ssl:true,
  trustStoreOptions:trustOptions,
  crlPaths:[
    "/path/to/your/crl.pem"
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer configuration is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myCrlAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/crl.pem")
def options = [
  ssl:true,
  trustStoreOptions:trustOptions,
  crlValues:[
    myCrlAsABuffer
  ]
]
def client = vertx.createNetClient(options)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_http_servers_and_clients">Writing HTTP servers and clients</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x allows you to easily write non blocking HTTP clients and servers.</p>
</div>
<div class="sect2">
<h3 id="_creating_an_http_server">Creating an HTTP Server</h3>
<div class="paragraph">
<p>The simplest way to create an HTTP server, using all default options is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createHttpServer()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_an_http_server">Configuring an HTTP server</h3>
<div class="paragraph">
<p>If you don&#8217;t want the default, a server can be configured by passing in a <code><a href="../cheatsheet/HttpServerOptions.html">HttpServerOptions</a></code>
instance when creating it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  maxWebsocketFrameSize:1000000
]

def server = vertx.createHttpServer(options)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_start_the_server_listening_2">Start the Server Listening</h3>
<div class="paragraph">
<p>To tell the server to listen for incoming requests you use one of the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServer.html#listen()">listen</a></code>
alternatives.</p>
</div>
<div class="paragraph">
<p>To tell the server to listen at the host and port as specified in the options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createHttpServer()
server.listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or to specify the host and port in the call to listen, ignoring what is configured in the options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createHttpServer()
server.listen(8080, "myhost.com")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default host is <code>0.0.0.0</code> which means 'listen on all available addresses' and the default port is <code>80</code>.</p>
</div>
<div class="paragraph">
<p>The actual bind is asynchronous so the server might not actually be listening until some time <strong>after</strong> the call to
listen has returned.</p>
</div>
<div class="paragraph">
<p>If you want to be notified when the server is actually listening you can provide a handler to the <code>listen</code> call.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createHttpServer()
server.listen(8080, "myhost.com", { res -&gt;
  if (res.succeeded()) {
    println("Server is now listening!")
  } else {
    println("Failed to bind!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_getting_notified_of_incoming_requests">Getting notified of incoming requests</h3>
<div class="paragraph">
<p>To be notified when a request arrives you need to set a <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServer.html#requestHandler(io.vertx.core.Handler)">requestHandler</a></code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createHttpServer()
server.requestHandler({ request -&gt;
  // Handle the request in here
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_requests">Handling requests</h3>
<div class="paragraph">
<p>When a request arrives, the request handler is called passing in an instance of <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html">HttpServerRequest</a></code>.
This object represents the server side HTTP request.</p>
</div>
<div class="paragraph">
<p>The handler is called when the headers of the request have been fully read.</p>
</div>
<div class="paragraph">
<p>If the request contains a body, that body will arrive at the server some time after the request handler has been called.</p>
</div>
<div class="paragraph">
<p>The server request object allows you to retrieve the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#uri()">uri</a></code>,
<code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#path()">path</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#params()">params</a></code> and
<code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#headers()">headers</a></code>, amongst other things.</p>
</div>
<div class="paragraph">
<p>Each server request object is associated with one server response object. You use
<code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#response()">response</a></code> to get a reference to the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html">HttpServerResponse</a></code>
object.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a simple example of a server handling a request and replying with "hello world" to it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">vertx.createHttpServer().requestHandler({ request -&gt;
  request.response().end("Hello world")
}).listen(8080)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_request_version">Request version</h4>
<div class="paragraph">
<p>The version of HTTP specified in the request can be retrieved with <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#version()">version</a></code></p>
</div>
</div>
<div class="sect3">
<h4 id="_request_method">Request method</h4>
<div class="paragraph">
<p>Use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#method()">method</a></code> to retrieve the HTTP method of the request.
(i.e. whether it&#8217;s GET, POST, PUT, DELETE, HEAD, OPTIONS, etc).</p>
</div>
</div>
<div class="sect3">
<h4 id="_request_uri">Request URI</h4>
<div class="paragraph">
<p>Use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#uri()">uri</a></code> to retrieve the URI of the request.</p>
</div>
<div class="paragraph">
<p>Note that this is the actual URI as passed in the HTTP request, and it&#8217;s almost always a relative URI.</p>
</div>
<div class="paragraph">
<p>The URI is as defined in <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html">Section 5.1.2 of the HTTP specification - Request-URI</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_request_path">Request path</h4>
<div class="paragraph">
<p>Use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#path()">path</a></code> to return the path part of the URI</p>
</div>
<div class="paragraph">
<p>For example, if the request URI was:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a/b/c/page.html?param1=abc&amp;param2=xyz</pre>
</div>
</div>
<div class="paragraph">
<p>Then the path would be</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/a/b/c/page.html</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_request_query">Request query</h4>
<div class="paragraph">
<p>Use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#query()">query</a></code> to return the query part of the URI</p>
</div>
<div class="paragraph">
<p>For example, if the request URI was:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a/b/c/page.html?param1=abc&amp;param2=xyz</pre>
</div>
</div>
<div class="paragraph">
<p>Then the query would be</p>
</div>
<div class="literalblock">
<div class="content">
<pre>param1=abc&amp;param2=xyz</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_request_headers">Request headers</h4>
<div class="paragraph">
<p>Use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#headers()">headers</a></code> to return the headers of the HTTP request.</p>
</div>
<div class="paragraph">
<p>This returns an instance of <code><a href="groovydoc/io/vertx/groovy/core/MultiMap.html">MultiMap</a></code> - which is like a normal Map or Hash but allows multiple
values for the same key - this is because HTTP allows multiple header values with the same key.</p>
</div>
<div class="paragraph">
<p>It also has case-insensitive keys, that means you can do the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def headers = request.headers()

// Get the User-Agent:
println("User agent is ${headers.get("user-agent")}")

// You can also do this and get the same result:
println("User agent is ${headers.get("User-Agent")}")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_request_parameters">Request parameters</h4>
<div class="paragraph">
<p>Use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#params()">params</a></code> to return the parameters of the HTTP request.</p>
</div>
<div class="paragraph">
<p>Just like <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#headers()">headers</a></code> this returns an instance of <code><a href="groovydoc/io/vertx/groovy/core/MultiMap.html">MultiMap</a></code>
as there can be more than one parameter with the same name.</p>
</div>
<div class="paragraph">
<p>Request parameters are sent on the request URI, after the path. For example if the URI was:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/page.html?param1=abc&amp;param2=xyz</pre>
</div>
</div>
<div class="paragraph">
<p>Then the parameters would contain the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>param1: 'abc'
param2: 'xyz</pre>
</div>
</div>
<div class="paragraph">
<p>Note that these request parameters are retrieved from the URL of the request. If you have form attributes that
have been sent as part of the submission of an HTML form submitted in the body of a <code>multi-part/form-data</code> request
then they will not appear in the params here.</p>
</div>
</div>
<div class="sect3">
<h4 id="_remote_address">Remote address</h4>
<div class="paragraph">
<p>The address of the sender of the request can be retrieved with <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#remoteAddress()">remoteAddress</a></code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_absolute_uri">Absolute URI</h4>
<div class="paragraph">
<p>The URI passed in an HTTP request is usually relative. If you wish to retrieve the absolute URI corresponding
to the request, you can get it with <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#absoluteURI()">absoluteURI</a></code></p>
</div>
</div>
<div class="sect3">
<h4 id="_end_handler">End handler</h4>
<div class="paragraph">
<p>The <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#endHandler(io.vertx.core.Handler)">endHandler</a></code> of the request is invoked when the entire request,
including any body has been fully read.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reading_data_from_the_request_body">Reading Data from the Request Body</h4>
<div class="paragraph">
<p>Often an HTTP request contains a body that we want to read. As previously mentioned the request handler is called
when just the headers of the request have arrived so the request object does not have a body at that point.</p>
</div>
<div class="paragraph">
<p>This is because the body may be very large (e.g. a file upload) and we don&#8217;t generally want to buffer the entire
body in memory before handing it to you, as that could cause the server to exhaust available memory.</p>
</div>
<div class="paragraph">
<p>To receive the body, you can use the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#handler(io.vertx.core.Handler)">handler</a></code>  on the request,
this will get called every time a chunk of the request body arrives. Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">request.handler({ buffer -&gt;
  println("I have received a chunk of the body of length ${buffer.length()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The object passed into the handler is a <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html">Buffer</a></code>, and the handler can be called
multiple times as data arrives from the network, depending on the size of the body.</p>
</div>
<div class="paragraph">
<p>In some cases (e.g. if the body is small) you will want to aggregate the entire body in memory, so you could do
the aggregation yourself as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer

// Create an empty buffer
def totalBuffer = Buffer.buffer()

request.handler({ buffer -&gt;
  println("I have received a chunk of the body of length ${buffer.length()}")
  totalBuffer.appendBuffer(buffer)
})

request.endHandler({ v -&gt;
  println("Full body received, length = ${totalBuffer.length()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is such a common case, that Vert.x provides a <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#bodyHandler(io.vertx.core.Handler)">bodyHandler</a></code> to do this
for you. The body handler is called once when all the body has been received:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">request.bodyHandler({ totalBuffer -&gt;
  println("Full body received, length = ${totalBuffer.length()}")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pumping_requests">Pumping requests</h4>
<div class="paragraph">
<p>The request object is a <code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html">ReadStream</a></code> so you can pump the request body to any
<code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html">WriteStream</a></code> instance.</p>
</div>
<div class="paragraph">
<p>See the chapter on <a href="#streams">streams and pumps</a> for a detailed explanation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_html_forms">Handling HTML forms</h4>
<div class="paragraph">
<p>HTML forms can be submitted with either a content type of <code>application/x-www-form-urlencoded</code> or <code>multipart/form-data</code>.</p>
</div>
<div class="paragraph">
<p>For url encoded forms, the form attributes are encoded in the url, just like normal query parameters.</p>
</div>
<div class="paragraph">
<p>For multi-part forms they are encoded in the request body, and as such are not available until the entire body
has been read from the wire.</p>
</div>
<div class="paragraph">
<p>Multi-part forms can also contain file uploads.</p>
</div>
<div class="paragraph">
<p>If you want to retrieve the attributes of a multi-part form you should tell Vert.x that you expect to receive
such a form <strong>before</strong> any of the body is read by calling <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#setExpectMultipart(boolean)">setExpectMultipart</a></code>
with true, and then you should retrieve the actual attributes using <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#formAttributes()">formAttributes</a></code>
once the entire body has been read:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">server.requestHandler({ request -&gt;
  request.setExpectMultipart(true)
  request.endHandler({ v -&gt;
    // The body has now been fully read, so retrieve the form attributes
    def formAttributes = request.formAttributes()
  })
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handling_form_file_uploads">Handling form file uploads</h4>
<div class="paragraph">
<p>Vert.x can also handle file uploads which are encoded in a multi-part request body.</p>
</div>
<div class="paragraph">
<p>To receive file uploads you tell Vert.x to expect a multi-part form and set an
<code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#uploadHandler(io.vertx.core.Handler)">uploadHandler</a></code> on the request.</p>
</div>
<div class="paragraph">
<p>This handler will be called once for every
upload that arrives on the server.</p>
</div>
<div class="paragraph">
<p>The object passed into the handler is a <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerFileUpload.html">HttpServerFileUpload</a></code> instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">server.requestHandler({ request -&gt;
  request.setExpectMultipart(true)
  request.uploadHandler({ upload -&gt;
    println("Got a file upload ${upload.name()}")
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>File uploads can be large we don&#8217;t provide the entire upload in a single buffer as that might result in memory
exhaustion, instead, the upload data is received in chunks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">request.uploadHandler({ upload -&gt;
  upload.handler({ chunk -&gt;
    println("Received a chunk of the upload of length ${chunk.length()}")
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The upload object is a <code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html">ReadStream</a></code> so you can pump the request body to any
<code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html">WriteStream</a></code> instance. See the chapter on <a href="#streams">streams and pumps</a> for a
detailed explanation.</p>
</div>
<div class="paragraph">
<p>If you just want to upload the file to disk somewhere you can use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerFileUpload.html#streamToFileSystem(java.lang.String)">streamToFileSystem</a></code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">request.uploadHandler({ upload -&gt;
  upload.streamToFileSystem("myuploads_directory/${upload.filename()}")
})</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Make sure you check the filename in a production system to avoid malicious clients uploading files
to arbitrary places on your filesystem. See <a href="#security_notes">security notes</a> for more information.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sending_back_responses">Sending back responses</h3>
<div class="paragraph">
<p>The server response object is an instance of <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html">HttpServerResponse</a></code> and is obtained from the
request with <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#response()">response</a></code>.</p>
</div>
<div class="paragraph">
<p>You use the response object to write a response back to the HTTP client.</p>
</div>
<div class="sect3">
<h4 id="_setting_status_code_and_message">Setting status code and message</h4>
<div class="paragraph">
<p>The default HTTP status code for a response is <code>200</code>, representing <code>OK</code>.</p>
</div>
<div class="paragraph">
<p>Use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#setStatusCode(int)">setStatusCode</a></code> to set a different code.</p>
</div>
<div class="paragraph">
<p>You can also specify a custom status message with <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#setStatusMessage(java.lang.String)">setStatusMessage</a></code>.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t specify a status message, the default one corresponding to the status code will be used.</p>
</div>
</div>
<div class="sect3">
<h4 id="_writing_http_responses">Writing HTTP responses</h4>
<div class="paragraph">
<p>To write data to an HTTP response, you use one the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#write(io.vertx.core.buffer.Buffer)">write</a></code> operations.</p>
</div>
<div class="paragraph">
<p>These can be invoked multiple times before the response is ended. They can be invoked in a few ways:</p>
</div>
<div class="paragraph">
<p>With a single buffer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
response.write(buffer)</code></pre>
</div>
</div>
<div class="paragraph">
<p>With a string. In this case the string will encoded using UTF-8 and the result written to the wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
response.write("hello world!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>With a string and an encoding. In this case the string will encoded using the specified encoding and the
result written to the wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
response.write("hello world!", "UTF-16")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Writing to a response is asynchronous and always returns immediately after the write has been queued.</p>
</div>
<div class="paragraph">
<p>If you are just writing a single string or buffer to the HTTP response you can write it and end the response in a
single call to the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#end(java.lang.String)">end</a></code></p>
</div>
<div class="paragraph">
<p>The first call to write results in the response header being being written to the response. Consequently, if you are
not using HTTP chunking then you must set the <code>Content-Length</code> header before writing to the response, since it will
be too late otherwise. If you are using HTTP chunking you do not have to worry.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ending_http_responses">Ending HTTP responses</h4>
<div class="paragraph">
<p>Once you have finished with the HTTP response you should <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#end(java.lang.String)">end</a></code> it.</p>
</div>
<div class="paragraph">
<p>This can be done in several ways:</p>
</div>
<div class="paragraph">
<p>With no arguments, the response is simply ended.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
response.write("hello world!")
response.end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>It can also be called with a string or buffer in the same way <code>write</code> is called. In this case it&#8217;s just the same as
calling write with a string or buffer followed by calling end with no arguments. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
response.end("hello world!")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_closing_the_underlying_connection">Closing the underlying connection</h4>
<div class="paragraph">
<p>You can close the underlying TCP connection with <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#close()">close</a></code>.</p>
</div>
<div class="paragraph">
<p>Non keep-alive connections will be automatically closed by Vert.x when the response is ended.</p>
</div>
<div class="paragraph">
<p>Keep-alive connections are not automatically closed by Vert.x by default. If you want keep-alive connections to be
closed after an idle time, then you configure <code><a href="../cheatsheet/HttpServerOptions.html#idleTimeout">idleTimeout</a></code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_setting_response_headers">Setting response headers</h4>
<div class="paragraph">
<p>HTTP response headers can be added to the response by adding them directly to the
<code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#headers()">headers</a></code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
def headers = response.headers()
headers.set("content-type", "text/html")
headers.set("other-header", "wibble")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or you can use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#putHeader(java.lang.String,%20java.lang.String)">putHeader</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
response.putHeader("content-type", "text/html").putHeader("other-header", "wibble")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Headers must all be added before any parts of the response body are written.</p>
</div>
</div>
<div class="sect3">
<h4 id="_chunked_http_responses_and_trailers">Chunked HTTP responses and trailers</h4>
<div class="paragraph">
<p>Vert.x supports <a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">HTTP Chunked Transfer Encoding</a>.</p>
</div>
<div class="paragraph">
<p>This allows the HTTP response body to be written in chunks, and is normally used when a large response body is
being streamed to a client and the total size is not known in advance.</p>
</div>
<div class="paragraph">
<p>You put the HTTP response into chunked mode as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
response.setChunked(true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Default is non-chunked. When in chunked mode, each call to one of the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#write(io.vertx.core.buffer.Buffer)">write</a></code>
methods will result in a new HTTP chunk being written out.</p>
</div>
<div class="paragraph">
<p>When in chunked mode you can also write HTTP response trailers to the response. These are actually written in
the final chunk of the response.</p>
</div>
<div class="paragraph">
<p>To add trailers to the response, add them directly to the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#trailers()">trailers</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
response.setChunked(true)
def trailers = response.trailers()
trailers.set("X-wibble", "woobble").set("X-quux", "flooble")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#putTrailer(java.lang.String,%20java.lang.String)">putTrailer</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def response = request.response()
response.setChunked(true)
response.putTrailer("X-wibble", "woobble").putTrailer("X-quux", "flooble")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_serving_files_directly_from_disk">Serving files directly from disk</h4>
<div class="paragraph">
<p>If you were writing a web server, one way to serve a file from disk would be to open it as an <code><a href="groovydoc/io/vertx/groovy/core/file/AsyncFile.html">AsyncFile</a></code>
and pump it to the HTTP response.</p>
</div>
<div class="paragraph">
<p>Or you could load it it one go using <code><a href="groovydoc/io/vertx/groovy/core/file/FileSystem.html#readFile(java.lang.String,%20io.vertx.core.Handler)">readFile</a></code> and write it straight to the response.</p>
</div>
<div class="paragraph">
<p>Alternatively, Vert.x provides a method which allows you to serve a file from disk to an HTTP response in one operation.
Where supported by the underlying operating system this may result in the OS directly transferring bytes from the
file to the socket without being copied through user-space at all.</p>
</div>
<div class="paragraph">
<p>This is done by using <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#sendFile(java.lang.String)">sendFile</a></code>, and is usually more efficient for large
files, but may be slower for small files.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a very simple web server that serves files from the file system using sendFile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">vertx.createHttpServer().requestHandler({ request -&gt;
  def file = ""
  if (request.path() == "/") {
    file = "index.html"
  } else {
    if (!request.path().contains("..")) {
      file = request.path()
    }}
  request.response().sendFile("web/${file}")
}).listen(8080)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sending a file is asynchronous and may not complete until some time after the call has returned. If you want to
be notified when the file has been writen you can use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html#sendFile(java.lang.String,%20io.vertx.core.Handler)">sendFile</a></code></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If you use <code>sendFile</code> while using HTTPS it will copy through user-space, since if the kernel is copying data
directly from disk to socket it doesn&#8217;t give us an opportunity to apply any encryption.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
If you&#8217;re going to write web servers directly using Vert.x be careful that users cannot exploit the
path to access files outside the directory from which you want to serve them. It may be safer instead to use
Vert.x Apex.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_pumping_responses">Pumping responses</h4>
<div class="paragraph">
<p>The server response is a <code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html">WriteStream</a></code> instance so you can pump to it from any
<code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html">ReadStream</a></code>, e.g. <code><a href="groovydoc/io/vertx/groovy/core/file/AsyncFile.html">AsyncFile</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html">NetSocket</a></code>,
<code><a href="groovydoc/io/vertx/groovy/core/http/WebSocket.html">WebSocket</a></code> or <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html">HttpServerRequest</a></code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example which echoes the request body back in the response for any PUT methods.
It uses a pump for the body, so it will work even if the HTTP request body is much larger than can fit in memory
at any one time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.core.http.HttpMethod
import io.vertx.groovy.core.streams.Pump
vertx.createHttpServer().requestHandler({ request -&gt;
  def response = request.response()
  if (request.method() == HttpMethod.PUT) {
    response.setChunked(true)
    Pump.pump(request, response).start()
    request.endHandler({ v -&gt;
      response.end()})
  } else {
    response.setStatusCode(400).end()
  }
}).listen(8080)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http_compression">HTTP Compression</h3>
<div class="paragraph">
<p>Vert.x comes with support for HTTP Compression out of the box.</p>
</div>
<div class="paragraph">
<p>This means you are able to automatically compress the body of the responses before they are sent back to the client.</p>
</div>
<div class="paragraph">
<p>If the client does not support HTTP compression the responses are sent back without compressing the body.</p>
</div>
<div class="paragraph">
<p>This allows to handle Client that support HTTP Compression and those that not support it at the same time.</p>
</div>
<div class="paragraph">
<p>To enable compression use can configure it with <code><a href="../cheatsheet/HttpServerOptions.html#compressionSupported">compressionSupported</a></code>.</p>
</div>
<div class="paragraph">
<p>By default compression is not enabled.</p>
</div>
<div class="paragraph">
<p>When HTTP compression is enabled the server will check if the client incldes an <code>Accept-Encoding</code> header which
includes the supported compressions. Commonly used are deflate and gzip. Both are supported by Vert.x.</p>
</div>
<div class="paragraph">
<p>If such a header is found the server will automatically compress the body of the response with one of the supported
compressions and send it back to the client.</p>
</div>
<div class="paragraph">
<p>Be aware that compression may be able to reduce network traffic but is more CPU-intensive.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_an_http_client">Creating an HTTP client</h3>
<div class="paragraph">
<p>You create an <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClient.html">HttpClient</a></code> instance with default options as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createHttpClient()</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to configure options for the client, you create it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [
  keepAlive:false
]
def client = vertx.createHttpClient()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_making_requests">Making requests</h3>
<div class="paragraph">
<p>The http client is very flexible and there are various ways you can make requests with it.</p>
</div>
<div class="paragraph">
<p>Often you want to make many requests to the same host/port with an http client. To avoid you repeating the host/port
every time you make a request you can configure the client with a default host/port:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// Set the default host
def options = [
  defaultHost:"wibble.com"
]
// Can also set default port if you want...
def client = vertx.createHttpClient(options)
client.getNow("/some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively if you find yourself making lots of requests to different host/ports with the same client you can
simply specify the host/port when doing the request.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createHttpClient()

// Specify both port and host name
client.getNow(8080, "myserver.mycompany.com", "/some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})

// This time use the default port 80 but specify the host name
client.getNow("foo.othercompany.com", "/other-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both methods of specifying host/port are supported for all the different ways of making requests with the client.</p>
</div>
<div class="sect3">
<h4 id="_simple_requests_with_no_request_body">Simple requests with no request body</h4>
<div class="paragraph">
<p>Often, you&#8217;ll want to make HTTP requests with no request body. This is usually the case with HTTP GET, OPTIONS and
HEAD requests.</p>
</div>
<div class="paragraph">
<p>The simplest way to do this with the Vert.x http client is using the methods prefixed with <code>Now</code>. For example
<code><a href="groovydoc/io/vertx/groovy/core/http/HttpClient.html#getNow(int,%20java.lang.String,%20java.lang.String,%20io.vertx.core.Handler)">getNow</a></code>.</p>
</div>
<div class="paragraph">
<p>These methods create the http request and send it in a single method call and allow you to provide a handler that will be
called with the http response when it comes back.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createHttpClient()

// Send a GET request
client.getNow("/some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})

// Send a GET request
client.headNow("/other-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_writing_general_requests">Writing general requests</h4>
<div class="paragraph">
<p>At other times you don&#8217;t know the request method you want to send until run-time. For that use case we provide
general purpose request methods such as <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClient.html#request(io.vertx.core.http.HttpMethod,%20int,%20java.lang.String,%20java.lang.String)">request</a></code> which allow you to specify
the HTTP method at run-time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.core.http.HttpMethod
def client = vertx.createHttpClient()

client.request(HttpMethod.GET, "some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
}).end()

client.request(HttpMethod.POST, "foo-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
}).end("some-data")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_writing_request_bodies">Writing request bodies</h4>
<div class="paragraph">
<p>Sometimes you&#8217;ll want to write requests which have a body, or perhaps you want to write headers to a request
before sending it.</p>
</div>
<div class="paragraph">
<p>To do this you can call one of the specific request methods such as <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClient.html#post(int,%20java.lang.String,%20java.lang.String)">post</a></code> or
one of the general purpose request methods such as <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClient.html#request(io.vertx.core.http.HttpMethod,%20int,%20java.lang.String,%20java.lang.String)">request</a></code>.</p>
</div>
<div class="paragraph">
<p>These methods don&#8217;t send the request immediately, but instead return an instance of <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html">HttpClientRequest</a></code>
which can be used to write to the request body or write headers.</p>
</div>
<div class="paragraph">
<p>Here are some examples of writing a POST request with a body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createHttpClient()

def request = client.post("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})

// Now do stuff with the request
request.putHeader("content-length", "1000")
request.putHeader("content-type", "text/plain")
request.write(body)

// Make sure the request is ended when you're done with it
request.end()

// Or fluently:

client.post("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
}).putHeader("content-length", "1000").putHeader("content-type", "text/plain").write(body).end()

// Or event more simply:

client.post("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
}).putHeader("content-type", "text/plain").end(body)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Methods exist to write strings in UTF-8 encoding and in any specific encoding and to write buffers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer

// Write string encoded in UTF-8
request.write("some data")

// Write string encoded in specific encoding
request.write("some other data", "UTF-16")

// Write a buffer
def buffer = Buffer.buffer()
buffer.appendInt(123).appendLong(245L)
request.write(buffer)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are just writing a single string or buffer to the HTTP request you can write it and end the request in a
single call to the <code>end</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer

// Write string and end the request (send it) in a single call
request.end("some simple data")

// Write buffer and end the request (send it) in a single call
def buffer = Buffer.buffer().appendDouble(12.34d).appendLong(432L)
request.end(buffer)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you&#8217;re writing to a request, the first call to <code>write</code> will result in the request headers being written
out to the wire.</p>
</div>
<div class="paragraph">
<p>The actual write is asychronous and might not occur until some time after the call has returned.</p>
</div>
<div class="paragraph">
<p>Non-chunked HTTP requests with a request body require a <code>Content-Length</code> header to be provided.</p>
</div>
<div class="paragraph">
<p>Consequently, if you are not using chunked HTTP then you must set the <code>Content-Length</code> header before writing
to the request, as it will be too late otherwise.</p>
</div>
<div class="paragraph">
<p>If you are calling one of the <code>end</code> methods that take a string or buffer then Vert.x will automatically calculate
and set the <code>Content-Length</code> header before writing the request body.</p>
</div>
<div class="paragraph">
<p>If you are using HTTP chunking a a <code>Content-Length</code> header is not required, so you do not have to calculate the size
up-front.</p>
</div>
</div>
<div class="sect3">
<h4 id="_writing_request_headers">Writing request headers</h4>
<div class="paragraph">
<p>You can write headers to a request using the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html#headers()">headers</a></code> multi-map as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// Write some headers using the headers() multimap

def headers = request.headers()
headers.set("content-type", "application/json").set("other-header", "foo")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The headers are an instance of <code><a href="groovydoc/io/vertx/groovy/core/MultiMap.html">MultiMap</a></code> which provides operations for adding, setting and removing
entries. Http headers allow more than one value for a specific key.</p>
</div>
<div class="paragraph">
<p>You can also write headers using <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html#putHeader(java.lang.String,%20java.lang.String)">putHeader</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// Write some headers using the putHeader method

request.putHeader("content-type", "application/json").putHeader("other-header", "foo")</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you wish to write headers to the request you must do so before any part of the request body is written.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ending_http_requests">Ending HTTP requests</h4>
<div class="paragraph">
<p>Once you have finished with the HTTP request you must end it with one of the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html#end(java.lang.String)">end</a></code>
operations.</p>
</div>
<div class="paragraph">
<p>Ending a request causes any headers to be written, if they have not already been written and the request to be marked
as complete.</p>
</div>
<div class="paragraph">
<p>Requests can be ended in several ways. With no arguments the request is simply ended:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">request.end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or a string or buffer can be provided in the call to <code>end</code>. This is like calling <code>write</code> with the string or buffer
before calling <code>end</code> with no arguments</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
// End the request with a string
request.end("some-data")

// End it with a buffer
def buffer = Buffer.buffer().appendFloat(12.3f).appendInt(321)
request.end(buffer)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_chunked_http_requests">Chunked HTTP requests</h4>
<div class="paragraph">
<p>Vert.x supports <a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">HTTP Chunked Transfer Encoding</a> for requests.</p>
</div>
<div class="paragraph">
<p>This allows the HTTP request body to be written in chunks, and is normally used when a large request body is being streamed
to the server, whose size is not known in advance.</p>
</div>
<div class="paragraph">
<p>You put the HTTP request into chunked mode using <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html#setChunked(boolean)">setChunked</a></code>.</p>
</div>
<div class="paragraph">
<p>In chunked mode each call to write will cause a new chunk to be written to the wire. In chunked mode there is
no need to set the <code>Content-Length</code> of the request up-front.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">request.setChunked(true)

// Write some chunks
for (def i = 0;i &lt; 10;i++) {
  request.write("this-is-chunk-${i}")
}

request.end()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_request_timeouts">Request timeouts</h4>
<div class="paragraph">
<p>You can set a timeout for a specific http request using <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html#setTimeout(long)">setTimeout</a></code>.</p>
</div>
<div class="paragraph">
<p>If the request does not return any data within the timeout period an exception will be passed to the exception handler
(if provided) and the request will be closed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_exceptions_2">Handling exceptions</h4>
<div class="paragraph">
<p>You can handle exceptions corresponding to a request by setting an exception handler on the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html">HttpClientRequest</a></code>
instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def request = client.post("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})
request.exceptionHandler({ e -&gt;
  println("Received exception: ${e.getMessage()}")
  e.printStackTrace()
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO - what about exceptions in the getNow methods where no exception handler can be provided??</p>
</div>
<div class="paragraph">
<p>Maybe need a catch all exception handler??</p>
</div>
</div>
<div class="sect3">
<h4 id="_specifying_a_handler_on_the_client_request">Specifying a handler on the client request</h4>
<div class="paragraph">
<p>Instead of providing a response handler in the call to create the client request object, alternatively, you can
not provide a handler when the request is created and set it later on the request object itself, using
<code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html#handler(io.vertx.core.Handler)">handler</a></code>, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def request = client.post("some-uri")
request.handler({ response -&gt;
  println("Received response with status code ${response.statusCode()}")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_request_as_a_stream">Using the request as a stream</h4>
<div class="paragraph">
<p>The <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html">HttpClientRequest</a></code> instance is also a <code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html">WriteStream</a></code> which means
you can pump to it from any <code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html">ReadStream</a></code> instance.</p>
</div>
<div class="paragraph">
<p>For, example, you could pump a file on disk to a http request body as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.streams.Pump

request.setChunked(true)
def pump = Pump.pump(file, request)
file.endHandler({ v -&gt;
  request.end()})
pump.start()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_http_responses">Handling http responses</h3>
<div class="paragraph">
<p>You receive an instance of <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html">HttpClientResponse</a></code> into the handler that you specify in of
the request methods or by setting a handler directly on the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html">HttpClientRequest</a></code> object.</p>
</div>
<div class="paragraph">
<p>You can query the status code and the status message of the response with <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html#statusCode()">statusCode</a></code>
and <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html#statusMessage()">statusMessage</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">client.getNow("some-uri", { response -&gt;
  // the status code - e.g. 200 or 404
  println("Status code is ${response.statusCode()}")

  // the status message e.g. "OK" or "Not Found".
  println("Status message is ${response.statusMessage()}")
})</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_response_as_a_stream">Using the response as a stream</h4>
<div class="paragraph">
<p>The <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html">HttpClientResponse</a></code> instance is also a <code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html">ReadStream</a></code> which means
you can pump it to any <code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html">WriteStream</a></code> instance.</p>
</div>
</div>
<div class="sect3">
<h4 id="_response_headers_and_trailers">Response headers and trailers</h4>
<div class="paragraph">
<p>Http responses can contain headers. Use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html#headers()">headers</a></code> to get the headers.</p>
</div>
<div class="paragraph">
<p>The object returned is a <code><a href="groovydoc/io/vertx/groovy/core/MultiMap.html">MultiMap</a></code> as HTTP headers can contain multiple values for single keys.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def contentType = response.headers().get("content-type")
def contentLength = response.headers().get("content-lengh")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Chunked HTTP responses can also contain trailers - these are sent in the last chunk of the response body.</p>
</div>
<div class="paragraph">
<p>You use <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html#trailers()">trailers</a></code> to get the trailers. Trailers are also a <code><a href="groovydoc/io/vertx/groovy/core/MultiMap.html">MultiMap</a></code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reading_the_request_body">Reading the request body</h4>
<div class="paragraph">
<p>The response handler is called when the headers of the response have been read from the wire.</p>
</div>
<div class="paragraph">
<p>If the response has a body this might arrive in several pieces some time after the headers have been read. We
don&#8217;t wait for all the body to arrive before calling the response handler as the response could be very large and we
might be waiting a long time, or run out of memory for large responses.</p>
</div>
<div class="paragraph">
<p>As parts of the response body arrive, the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html#handler(io.vertx.core.Handler)">handler</a></code> is called with
a <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html">Buffer</a></code> representing the piece of the body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">client.getNow("some-uri", { response -&gt;

  response.handler({ buffer -&gt;
    println("Received a part of the response body: ${buffer}")
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you know the response body is not very large and want to aggregate it all in memory before handling it, you can
either aggregate it yourself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer

client.getNow("some-uri", { response -&gt;

  // Create an empty buffer
  def totalBuffer = Buffer.buffer()

  response.handler({ buffer -&gt;
    println("Received a part of the response body: ${buffer.length()}")

    totalBuffer.appendBuffer(buffer)
  })

  response.endHandler({ v -&gt;
    // Now all the body has been read
    println("Total response body length is ${totalBuffer.length()}")
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or you can use the convenience <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html#bodyHandler(io.vertx.core.Handler)">bodyHandler</a></code> which
is called with the entire body when the response has been fully read:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">client.getNow("some-uri", { response -&gt;

  response.bodyHandler({ totalBuffer -&gt;
    // Now all the body has been read
    println("Total response body length is ${totalBuffer.length()}")
  })
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_response_end_handler">Response end handler</h4>
<div class="paragraph">
<p>The response <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html#endHandler(io.vertx.core.Handler)">endHandler</a></code> is called when the entire response body has been read
or immediately after the headers have been read and the response handler has been called if there is no body.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reading_cookies_from_the_response">Reading cookies from the response</h4>
<div class="paragraph">
<p>You can retrieve the list of cookies from a response using <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html#cookies()">cookies</a></code>.</p>
</div>
<div class="paragraph">
<p>Alternatively you can just parse the <code>Set-Cookie</code> headers yourself in the response.</p>
</div>
</div>
<div class="sect3">
<h4 id="_100_continue_handling">100-Continue handling</h4>
<div class="paragraph">
<p>According to the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html">HTTP 1.1 specification</a> a client can set a
header <code>Expect: 100-Continue</code> and send the request header before sending the rest of the request body.</p>
</div>
<div class="paragraph">
<p>The server can then respond with an interim response status <code>Status: 100 (Continue)</code> to signify to the client that
it is ok to send the rest of the body.</p>
</div>
<div class="paragraph">
<p>The idea here is it allows the server to authorise and accept/reject the request before large amounts of data are sent.
Sending large amounts of data if the request might not be accepted is a waste of bandwidth and ties up the server
in reading data that it will just discard.</p>
</div>
<div class="paragraph">
<p>Vert.x allows you to set a <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html#continueHandler(io.vertx.core.Handler)">continueHandler</a></code> on the
client request object</p>
</div>
<div class="paragraph">
<p>This will be called if the server sends back a <code>Status: 100 (Continue)</code> response to signify that it is ok to send
the rest of the request.</p>
</div>
<div class="paragraph">
<p>This is used in conjunction with `<a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html#sendHead()">sendHead</a>`to send the head of the request.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def request = client.put("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})

request.putHeader("Expect", "100-Continue")

request.continueHandler({ v -&gt;
  // OK to send rest of body
  request.write("Some data")
  request.write("Some more data")
  request.end()
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_enabling_compression_on_the_client">Enabling compression on the client</h3>
<div class="paragraph">
<p>The http client comes with support for HTTP Compression out of the box.</p>
</div>
<div class="paragraph">
<p>This means the client can let the remote http server know that it supports compression, and will be able to handle
compressed response bodies.</p>
</div>
<div class="paragraph">
<p>An http server is free to either compress with one of the supported compression algorithms or to send the body back
without compressing it at all. So this is only a hint for the Http server which it may ignore at will.</p>
</div>
<div class="paragraph">
<p>To tell the http server which compression is supported by the client it will include an <code>Accept-Encoding</code> header with
the supported compression algorithm as value. Multiple compression algorithms are supported. In case of Vert.x this
will result in the following header added:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Accept-Encoding: gzip, deflate</pre>
</div>
</div>
<div class="paragraph">
<p>The server will choose then from one of these. You can detect if a server ompressed the body by checking for the
<code>Content-Encoding</code> header in the response sent back from it.</p>
</div>
<div class="paragraph">
<p>If the body of the response was compressed via gzip it will include for example the following header:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Content-Encoding: gzip</pre>
</div>
</div>
<div class="paragraph">
<p>To enable compression set <code><a href="../cheatsheet/HttpClientOptions.html#tryUseCompression">tryUseCompression</a></code> on the options
used when creating the client.</p>
</div>
<div class="paragraph">
<p>By default compression is disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pooling_and_keep_alive">Pooling and keep alive</h3>
<div class="paragraph">
<p>Http keep alive allows http connections to be used for more than one request. This can be a more efficient use of
connections when you&#8217;re making multiple requests to the same server.</p>
</div>
<div class="paragraph">
<p>The http client supports pooling of connections, allowing you to reuse connections between requests.</p>
</div>
<div class="paragraph">
<p>For pooling to work, keep alive must be true using <code><a href="../cheatsheet/HttpClientOptions.html#keepAlive">keepAlive</a></code>
on the options used when configuring the client. The default value is true.</p>
</div>
<div class="paragraph">
<p>When keep alive is enabled. Vert.x will add a <code>Connection: Keep-Alive</code> header to each HTTP request sent.</p>
</div>
<div class="paragraph">
<p>The maximum number of connections to pool <strong>for each server</strong> is configured using <code><a href="../cheatsheet/HttpClientOptions.html#maxPoolSize">maxPoolSize</a></code></p>
</div>
<div class="paragraph">
<p>When making a request with pooling enabled, Vert.x will create a new connection if there are less than the maximum number of
connections already created for that server, otherwise it will add the request to a queue.</p>
</div>
<div class="paragraph">
<p>When a response returns, if there are pending requests for the server, then the connection will be reused, otherwise
it will be closed.</p>
</div>
<div class="paragraph">
<p>This gives the benefits of keep alive when the client is loaded but means we don&#8217;t keep connections hanging around
unnecessarily when there would be no benefits anyway.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pipe_lining">Pipe-lining</h3>
<div class="paragraph">
<p>The client also supports pipe-lining of requests on a connection.</p>
</div>
<div class="paragraph">
<p>Pipe-lining means another request is sent on the same connection before the response from the preceding one has
returned. Pipe-lining is not appropriate for all requests.</p>
</div>
<div class="paragraph">
<p>To enable pipe-lining, it must be enabled using <code><a href="../cheatsheet/HttpClientOptions.html#pipelining">pipelining</a></code>.
By default pipe-lining is disabled.</p>
</div>
<div class="paragraph">
<p>When pipe-lining is enabled requests will be written to connections without waiting for previous responses to return.</p>
</div>
<div class="paragraph">
<p>When pipe-line responses return at the client, the connection will be automatically closed when all in-flight
responses have returned and there are no outstanding pending requests to write.</p>
</div>
</div>
<div class="sect2">
<h3 id="_server_sharing">Server sharing</h3>
<div class="paragraph">
<p>TODO
round robin requests etc</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_https_with_vert_x">Using HTTPS with Vert.x</h3>
<div class="paragraph">
<p>Vert.x http servers and clients can be configured to use HTTPS in exactly the same way as net servers.</p>
</div>
<div class="paragraph">
<p>Please see <a href="#netserver_ssl">configuring net servers to use SSL</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_websockets">WebSockets</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/WebSocket">WebSockets</a> are a web technology that allows a full duplex socket-like
connection between HTTP servers and HTTP clients (typically browsers).</p>
</div>
<div class="paragraph">
<p>Vert.x supports WebSockets on both the client and server-side.</p>
</div>
<div class="sect3">
<h4 id="_websockets_on_the_server">WebSockets on the server</h4>
<div class="paragraph">
<p>There are two ways of handling WebSockets on the server side.</p>
</div>
<div class="sect4">
<h5 id="_websocket_handler">WebSocket handler</h5>
<div class="paragraph">
<p>The first way involves providing a <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServer.html#websocketHandler(io.vertx.core.Handler)">websocketHandler</a></code>
on the server instance.</p>
</div>
<div class="paragraph">
<p>When a WebSocket connection is made to the server, the handler will be called, passing in an instance of
<code><a href="groovydoc/io/vertx/groovy/core/http/ServerWebSocket.html">ServerWebSocket</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">server.websocketHandler({ websocket -&gt;
  println("Connected!")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can choose to reject the WebSocket by calling <code><a href="groovydoc/io/vertx/groovy/core/http/ServerWebSocket.html#reject()">reject</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">server.websocketHandler({ websocket -&gt;
  if (websocket.path() == "/myapi") {
    websocket.reject()
  } else {
    // Do something
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_upgrading_to_websocket">Upgrading to WebSocket</h5>
<div class="paragraph">
<p>The second way of handling WebSockets is to handle the HTTP Upgrade request that was sent from the client, and
call <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html#upgrade()">upgrade</a></code> on the server request.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">server.requestHandler({ request -&gt;
  if (request.path() == "/myapi") {

    def websocket = request.upgrade()
    // Do something

  } else {
    // Reject
    request.response().setStatusCode(400).end()
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_server_websocket">The server WebSocket</h5>
<div class="paragraph">
<p>The <code><a href="groovydoc/io/vertx/groovy/core/http/ServerWebSocket.html">ServerWebSocket</a></code> instance enables you to retrieve the <code><a href="groovydoc/io/vertx/groovy/core/http/ServerWebSocket.html#headers()">headers</a></code>,
<code><a href="groovydoc/io/vertx/groovy/core/http/ServerWebSocket.html#path()">path</a></code> path}, <code><a href="groovydoc/io/vertx/groovy/core/http/ServerWebSocket.html#query()">query</a></code> and
<code><a href="groovydoc/io/vertx/groovy/core/http/ServerWebSocket.html#uri()">uri</a></code> URI} of the HTTP request of the WebSocket handshake.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_websockets_on_the_client">WebSockets on the client</h4>
<div class="paragraph">
<p>The Vert.x <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClient.html">HttpClient</a></code> supports WebSockets.</p>
</div>
<div class="paragraph">
<p>You can connect a WebSocket to a server using one of the <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClient.html#websocket(int,%20java.lang.String,%20java.lang.String,%20io.vertx.core.Handler)">websocket</a></code> operations and
providing a handler.</p>
</div>
<div class="paragraph">
<p>The handler will be called with an instance of <code><a href="groovydoc/io/vertx/groovy/core/http/WebSocket.html">WebSocket</a></code> when the connection has been made:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">client.websocket("/some-uri", { websocket -&gt;
  println("Connected!")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_writing_messages_to_websockets">Writing messages to WebSockets</h4>
<div class="paragraph">
<p>If you wish to write a single binary WebSocket message containing a single WebSocket frame to the WebSocket (a
common case) the simplest way to do this is to use <code><a href="groovydoc/io/vertx/groovy/core/http/WebSocket.html#writeMessage(io.vertx.core.buffer.Buffer)">writeMessage</a></code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
// Write a simple message
def buffer = Buffer.buffer().appendInt(123).appendFloat(1.23f)

websocket.writeMessage(buffer)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the websocket message is larger than the maximum websocket frame size as configured with
<code><a href="../cheatsheet/HttpClientOptions.html#maxWebsocketFrameSize">maxWebsocketFrameSize</a></code>
then Vert.x will split it into multiple WebSocket frames before sending it on the wire.</p>
</div>
</div>
<div class="sect3">
<h4 id="_writing_frames_to_websockets">Writing frames to WebSockets</h4>
<div class="paragraph">
<p>A WebSocket message can be composed of multiple frames. In this case the first frame is either a <em>binary</em> or <em>text</em> frame
followed by one or more <em>continuation</em> frames.</p>
</div>
<div class="paragraph">
<p>The last frame in the message is marked as <em>final</em>.</p>
</div>
<div class="paragraph">
<p>To send a message consisting of multiple frames you create frames using
<code><a href="groovydoc/io/vertx/groovy/core/http/WebSocketFrame.html#binaryFrame(io.vertx.core.buffer.Buffer,%20boolean)">WebSocketFrame.binaryFrame</a></code>
, <code><a href="groovydoc/io/vertx/groovy/core/http/WebSocketFrame.html#textFrame(java.lang.String,%20boolean)">WebSocketFrame.textFrame</a></code> or
<code><a href="groovydoc/io/vertx/groovy/core/http/WebSocketFrame.html#continuationFrame(io.vertx.core.buffer.Buffer,%20boolean)">WebSocketFrame.continuationFrame</a></code> and write them
to the WebSocket using <code><a href="groovydoc/io/vertx/groovy/core/http/WebSocket.html#writeFrame(io.vertx.core.http.WebSocketFrame)">writeFrame</a></code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example for binary frames:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.http.WebSocketFrame

def frame1 = WebSocketFrame.binaryFrame(buffer1, false)
websocket.writeFrame(frame1)

def frame2 = WebSocketFrame.continuationFrame(buffer2, false)
websocket.writeFrame(frame2)

// Write the final frame
def frame3 = WebSocketFrame.continuationFrame(buffer2, true)
websocket.writeFrame(frame3)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reading_frames_from_websockets">Reading frames from WebSockets</h4>
<div class="paragraph">
<p>To read frames from a WebSocket you use the <code><a href="groovydoc/io/vertx/groovy/core/http/WebSocket.html#frameHandler(io.vertx.core.Handler)">frameHandler</a></code>.</p>
</div>
<div class="paragraph">
<p>The frame handler will be called with instances of <code><a href="groovydoc/io/vertx/groovy/core/http/WebSocketFrame.html">WebSocketFrame</a></code> when a frame arrives,
for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">websocket.frameHandler({ frame -&gt;
  println("Received a frame of size!")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_closing_websockets">Closing WebSockets</h4>
<div class="paragraph">
<p>Use <code><a href="groovydoc/io/vertx/groovy/core/http/WebSocketBase.html#close()">close</a></code> to close the WebSocket connection when you have finished with it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_streaming_websockets">Streaming WebSockets</h4>
<div class="paragraph">
<p>The <code><a href="groovydoc/io/vertx/groovy/core/http/WebSocket.html">WebSocket</a></code> instance is also a <code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html">ReadStream</a></code> and a
<code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html">WriteStream</a></code> so it can be used with pumps.</p>
</div>
<div class="paragraph">
<p>When using a WebSocket as a write stream or a read stream it can only be used with WebSockets connections that are
used with binary frames that are no split over multiple frames.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_automatic_clean_up_in_verticles_4">Automatic clean-up in verticles</h3>
<div class="paragraph">
<p>If you&#8217;re creating http servers and clients from inside verticles, those servers and clients will be automatically closed
when the verticle is undeployed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_shared_data_with_vert_x">Using Shared Data with Vert.x</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Shared data contains functionality that allows you to safely share data between different parts of your application,
or different applications in the same Vert.x instance or across a cluster of Vert.x instances.</p>
</div>
<div class="paragraph">
<p>Shared data includes local shared maps, distributed, cluster-wide maps, asynchronous cluster-wide locks and
asynchronous cluster-wide counters.</p>
</div>
<div class="sect2">
<h3 id="_local_shared_maps">Local shared maps</h3>
<div class="paragraph">
<p><code><a href="groovydoc/io/vertx/groovy/core/shareddata/LocalMap.html">Local shared maps</a></code> allow you to share data safely between different event
loops (e.g. different verticles) in the same Vert.x instance.</p>
</div>
<div class="paragraph">
<p>Local shared maps only allow certain data types to be used as keys and values. Those types must either be immutable,
or certain other types that can be copied like <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html">Buffer</a></code>. In the latter case the key/value
will be copied before putting it in the map.</p>
</div>
<div class="paragraph">
<p>This way we can ensure there is no <em>shared access to mutable state</em> between different threads in your Vert.x application
so you don&#8217;t have to worry about protecting that state by synchronising access to it.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of using a shared local map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer

def sd = vertx.sharedData()

def map1 = sd.getLocalMap("mymap1")

map1.put("foo", "bar")

def map2 = sd.getLocalMap("mymap2")

map2.put("eek", Buffer.buffer().appendInt(123))

// Then... in another part of your application:

map1 = sd.getLocalMap("mymap1")

def val = map1.get("foo")

map2 = sd.getLocalMap("mymap2")

def buff = map2.get("eek")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cluster_wide_asynchronous_maps">Cluster-wide asynchronous maps</h3>
<div class="paragraph">
<p>Cluster-wide asynchronous maps allow data to be put in the map from any node of the cluster and retrieved from any
other node.</p>
</div>
<div class="paragraph">
<p>This makes them really useful for things like storing session state in a farm of servers hosting a Vert.x web
application.</p>
</div>
<div class="paragraph">
<p>You get an instance of <code><a href="groovydoc/io/vertx/groovy/core/shareddata/AsyncMap.html">AsyncMap</a></code> with
<code><a href="groovydoc/io/vertx/groovy/core/shareddata/SharedData.html#getClusterWideMap(java.lang.String,%20io.vertx.core.Handler)">getClusterWideMap</a></code>.</p>
</div>
<div class="paragraph">
<p>Getting the map is asynchronous and the result is returned to you in the handler that you specify. Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def sd = vertx.sharedData()

sd.getClusterWideMap("mymap", { res -&gt;
  if (res.succeeded()) {
    def map = res.result()
  } else {
    // Something went wrong!
  }
})</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_putting_data_in_a_map">Putting data in a map</h4>
<div class="paragraph">
<p>You put data in a map with <code><a href="groovydoc/io/vertx/groovy/core/shareddata/AsyncMap.html#put(java.lang.Object,%20java.lang.Object,%20io.vertx.core.Handler)">put</a></code>.</p>
</div>
<div class="paragraph">
<p>The actual put is asynchronous and the handler is notified once it is complete:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">map.put("foo", "bar", { resPut -&gt;
  if (resPut.succeeded()) {
    // Successfully put the value
  } else {
    // Something went wrong!
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_getting_data_from_a_map">Getting data from a map</h4>
<div class="paragraph">
<p>You get data from a map with <code><a href="groovydoc/io/vertx/groovy/core/shareddata/AsyncMap.html#get(java.lang.Object,%20io.vertx.core.Handler)">get</a></code>.</p>
</div>
<div class="paragraph">
<p>The actual get is asynchronous and the handler is notified with the result some time later</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">map.get("foo", { resGet -&gt;
  if (resGet.succeeded()) {
    // Successfully got the value
    def val = resGet.result()
  } else {
    // Something went wrong!
  }
})</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_other_map_operations">Other map operations</h5>
<div class="paragraph">
<p>You can also remove entries from an asynchronous map, clear them and get the size.</p>
</div>
<div class="paragraph">
<p>See the <code><a href="groovydoc/io/vertx/groovy/core/shareddata/AsyncMap.html">API docs</a></code> for more information.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cluster_wide_locks">Cluster-wide locks</h3>
<div class="paragraph">
<p><code><a href="groovydoc/io/vertx/groovy/core/shareddata/Lock.html">Cluster wide locks</a></code> allow you to obtain exclusive locks across the cluster -
this is useful when you want to do something or access a resource on only one node of a cluster at any one time.</p>
</div>
<div class="paragraph">
<p>Cluster wide locks have an asynchronous API unlike most lock APIs which block the calling thread until the lock
is obtained.</p>
</div>
<div class="paragraph">
<p>To obtain a lock use <code><a href="groovydoc/io/vertx/groovy/core/shareddata/SharedData.html#getLock(java.lang.String,%20io.vertx.core.Handler)">getLock</a></code>.</p>
</div>
<div class="paragraph">
<p>This won&#8217;t block, but when the lock is available, the handler will be called with an instance of <code><a href="groovydoc/io/vertx/groovy/core/shareddata/Lock.html">Lock</a></code>,
signifying that you now own the lock.</p>
</div>
<div class="paragraph">
<p>While you own the lock no other caller, anywhere on the cluster will be able to obtain the lock.</p>
</div>
<div class="paragraph">
<p>When you&#8217;ve finished with the lock, you call <code><a href="groovydoc/io/vertx/groovy/core/shareddata/Lock.html#release()">release</a></code> to release it, so
another caller can obtain it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">sd.getLock("mylock", { res -&gt;
  if (res.succeeded()) {
    // Got the lock!
    def lock = res.result()

    // 5 seconds later we release the lock so someone else can get it

    vertx.setTimer(5000, { tid -&gt;
      lock.release()})

  } else {
    // Something went wrong
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also get a lock with a timeout. If it fails to obtain the lock within the timeout the handler will be called
with a failure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">sd.getLockWithTimeout("mylock", 10000, { res -&gt;
  if (res.succeeded()) {
    // Got the lock!
    def lock = res.result()

  } else {
    // Failed to get lock
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cluster_wide_counters">Cluster-wide counters</h3>
<div class="paragraph">
<p>It&#8217;s often useful to maintain an atomic counter across the different nodes of your application.</p>
</div>
<div class="paragraph">
<p>You can do this with <code><a href="groovydoc/io/vertx/groovy/core/shareddata/Counter.html">Counter</a></code>.</p>
</div>
<div class="paragraph">
<p>You obtain an instance with <code><a href="groovydoc/io/vertx/groovy/core/shareddata/SharedData.html#getCounter(java.lang.String,%20io.vertx.core.Handler)">getCounter</a></code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">sd.getCounter("mycounter", { res -&gt;
  if (res.succeeded()) {
    def counter = res.result()
  } else {
    // Something went wrong!
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you have an instance you can retrieve the current count, atomically increment it, decrement and add a value to
it using the various methods.</p>
</div>
<div class="paragraph">
<p>See the <code><a href="groovydoc/io/vertx/groovy/core/shareddata/Counter.html">API docs</a></code> for more information.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_file_system_with_vert_x">Using the file system with Vert.x</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Vert.x <code><a href="groovydoc/io/vertx/groovy/core/file/FileSystem.html">FileSystem</a></code> object provides many operations for manipulating the file system.</p>
</div>
<div class="paragraph">
<p>There is one file system object per Vert.x instance, and you obtain it with <code><a href="groovydoc/io/vertx/groovy/core/Vertx.html#fileSystem()">fileSystem</a></code>.</p>
</div>
<div class="paragraph">
<p>A blocking and a non blocking version of each operation is provided.</p>
</div>
<div class="paragraph">
<p>The non blocking versions take a handler which is called when the operation completes or an error occurs.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of asynchronously copying a file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def fs = vertx.fileSystem()

// Copy file from foo.txt to bar.txt
fs.copy("foo.txt", "bar.txt", { res -&gt;
  if (res.succeeded()) {
    // Copied ok!
  } else {
    // Something went wrong
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The blocking versions are named  and return the results or throw exceptions directly.</p>
</div>
<div class="paragraph">
<p>In many cases, depending on the operating system and file system,some of the potentially blocking operations
can return quickly, which is why we provide them, but it&#8217;s highly recommended that you test how long they take to
return in your particular application before using them from an event loop, so as not to break the Golden Rule.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the copy using the blocking API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def fs = vertx.fileSystem()

// Copy file from foo.txt to bar.txt synchronously
fs.copyBlocking("foo.txt", "bar.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Many operations exist to copy, move, truncate, chmod and many other file operations.</p>
</div>
<div class="paragraph">
<p>We won&#8217;t list them all here, please consult the <code><a href="groovydoc/io/vertx/groovy/core/file/FileSystem.html">API docs</a></code> for the full list.</p>
</div>
<div class="sect2">
<h3 id="_asynchronous_files">Asynchronous files</h3>
<div class="paragraph">
<p>Vert.x provides an asynchronous file abstraction that allows you to manipulate a file on the file system</p>
</div>
<div class="paragraph">
<p>You open an <code><a href="groovydoc/io/vertx/groovy/core/file/AsyncFile.html">AsyncFile</a></code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def options = [:]
fileSystem.open("myfile.txt", options, { res -&gt;
  if (res.succeeded()) {
    def file = res.result()
  } else {
    // Something went wrong!
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_datagram_sockets_udp">Datagram sockets (UDP)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Using User Datagram Protocol (UDP) with Vert.x is a piece of cake.</p>
</div>
<div class="paragraph">
<p>UDP is a connection-less transport which basically means you have no persistent connection to a remote peer.</p>
</div>
<div class="paragraph">
<p>Instead you can send and receive packages and the remote address is contained in each of them.</p>
</div>
<div class="paragraph">
<p>Beside this UDP is not as safe as TCP to use, which means there are no guarantees that a send Datagram packet will
receive it&#8217;s endpoint at all.</p>
</div>
<div class="paragraph">
<p>The only guarantee is that it will either receive complete or not at all.</p>
</div>
<div class="paragraph">
<p>Also you usually can&#8217;t send data which is bigger then the MTU size of your network interface, this is because each
packet will be send as one packet.</p>
</div>
<div class="paragraph">
<p>But be aware even if the packet size is smaller then the MTU it may still fail.</p>
</div>
<div class="paragraph">
<p>At which size it will fail depends on the Operating System etc. So rule of thumb is to try to send small packets.</p>
</div>
<div class="paragraph">
<p>Because of the nature of UDP it is best fit for Applications where you are allowed to drop packets (like for
example a monitoring application).</p>
</div>
<div class="paragraph">
<p>The benefits are that it has a lot less overhead compared to TCP, which can be handled by the NetServer
and NetClient (see above).</p>
</div>
<div class="sect2">
<h3 id="_creating_a_datagramsocket">Creating a DatagramSocket</h3>
<div class="paragraph">
<p>To use UDP you first need t create a <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html">DatagramSocket</a></code>. It does not matter here if you only want to send data or send
and receive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def socket = vertx.createDatagramSocket([:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html">DatagramSocket</a></code> will not be bound to a specific port. This is not a
problem if you only want to send data (like a client), but more on this in the next section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sending_datagram_packets">Sending Datagram packets</h3>
<div class="paragraph">
<p>As mentioned before, User Datagram Protocol (UDP) sends data in packets to remote peers but is not connected to
them in a persistent fashion.</p>
</div>
<div class="paragraph">
<p>This means each packet can be sent to a different remote peer.</p>
</div>
<div class="paragraph">
<p>Sending packets is as easy as shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
def socket = vertx.createDatagramSocket([:])
def buffer = Buffer.buffer("content")
// Send a Buffer
socket.send(buffer, 1234, "10.0.0.1", { asyncResult -&gt;
  println("Send succeeded? ${asyncResult.succeeded()}")
})
// Send a String
socket.send("A string used as content", 1234, "10.0.0.1", { asyncResult -&gt;
  println("Send succeeded? ${asyncResult.succeeded()}")
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_receiving_datagram_packets">Receiving Datagram packets</h3>
<div class="paragraph">
<p>If you want to receive packets you need to bind the <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html">DatagramSocket</a></code> by calling
<code>listen(&#8230;&#8203;)}</code> on it.</p>
</div>
<div class="paragraph">
<p>This way you will be able to receive <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramPacket.html">DatagramPacket</a>`s that were sent to the address and port on
which the `<a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html">DatagramSocket</a></code> listens.</p>
</div>
<div class="paragraph">
<p>Beside this you also want to set a <code>Handler</code> which will be called for each received <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramPacket.html">DatagramPacket</a></code>.</p>
</div>
<div class="paragraph">
<p>The <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramPacket.html">DatagramPacket</a></code> has the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramPacket.html#sender()">sender</a></code>: The InetSocketAddress which represent the sender of the packet</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramPacket.html#data()">data</a></code>: The Buffer which holds the data which was received.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So to listen on a specific address and port you would do something like shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def socket = vertx.createDatagramSocket([:])
socket.listen(1234, "0.0.0.0", { asyncResult -&gt;
  if (asyncResult.succeeded()) {
    socket.handler({ packet -&gt;
      // Do something with the packet
    })
  } else {
    println("Listen failed${asyncResult.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be aware that even if the {code AsyncResult} is successed it only means it might be written on the network
stack, but gives no guarantee that it ever reached or will reach the remote peer at all.</p>
</div>
<div class="paragraph">
<p>If you need such a guarantee then you want to use TCP with some handshaking logic build on top.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multicast">Multicast</h3>
<div class="sect3">
<h4 id="_sending_multicast_packets">Sending Multicast packets</h4>
<div class="paragraph">
<p>Multicast allows multiple sockets to receive the same packets. This works by have same join a multicast group
to which you can send packets.</p>
</div>
<div class="paragraph">
<p>We will look at how you can joint a Multicast Group and so receive packets in the next section.</p>
</div>
<div class="paragraph">
<p>For now let us focus on how to send those. Sending multicast packets is not different to send normal Datagram Packets.</p>
</div>
<div class="paragraph">
<p>The only difference is that you would pass in a multicast group address to the send method.</p>
</div>
<div class="paragraph">
<p>This is show here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.buffer.Buffer
def socket = vertx.createDatagramSocket([:])
def buffer = Buffer.buffer("content")
// Send a Buffer to a multicast address
socket.send(buffer, 1234, "230.0.0.1", { asyncResult -&gt;
  println("Send succeeded? ${asyncResult.succeeded()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>All sockets that have joined the multicast group 230.0.0.1 will receive the packet.</p>
</div>
<div class="sect4">
<h5 id="_receiving_multicast_packets">Receiving Multicast packets</h5>
<div class="paragraph">
<p>If you want to receive packets for specific Multicast group you need to bind the <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html">DatagramSocket</a></code> by
calling <code>listen(&#8230;&#8203;)</code> on it and join the Multicast group.</p>
</div>
<div class="paragraph">
<p>This way you will be able to receive DatagramPackets that were sent to the address and port on which the
<code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html">DatagramSocket</a></code> listens and also to those sent to the Multicast group.</p>
</div>
<div class="paragraph">
<p>Beside this you also want to set a Handler which will be called for each received DatagramPacket.</p>
</div>
<div class="paragraph">
<p>The <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramPacket.html">DatagramPacket</a></code> has the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sender()</code>: The InetSocketAddress which represent the sender of the packet</p>
</li>
<li>
<p><code>data()</code>: The Buffer which holds the data which was received.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So to listen on a specific address and port and also receive packets for the Multicast group 230.0.0.1 you
would do something like shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def socket = vertx.createDatagramSocket([:])
socket.listen(1234, "0.0.0.0", { asyncResult -&gt;
  if (asyncResult.succeeded()) {
    socket.handler({ packet -&gt;
      // Do something with the packet
    })

    // join the multicast group
    socket.listenMulticastGroup("230.0.0.1", { asyncResult2 -&gt;
      println("Listen succeeded? ${asyncResult2.succeeded()}")
    })
  } else {
    println("Listen failed${asyncResult.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_unlisten_leave_a_multicast_group">Unlisten / leave a Multicast group</h5>
<div class="paragraph">
<p>There are sometimes situations where you want to receive packets for a Multicast group for a limited time.</p>
</div>
<div class="paragraph">
<p>In this situations you can first start to listen for them and then later unlisten.</p>
</div>
<div class="paragraph">
<p>This is shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def socket = vertx.createDatagramSocket([:])
socket.listen(1234, "0.0.0.0", { asyncResult -&gt;
  if (asyncResult.succeeded()) {
    socket.handler({ packet -&gt;
      // Do something with the packet
    })

    // join the multicast group
    socket.listenMulticastGroup("230.0.0.1", { asyncResult2 -&gt;
      if (asyncResult2.succeeded()) {
        // will now receive packets for group

        // do some work

        socket.unlistenMulticastGroup("230.0.0.1", { asyncResult3 -&gt;
          println("Unlisten succeeded? ${asyncResult3.succeeded()}")
        })
      } else {
        println("Listen failed${asyncResult2.cause()}")
      }
    })
  } else {
    println("Listen failed${asyncResult.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_blocking_multicast">Blocking multicast</h5>
<div class="paragraph">
<p>Beside unlisten a Multicast address it&#8217;s also possible to just block multicast for a specific sender address.</p>
</div>
<div class="paragraph">
<p>Be aware this only work on some Operating Systems and kernel versions. So please check the Operating System
documentation if it&#8217;s supported.</p>
</div>
<div class="paragraph">
<p>This an expert feature.</p>
</div>
<div class="paragraph">
<p>To block multicast from a specific address you can call <code>blockMulticastGroup(&#8230;&#8203;)</code> on the DatagramSocket
like shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def socket = vertx.createDatagramSocket([:])

// Some code

// This would block packets which are send from 10.0.0.2
socket.blockMulticastGroup("230.0.0.1", "10.0.0.2", { asyncResult -&gt;
  println("block succeeded? ${asyncResult.succeeded()}")
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_datagramsocket_properties">DatagramSocket properties</h4>
<div class="paragraph">
<p>When creating a <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html">DatagramSocket</a></code> there are multiple properties you can set to
change it&#8217;s behaviour with the <code><a href="../cheatsheet/DatagramSocketOptions.html">DatagramSocketOptions</a></code> object. Those are listed here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../cheatsheet/DatagramSocketOptions.html#sendBufferSize">sendBufferSize</a></code> Sets the send buffer size in bytes.</p>
</li>
<li>
<p><code><a href="../cheatsheet/DatagramSocketOptions.html#receiveBufferSize">receiveBufferSize</a></code> Sets the TCP receive buffer size
in bytes.</p>
</li>
<li>
<p><code><a href="../cheatsheet/DatagramSocketOptions.html#reuseAddress">reuseAddress</a></code> If true then addresses in TIME_WAIT
state can be reused after they have been closed.</p>
</li>
<li>
<p><code><a href="../cheatsheet/DatagramSocketOptions.html#trafficClass">trafficClass</a></code></p>
</li>
<li>
<p><code><a href="../cheatsheet/DatagramSocketOptions.html#broadcast">broadcast</a></code> Sets or clears the SO_BROADCAST socket
option. When this option is set, Datagram (UDP) packets may be sent to a local interface&#8217;s broadcast address.</p>
</li>
<li>
<p><code><a href="../cheatsheet/DatagramSocketOptions.html#multicastNetworkInterface">multicastNetworkInterface</a></code> Sets or clears
the IP_MULTICAST_LOOP socket option. When this option is set, multicast packets will also be received on the
local interface.</p>
</li>
<li>
<p><code><a href="../cheatsheet/DatagramSocketOptions.html#multicastTimeToLive">multicastTimeToLive</a></code> Sets the IP_MULTICAST_TTL socket
option. TTL stands for "Time to Live," but in this context it specifies the number of IP hops that a packet is
allowed to go through, specifically for multicast traffic. Each router or gateway that forwards a packet decrements
the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_datagramsocket_local_address">DatagramSocket Local Address</h4>
<div class="paragraph">
<p>You can find out the local address of the socket (i.e. the address of this side of the UDP Socket) by calling
<code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html#localAddress()">localAddress</a></code>. This will only return an <code>InetSocketAddress</code> if you
bound the <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html">DatagramSocket</a></code> with <code>listen(&#8230;&#8203;)</code> before, otherwise it will return null.</p>
</div>
</div>
<div class="sect3">
<h4 id="_closing_a_datagramsocket">Closing a DatagramSocket</h4>
<div class="paragraph">
<p>You can close a socket by invoking the <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html#close(io.vertx.core.Handler)">close</a></code> method. This will close
the socket and release all resources</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dns_client">DNS client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Often you will find yourself in situations where you need to obtain DNS informations in an asynchronous fashion.</p>
</div>
<div class="paragraph">
<p>Unfortunally this is not possible with the API that is shipped with the Java Virtual Machine itself. Because of
this Vert.x offers it&#8217;s own API for DNS resolution which is fully asynchronous.</p>
</div>
<div class="paragraph">
<p>To obtain a DnsClient instance you will create a new via the Vertx instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be aware that you can pass in a varargs of InetSocketAddress arguments to specifiy more then one DNS Server to try
to query for DNS resolution. The DNS Servers will be queried in the same order as specified here. Where the next
will be used once the first produce an error while be used.</p>
</div>
<div class="sect2">
<h3 id="_lookup">lookup</h3>
<div class="paragraph">
<p>Try to lookup the A (ipv4) or AAAA (ipv6) record for a given name. The first which is returned will be used,
so it behaves the same way as you may be used from when using "nslookup" on your operation system.</p>
</div>
<div class="paragraph">
<p>To lookup the A / AAAA record for "vertx.io" you would typically use it like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.lookup("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    println(ar.result())
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lookup4">lookup4</h3>
<div class="paragraph">
<p>Try to lookup the A (ipv4) record for a given name. The first which is returned will be used, so it behaves
the same way as you may be used from when using "nslookup" on your operation system.</p>
</div>
<div class="paragraph">
<p>To lookup the A record for "vertx.io" you would typically use it like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.lookup4("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    println(ar.result())
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lookup6">lookup6</h3>
<div class="paragraph">
<p>Try to lookup the AAAA (ipv6) record for a given name. The first which is returned will be used, so it behaves the
same way as you may be used from when using "nslookup" on your operation system.</p>
</div>
<div class="paragraph">
<p>To lookup the A record for "vertx.io" you would typically use it like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.lookup6("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    println(ar.result())
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvea">resolveA</h3>
<div class="paragraph">
<p>Try to resolve all A (ipv4) records for a given name. This is quite similar to using "dig" on unix like operation
systems.</p>
</div>
<div class="paragraph">
<p>To lookup all the A records for "vertx.io" you would typically do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.resolveA("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    def records = ar.result()
    records.each { record -&gt;
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolveaaaa">resolveAAAA</h3>
<div class="paragraph">
<p>Try to resolve all AAAA (ipv6) records for a given name. This is quite similar to using "dig" on unix like
operation systems.</p>
</div>
<div class="paragraph">
<p>To lookup all the AAAAA records for "vertx.io" you would typically do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.resolveAAAA("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    def records = ar.result()
    records.each { record -&gt;
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvecname">resolveCNAME</h3>
<div class="paragraph">
<p>Try to resolve all CNAME records for a given name. This is quite similar to using "dig" on unix like operation
systems.</p>
</div>
<div class="paragraph">
<p>To lookup all the CNAME records for "vertx.io" you would typically do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.resolveCNAME("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    def records = ar.result()
    records.each { record -&gt;
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvemx">resolveMX</h3>
<div class="paragraph">
<p>Try to resolve all MX records for a given name. The MX records are used to define which Mail-Server accepts
emails for a given domain.</p>
</div>
<div class="paragraph">
<p>To lookup all the MX records for "vertx.io" you would typically do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.resolveMX("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    def records = ar.result()
    records.each { record -&gt;
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be aware that the List will contain the <code><a href="groovydoc/io/vertx/groovy/core/dns/MxRecord.html">MxRecord</a></code> sorted by the priority of them, which
means MX records with smaller priority coming first in the List.</p>
</div>
<div class="paragraph">
<p>The <code><a href="groovydoc/io/vertx/groovy/core/dns/MxRecord.html">MxRecord</a></code> allows you to access the priority and the name of the MX record by offer methods for it like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">todo</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvetxt">resolveTXT</h3>
<div class="paragraph">
<p>Try to resolve all TXT records for a given name. TXT records are often used to define extra informations for a domain.</p>
</div>
<div class="paragraph">
<p>To resolve all the TXT records for "vertx.io" you could use something along these lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.resolveTXT("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    def records = ar.result()
    records.each { record -&gt;
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvens">resolveNS</h3>
<div class="paragraph">
<p>Try to resolve all NS records for a given name. The NS records specify which DNS Server hosts the DNS informations
for a given domain.</p>
</div>
<div class="paragraph">
<p>To resolve all the NS records for "vertx.io" you could use something along these lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.resolveNS("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    def records = ar.result()
    records.each { record -&gt;
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvesrv">resolveSRV</h3>
<div class="paragraph">
<p>Try to resolve all SRV records for a given name. The SRV records are used to define extra informations like port and
hostname of services. Some protocols need this extra informations.</p>
</div>
<div class="paragraph">
<p>To lookup all the SRV records for "vertx.io" you would typically do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.resolveSRV("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    def records = ar.result()
    records.each { record -&gt;
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be aware that the List will contain the SrvRecords sorted by the priority of them, which means SrvRecords
with smaller priority coming first in the List.</p>
</div>
<div class="paragraph">
<p>The SrvRecord allows you to access all informations contained in the SRV record itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">todo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please refer to the API docs for the exact details.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolveptr">resolvePTR</h3>
<div class="paragraph">
<p>Try to resolve the PTR record for a given name. The PTR record maps an ipaddress to a name.</p>
</div>
<div class="paragraph">
<p>To resolve the PTR record for the ipaddress 10.0.0.1 you would use the PTR notion of "1.0.0.10.in-addr.arpa"</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.resolvePTR("1.0.0.10.in-addr.arpa", { ar -&gt;
  if (ar.succeeded()) {
    def record = ar.result()
    println(record)
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reverselookup">reverseLookup</h3>
<div class="paragraph">
<p>Try to do a reverse lookup for an ipaddress. This is basically the same as resolve a PTR record, but allows you to
just pass in the ipaddress and not a valid PTR query string.</p>
</div>
<div class="paragraph">
<p>To do a reverse lookup for the ipaddress 10.0.0.1 do something similar like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = vertx.createDnsClient(53, "10.0.0.1")
client.reverseLookup("10.0.0.1", { ar -&gt;
  if (ar.succeeded()) {
    def record = ar.result()
    println(record)
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unresolved directive in dns.adoc - include::override/dns.adoc[]</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="streams">Streams</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are several objects in Vert.x that allow items to be read from and written.</p>
</div>
<div class="paragraph">
<p>In previous versions the streams.adoc package was manipulating <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html">Buffer</a></code>
objects exclusively. From now, streams are not anymore coupled to buffers and work with any kind of objects.</p>
</div>
<div class="paragraph">
<p>In Vert.x, calls to write item return immediately and writes are internally queued.</p>
</div>
<div class="paragraph">
<p>It&#8217;s not hard to see that if you write to an object faster than it can actually write the data to
its underlying resource then the write queue could grow without bound - eventually resulting in
exhausting available memory.</p>
</div>
<div class="paragraph">
<p>To solve this problem a simple flow control capability is provided by some objects in the Vert.x API.</p>
</div>
<div class="paragraph">
<p>Any flow control aware object that can be written-to implements <code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html">ReadStream</a></code>,
and any flow control object that can be read-from is said to implement <code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html">WriteStream</a></code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take an example where we want to read from a <code>ReadStream</code> and write the data to a <code>WriteStream</code>.</p>
</div>
<div class="paragraph">
<p>A very simple example would be reading from a <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html">NetSocket</a></code> on a server and writing back to the
same <code>NetSocket</code> - since <code>NetSocket</code> implements both <code>ReadStream</code> and <code>WriteStream</code>, but you can
do this between any <code>ReadStream</code> and any <code>WriteStream</code>, including HTTP requests and response,
async files, WebSockets, etc.</p>
</div>
<div class="paragraph">
<p>A naive way to do this would be to directly take the data that&#8217;s been read and immediately write it
to the <code>NetSocket</code>, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer([
  port:1234,
  host:"localhost"
])
server.connectHandler({ sock -&gt;
  sock.handler({ buffer -&gt;
    // Write the data straight back
    sock.write(buffer)
  })
}).listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s a problem with the above example: If data is read from the socket faster than it can be
written back to the socket, it will build up in the write queue of the <code>NetSocket</code>, eventually
running out of RAM. This might happen, for example if the client at the other end of the socket
wasn&#8217;t reading very fast, effectively putting back-pressure on the connection.</p>
</div>
<div class="paragraph">
<p>Since <code>NetSocket</code> implements <code>WriteStream</code>, we can check if the <code>WriteStream</code> is full before
writing to it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer([
  port:1234,
  host:"localhost"
])
server.connectHandler({ sock -&gt;
  sock.handler({ buffer -&gt;
    if (!sock.writeQueueFull()) {
      sock.write(buffer)
    }
  })

}).listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example won&#8217;t run out of RAM but we&#8217;ll end up losing data if the write queue gets full. What we
really want to do is pause the <code>NetSocket</code> when the write queue is full. Let&#8217;s do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer([
  port:1234,
  host:"localhost"
])
server.connectHandler({ sock -&gt;
  sock.handler({ buffer -&gt;
    sock.write(buffer)
    if (sock.writeQueueFull()) {
      sock.pause()
    }
  })
}).listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re almost there, but not quite. The <code>NetSocket</code> now gets paused when the file is full, but we also need to unpause
it when the write queue has processed its backlog:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = vertx.createNetServer([
  port:1234,
  host:"localhost"
])
server.connectHandler({ sock -&gt;
  sock.handler({ buffer -&gt;
    sock.write(buffer)
    if (sock.writeQueueFull()) {
      sock.pause()
      sock.drainHandler({ done -&gt;
        sock.resume()
      })
    }
  })
}).listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>And there we have it. The <code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html#drainHandler(io.vertx.core.Handler)">drainHandler</a></code> event handler will
get called when the write queue is ready to accept more data, this resumes the <code>NetSocket</code> which
allows it to read more data.</p>
</div>
<div class="paragraph">
<p>It&#8217;s very common to want to do this when writing Vert.x applications, so we provide a helper class
called <code><a href="groovydoc/io/vertx/groovy/core/streams/Pump.html">Pump</a></code> which does all this hard work for you. You just feed it the <code>ReadStream</code> and
the <code>WriteStream</code> and it tell it to start:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import io.vertx.groovy.core.streams.Pump
def server = vertx.createNetServer([
  port:1234,
  host:"localhost"
])
server.connectHandler({ sock -&gt;
  Pump.pump(sock, sock).start()
}).listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which does exactly the same thing as the more verbose example.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the methods on <code>ReadStream</code> and <code>WriteStream</code> in more detail:</p>
</div>
<div class="sect2">
<h3 id="_readstream">ReadStream</h3>
<div class="paragraph">
<p><code>ReadStream</code> is implemented by <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientResponse.html">HttpClientResponse</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/datagram/DatagramSocket.html">DatagramSocket</a></code>,
<code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html">HttpClientRequest</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerFileUpload.html">HttpServerFileUpload</a></code>,
<code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequest.html">HttpServerRequest</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerRequestStream.html">HttpServerRequestStream</a></code>,
<code><a href="groovydoc/io/vertx/groovy/core/eventbus/MessageConsumer.html">MessageConsumer</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html">NetSocket</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocketStream.html">NetSocketStream</a></code>,
<code><a href="groovydoc/io/vertx/groovy/core/http/WebSocket.html">WebSocket</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/http/WebSocketStream.html">WebSocketStream</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/TimeoutStream.html">TimeoutStream</a></code>,
<code><a href="groovydoc/io/vertx/groovy/core/file/AsyncFile.html">AsyncFile</a></code>.</p>
</div>
<div class="paragraph">
<p>Functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html#handler(io.vertx.core.Handler)">handler</a></code>:
set a handler which will receive items from the ReadStream.</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html#pause()">pause</a></code>:
pause the handler. When paused no items will be received in the handler.</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html#resume()">resume</a></code>:
resume the handler. The handler will be called if any item arrives.</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html#exceptionHandler(io.vertx.core.Handler)">exceptionHandler</a></code>:
Will be called if an exception occurs on the ReadStream.</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/ReadStream.html#endHandler(io.vertx.core.Handler)">endHandler</a></code>:
Will be called when end of stream is reached. This might be when EOF is reached if the ReadStream represents a file,
or when end of request is reached if it&#8217;s an HTTP request, or when the connection is closed if it&#8217;s a TCP socket.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_writestream">WriteStream</h3>
<div class="paragraph">
<p><code>WriteStream</code> is implemented by <code><a href="groovydoc/io/vertx/groovy/core/http/HttpClientRequest.html">HttpClientRequest</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/http/HttpServerResponse.html">HttpServerResponse</a></code>
<code><a href="groovydoc/io/vertx/groovy/core/http/WebSocket.html">WebSocket</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/net/NetSocket.html">NetSocket</a></code>, <code><a href="groovydoc/io/vertx/groovy/core/file/AsyncFile.html">AsyncFile</a></code>,
<code><a href="groovydoc/io/vertx/groovy/core/datagram/PacketWritestream.html">PacketWritestream</a></code> and <code><a href="groovydoc/io/vertx/groovy/core/eventbus/MessageProducer.html">MessageProducer</a></code></p>
</div>
<div class="paragraph">
<p>Functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html#write(java.lang.Object)">write</a></code>:
write an object to the WriteStream. This method will never block. Writes are queued internally and asynchronously
written to the underlying resource.</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html#setWriteQueueMaxSize(int)">setWriteQueueMaxSize</a></code>:
set the number of object at which the write queue is considered <em>full</em>, and the method <code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html#writeQueueFull()">writeQueueFull</a></code>
returns <code>true</code>. Note that, when the write queue is considered full, if write is called the data will still be accepted
and queued. The actual number depends on the stream implementation, for <code><a href="groovydoc/io/vertx/groovy/core/buffer/Buffer.html">Buffer</a></code> the size
represents the actual number of bytes written and not the number of buffers.</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html#writeQueueFull()">writeQueueFull</a></code>:
returns <code>true</code> if the write queue is considered full.</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html#exceptionHandler(io.vertx.core.Handler)">exceptionHandler</a></code>:
Will be called if an exception occurs on the <code>WriteStream</code>.</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html#drainHandler(io.vertx.core.Handler)">drainHandler</a></code>:
The handler will be called if the <code>WriteStream</code> is considered no longer full.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_pump">Pump</h3>
<div class="paragraph">
<p>Instances of Pump have the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/Pump.html#start()">start</a></code>:
Start the pump.</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/Pump.html#stop()">stop</a></code>:
Stops the pump. When the pump starts it is in stopped mode.</p>
</li>
<li>
<p><code><a href="groovydoc/io/vertx/groovy/core/streams/Pump.html#setWriteQueueMaxSize(int)">setWriteQueueMaxSize</a></code>:
This has the same meaning as <code><a href="groovydoc/io/vertx/groovy/core/streams/WriteStream.html#setWriteQueueMaxSize(int)">setWriteQueueMaxSize</a></code> on the <code>WriteStream</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A pump can be started and stopped multiple times.</p>
</div>
<div class="paragraph">
<p>When a pump is first created it is <em>not</em> started. You need to call the <code>start()</code> method to start it.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_parse_tools">Parse tools</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_thread_safety">Thread safety</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Notes on thread safety of Vert.x objects</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_metrics_spi">Metrics SPI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default Vert.x does not record any metrics. Instead it provides an SPI for others to implement which can be added
to the classpath. The metrics SPI is an advanced feature which allows implementers to capture events from Vert.x in
order to gather metrics. For more information on this, please consult the
<code><a href="groovydoc/io/vertx/groovy/core/spi/metrics/VertxMetrics.html">API Documentation</a></code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_clustering">Clustering</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_trouble_shooting_clustering">Trouble-shooting clustering</h3>

</div>
<div class="sect2">
<h3 id="_high_availability_2">High Availability</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_security_notes">Security notes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Warn about file uploads and serving files from arbitrary locations</p>
</div>
<div class="paragraph">
<p>Vert.x is a tool kit</p>
</div>
<div class="paragraph">
<p>Run in a security sandbox</p>
</div>
<div class="paragraph">
<p>Use Apex</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-03-18 21:16:30 GMT
</div>
</div>
</body>
</html>