<!DOCTYPE html><html lang=en><head><title>Blog</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta content="width=device-width,initial-scale=1" name=viewport><meta content="Vert.x is a tool-kit for building reactive applications on the JVM." name=description><link href=http://vertx.io/stylesheets/main.css media=screen rel=stylesheet><link href=http://vertx.io/stylesheets/font-awesome.min.css media=screen rel=stylesheet><link href=http://vertx.io/javascripts/styles/rainbow.min.css media=screen rel=stylesheet><!--[if lt IE 9]><script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script><![endif]--><link href=http://vertx.io/assets/favicons/vertx-favicon-5.ico rel="shortcut icon"><link href="http://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel=stylesheet type=text/css><link rel=alternate type=application/rss+xml title=RSS href=http://vertx.io/feed.xml><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('send', 'pageview');</script></head><body><a href="http://www.reactivemanifesto.org/" id=reactive-manifesto-banner><img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000" src=http://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png></a> <a id=skippy class="sr-only sr-only-focusable" href=#content><div class=container><span class=skiplink-text>Skip to main content</span></div></a><header class="navbar navbar-default navbar-static-top" id=top role=banner><div class=container><div class=navbar-header><button class="navbar-toggle collapsed" type=button data-toggle=collapse data-target=#vertx-navbar-collapse><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button> <a href="http://vertx.io/" class=navbar-brand><img alt=Brand src=http://vertx.io/assets/logo-sm.png></a></div><nav class="collapse navbar-collapse" id=vertx-navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=https://bintray.com/vertx/downloads/distribution/view>Download</a></li><li><a href="http://vertx.io/docs/">Documentation</a></li><li><a href=https://github.com/vert-x3/wiki/wiki>Wiki</a></li><li><a href="http://vertx.io/community/">Community</a></li><li><a href=http://vertx.io/blog/blog.html>Blog</a></li><li><a href="http://vertx.io/vertx2/" class=vertx-2-link>Vert.x 2</a></li></ul></nav></div></header><div class=container><div class="row blog"><div class="col-sm-8 blog-main"><article class=blog-post><h2 class=blog-post-title><a href=/blog/some-rest-with-vert-x/index.html>Some Rest with Vert.x</a></h2><p class=blog-post-meta>27th July 2015 by <a href=http://github.com/cescoffier>cescoffier</a></p><article><h2 id=previously-in-this-blog-series>Previously in this blog series</h2><p>This post is part of the <em>Introduction to Vert.x</em> series. So, let’s have a quick look about the content of the previous posts. In <a href=/blog/my-first-vert-x-3-application/index.html>the first post</a>, we developed a very simple Vert.x 3 application, and saw how this application can be tested, packaged and executed. In <a href=/blog/vert-x-application-configuration/index.html>the last post</a>, we saw how this application became configurable and how we can use a random port in test.</p><p>Well, nothing fancy… Let’s go a bit further this time and develop a <em>CRUD-ish</em> application. So an application exposing an HTML page interacting with the backend using a REST API. The level of <em>RESTfullness</em> of the API is not the topic of this post, I let you decide as it’s a very slippery topic.</p><p>So, in other words we are going to see:</p><ul><li>Vert.x Web - a framework that let you create Web applications easily using Vert.x</li><li>How to expose static resources</li><li>How to develop a REST API</li></ul><p>The code developed in this post is available on the <a href=https://github.com/cescoffier/my-vertx-first-app/tree/post-3>post-3</a> branch of this <a href=https://github.com/cescoffier/my-vertx-first-app>Github</a> project. We are going to start from the <a href=https://github.com/cescoffier/my-vertx-first-app/tree/post-2>post-2</a> codebase.</p><p>So, let’s start.</p><h2 id=vert-x-web>Vert.x Web</h2><p>As you may have notices in the previous posts, dealing with complex HTTP application using only Vert.x Core would be kind of cumbersome. That’s the main reason behind <a href="http://vertx.io/docs/vertx-web/java/">Vert.x Web</a>. It makes the development of Vert.x base web applications really easy, without changing the philosophy.</p><p>To use Vert.x Web, you need to update the <code>pom.xml</code> file to add the following dependency:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>dependency</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>io.vertx<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>vertx-web<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>3.0.0<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>dependency</span>&gt;</span></code></pre><p>That’s the only thing you need to use Vert.x Web. Sweet, no ?</p><p>Let’s now use it. Remember, in the previous post, when we requested <a href=http://localhost:8080>http://localhost:8080</a>, we reply a nice <em>Hello World</em> message. Let’s do the same with Vert.x Web. Open the <code>io.vertx.blog.first.MyFirstVerticle</code> class and change the <code>start</code> method to be:</p><pre><code class="hljs java"><span class=hljs-annotation>@Override</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>(Future&lt;Void&gt; fut)</span> </span>{
 <span class=hljs-comment>// Create a router object.</span>
 Router router = Router.router(vertx);

 <span class=hljs-comment>// Bind "/" to our hello message - so we are still compatible.</span>
 router.route(<span class=hljs-string>"/"</span>).handler(routingContext -&gt; {
   HttpServerResponse response = routingContext.response();
   response
       .putHeader(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"text/html"</span>)
       .end(<span class=hljs-string>"&lt;h1&gt;Hello from my first Vert.x 3 application&lt;/h1&gt;"</span>);
 });

 <span class=hljs-comment>// Create the HTTP server and pass the "accept" method to the request handler.</span>
 vertx
     .createHttpServer()
     .requestHandler(router::accept)
     .listen(
         <span class=hljs-comment>// Retrieve the port from the configuration,</span>
         <span class=hljs-comment>// default to 8080.</span>
         config().getInteger(<span class=hljs-string>"http.port"</span>, <span class=hljs-number>8080</span>),
         result -&gt; {
           <span class=hljs-keyword>if</span> (result.succeeded()) {
             fut.complete();
           } <span class=hljs-keyword>else</span> {
             fut.fail(result.cause());
           }
         }
     );
}</code></pre><p>You may be surprise by the length of this snippet (in comparison to the previous code). But as we are going to see, it will make our app on steroids, just be patient.</p><p>As you can see, we start by creating a <code>Router</code> object. The router is the cornerstone of Vert.x Web. This object is responsible for dispatching the HTTP requests to the right <em>handler</em>. Two other concepts are very important in Vert.x Web:</p><ul><li>Routes - which let you define how request are dispatched</li><li>Handlers - which are the actual action processing the requests and writing the result. Handlers can be chained.</li></ul><p>If you understand these 3 concepts, you have understood everything in Vert.x Web.</p><p>Let’s focus on this code first:</p><pre><code class="hljs java">router.route(<span class=hljs-string>"/"</span>).handler(routingContext -&gt; {
  HttpServerResponse response = routingContext.response();
  response
      .putHeader(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"text/html"</span>)
      .end(<span class=hljs-string>"&lt;h1&gt;Hello from my first Vert.x 3 application&lt;/h1&gt;"</span>);
});</code></pre><p>It <em>routes</em> requests arriving on “/“ to the given <em>handler</em>. Handlers receive a <code>RoutingContext</code> object. This handler is quite similar to the code we had before, and it’s quite normal as it manipulates the same type of object: <code>HttpServerResponse</code>.</p><p>Let’s now have a look to the rest of the code:</p><pre><code class="hljs java">vertx
    .createHttpServer()
    .requestHandler(router::accept)
    .listen(
        <span class=hljs-comment>// Retrieve the port from the configuration,</span>
        <span class=hljs-comment>// default to 8080.</span>
        config().getInteger(<span class=hljs-string>"http.port"</span>, <span class=hljs-number>8080</span>),
        result -&gt; {
          <span class=hljs-keyword>if</span> (result.succeeded()) {
            fut.complete();
          } <span class=hljs-keyword>else</span> {
            fut.fail(result.cause());
          }
        }
    );
}</code></pre><p>It’s basically the same code as before, except that we change the request handler. We pass <code>router::accept</code> to the handler. You may not be familiar with this notation. It’s a reference to a method (here the method <code>accept</code> from the <code>router</code> object). In other worlds, it instructs vert.x to call the <code>accept</code> method of the <code>router</code> when it receives a request.</p><p>Let’s try to see if this work:</p><pre><code class=hljs>mvn clean package
java -jar target/<span class=hljs-keyword>my</span>-<span class=hljs-keyword>first</span>-app-<span class=hljs-number>1.0</span>-SNAPSHOT-fat.jar</code></pre><p>By opening <code>http://localhost:8080</code> in your browser you should see the <em>Hello</em> message. As we didn’t change the behavior of the application, our tests are still valid.</p><h2 id=exposing-static-resources>Exposing static resources</h2><p>Ok, so we have a first application using vert.x web. Let’s see some of the benefits. Let’s start with serving static resources, such as an <code>index.html</code> page. Before we go further, I should start with a disclaimer: “the HTML page we are going to see here is ugly like hell : I’m not a UI guy”. I should also add that there are probably plenty of better ways to implement this and a myriad of frameworks I should try, but that’s not the point. I tried to keep things simple and just relying on JQuery and Twitter Bootstrap, so if you know a bit of JavaScript you can understand and edit the page.</p><p>Let’s create the HTML page that will be the entry point of our application. Create an <code>index.html</code> page in <code>src/main/resources/assets</code> with the content from <a href=https://github.com/cescoffier/my-vertx-first-app/blob/post-3/src/main/resources/assets/index.html>here</a>. As it’s just a HTML page with a bit of JavaScript, we won’t detail the file here. If you have questions, just post comments.</p><p>Basically, the page is a simple <em>CRUD</em> UI to manage my collection of <em>not-yet-finished</em> bottles of Whisky. It was made in a generic way, so you can transpose it to your own collection. The list of product is displayed in the main table. You can create a new product, edit one or delete one. These actions are relying on a REST API (that we are going to implement) through AJAX calls. That’s all.</p><p>Once this page is created, edit the <code>io.vertx.blog.first.MyFirstVerticle</code> class and change the <code>start</code> method to be:</p><pre><code class="hljs java"><span class=hljs-annotation>@Override</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>(Future&lt;Void&gt; fut)</span> </span>{
 Router router = Router.router(vertx);
 router.route(<span class=hljs-string>"/"</span>).handler(routingContext -&gt; {
   HttpServerResponse response = routingContext.response();
   response
       .putHeader(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"text/html"</span>)
       .end(<span class=hljs-string>"&lt;h1&gt;Hello from my first Vert.x 3 application&lt;/h1&gt;"</span>);
 });

 <span class=hljs-comment>// Serve static resources from the /assets directory</span>
 router.route(<span class=hljs-string>"/assets/*"</span>).handler(StaticHandler.create(<span class=hljs-string>"assets"</span>));

 vertx
     .createHttpServer()
     .requestHandler(router::accept)
     .listen(
         <span class=hljs-comment>// Retrieve the port from the configuration,</span>
         <span class=hljs-comment>// default to 8080.</span>
         config().getInteger(<span class=hljs-string>"http.port"</span>, <span class=hljs-number>8080</span>),
         result -&gt; {
           <span class=hljs-keyword>if</span> (result.succeeded()) {
             fut.complete();
           } <span class=hljs-keyword>else</span> {
             fut.fail(result.cause());
           }
         }
     );
}</code></pre><p>The only difference with the previous code is the <code>router.route(&quot;/assets/*&quot;).handler(StaticHandler.create(&quot;assets&quot;));</code> line. So, what does this line mean? It’s actually quite simple. It <em>routes</em> requests on “/assets/*” to resources stored in the “assets” directory. So our <code>index.html</code> page is going to be served using <code>http://localhost:8080/assets/index.html</code>.</p><p>Before testing this, let’s take a few seconds on the handler creation. All processing actions in Vert.x web are implemented as <em>handler</em>. To create a handler you always call the <code>create</code> method.</p><p>So, I’m sure you are impatient to see our beautiful HTML page. Let’s build and run the application:</p><pre><code class=hljs>mvn clean package
java -jar target/<span class=hljs-keyword>my</span>-<span class=hljs-keyword>first</span>-app-<span class=hljs-number>1.0</span>-SNAPSHOT-fat.jar</code></pre><p>Now, open your browser to <code>http://localhost:8080/assets/index.html</code>. Here it is… Ugly right? I told you.</p><p>As you may notice too… the table is empty, this is because we didn’t implement the REST API yet. Let’s do that now.</p><h2 id=rest-api-with-vert-x-web>REST API with Vert.x Web</h2><p>Vert.x Web makes the implementation of REST API really easy, as it basically <em>routes</em> your URL to the right handler. The API is very simple, and will be structured as follows:</p><ul><li><code>GET /api/whiskies</code> =&gt; get all bottles (<code>getAll</code>)</li><li><code>GET /api/whiskies/:id</code> =&gt; get the bottle with the corresponding id (<code>getOne</code>)</li><li><code>POST /api/whiskies</code> =&gt; add a new bottle (<code>addOne</code>)</li><li><code>PUT /api/whiskies/:id</code> =&gt; update a bottle (<code>updateOne</code>)</li><li><code>DELETE /api/whiskies/id</code> =&gt; delete a bottle (<code>deleteOne</code>)</li></ul><h3 id=we-need-some-data->We need some data…</h3><p>But before going further, let’s create our <em>data</em> object. Create the <code>src/main/java/io/vertx/blog/first/Whisky.java</code> with the following content:</p><pre><code class="hljs java"><span class=hljs-keyword>package</span> io.vertx.blog.first;

<span class=hljs-keyword>import</span> java.util.concurrent.atomic.AtomicInteger;

<span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Whisky</span> </span>{

  <span class=hljs-keyword>private</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>final</span> AtomicInteger COUNTER = <span class=hljs-keyword>new</span> AtomicInteger();

  <span class=hljs-keyword>private</span> <span class=hljs-keyword>final</span> <span class=hljs-keyword>int</span> id;

  <span class=hljs-keyword>private</span> String name;

  <span class=hljs-keyword>private</span> String origin;

  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-title>Whisky</span><span class=hljs-params>(String name, String origin)</span> </span>{
    <span class=hljs-keyword>this</span>.id = COUNTER.getAndIncrement();
    <span class=hljs-keyword>this</span>.name = name;
    <span class=hljs-keyword>this</span>.origin = origin;
  }

  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-title>Whisky</span><span class=hljs-params>()</span> </span>{
    <span class=hljs-keyword>this</span>.id = COUNTER.getAndIncrement();
  }

  <span class=hljs-function><span class=hljs-keyword>public</span> String <span class=hljs-title>getName</span><span class=hljs-params>()</span> </span>{
    <span class=hljs-keyword>return</span> name;
  }

  <span class=hljs-function><span class=hljs-keyword>public</span> String <span class=hljs-title>getOrigin</span><span class=hljs-params>()</span> </span>{
    <span class=hljs-keyword>return</span> origin;
  }

  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>int</span> <span class=hljs-title>getId</span><span class=hljs-params>()</span> </span>{
    <span class=hljs-keyword>return</span> id;
  }

  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>setName</span><span class=hljs-params>(String name)</span> </span>{
    <span class=hljs-keyword>this</span>.name = name;
  }

  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>setOrigin</span><span class=hljs-params>(String origin)</span> </span>{
    <span class=hljs-keyword>this</span>.origin = origin;
  }
}</code></pre><p>It’s a very simple <em>bean</em> class (so with getters and setters). We choose this format because Vert.x is relying on <a href=http://wiki.fasterxml.com/JacksonHome>Jackson</a> to handle the JSON format. Jackson automates the serialization and deserialization of <em>bean</em> classes, making our code much simpler.</p><p>Now, let’s create a couple of bottles. In the <code>MyFirstVerticle</code> class, add the following code:</p><pre><code class="hljs java"><span class=hljs-comment>// Store our product</span>
<span class=hljs-keyword>private</span> Map&lt;Integer, Whisky&gt; products = <span class=hljs-keyword>new</span> LinkedHashMap&lt;&gt;();
<span class=hljs-comment>// Create some product</span>
<span class=hljs-function><span class=hljs-keyword>private</span> <span class=hljs-keyword>void</span> <span class=hljs-title>createSomeData</span><span class=hljs-params>()</span> </span>{
  Whisky bowmore = <span class=hljs-keyword>new</span> Whisky(<span class=hljs-string>"Bowmore 15 Years Laimrig"</span>, <span class=hljs-string>"Scotland, Islay"</span>);
  products.put(bowmore.getId(), bowmore);
  Whisky talisker = <span class=hljs-keyword>new</span> Whisky(<span class=hljs-string>"Talisker 57° North"</span>, <span class=hljs-string>"Scotland, Island"</span>);
  products.put(talisker.getId(), talisker);
}</code></pre><p>Then, in the <code>start</code> method, call the <code>createSomeData</code> method:</p><pre><code class="hljs java"><span class=hljs-annotation>@Override</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>(Future&lt;Void&gt; fut)</span> </span>{

  createSomeData();

  <span class=hljs-comment>// Create a router object.</span>
  Router router = Router.router(vertx);

  <span class=hljs-comment>// Rest of the method</span>
}</code></pre><p>As you have noticed, we don’t really have a <em>backend</em> here, it’s just a (in-memory) map. Adding a backend will be covered by another post.</p><h3 id=get-our-products>Get our products</h3><p>Enough decoration, let’s implement the REST API. We are going to start with <code>GET /api/whiskies</code>. It returns the list of bottles in a JSON Array.</p><p>In the <code>start</code> method, add this line just below the static handler line:</p><pre><code class="hljs java">router.get(<span class=hljs-string>"/api/whiskies"</span>).handler(<span class=hljs-keyword>this</span>::getAll);</code></pre><p>This line instructs the <code>router</code> to handle the <code>GET</code> requests on “/api/whiskies” by calling the <code>getAll</code> method. We could have inlined the handler code, but for clarity reasons let’s create another method:</p><pre><code class="hljs java"><span class=hljs-function><span class=hljs-keyword>private</span> <span class=hljs-keyword>void</span> <span class=hljs-title>getAll</span><span class=hljs-params>(RoutingContext routingContext)</span> </span>{
  routingContext.response()
      .putHeader(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"application/json; charset=utf-8"</span>)
      .end(Json.encodePrettily(products.values()));
}</code></pre><p>As every <em>handler</em> our method receives a <code>RoutingContext</code>. It populates the <code>response</code> by setting the <code>content-type</code> and the actual content. Because our content may contain <em>weird</em> characters, we force the charset to UTF-8. To create the actual content, no need to compute the JSON string ourself. Vert.x lets us use the <code>Json</code> API. So <code>Json.encodePrettily(products.values())</code> computes the JSON string representing the set of bottles.</p><p>We could have used <code>Json.encodePrettily(products)</code>, but to make the JavaScript code simpler, we just return the set of bottles and not an object containing <code>ID =&gt; Bottle</code> entries.</p><p>With this in place, we should be able to retrieve the set of bottle from our HTML page. Let’s try it:</p><pre><code class=hljs>mvn clean package
java -jar target/<span class=hljs-keyword>my</span>-<span class=hljs-keyword>first</span>-app-<span class=hljs-number>1.0</span>-SNAPSHOT-fat.jar</code></pre><p>Then open the HTML page in your browser (<code>http://localhost:8080/assets/index.html</code>), and should should see:</p><p><img src=/assets/blog/intro-series/post-3-My_Whisky_Collection.png alt="Alt text"></p><p>I’m sure you are curious, and want to actually see what is returned by our REST API. Let’s open a browser to <code>http://localhost:8080/api/whiskies</code>. You should get:</p><pre><code class=hljs>[ {
  "<span class=hljs-attribute>id</span>" : <span class=hljs-value><span class=hljs-number>0</span></span>,
  "<span class=hljs-attribute>name</span>" : <span class=hljs-value><span class=hljs-string>"Bowmore 15 Years Laimrig"</span></span>,
  "<span class=hljs-attribute>origin</span>" : <span class=hljs-value><span class=hljs-string>"Scotland, Islay"</span>
</span>}, {
  "<span class=hljs-attribute>id</span>" : <span class=hljs-value><span class=hljs-number>1</span></span>,
  "<span class=hljs-attribute>name</span>" : <span class=hljs-value><span class=hljs-string>"Talisker 57° North"</span></span>,
  "<span class=hljs-attribute>origin</span>" : <span class=hljs-value><span class=hljs-string>"Scotland, Island"</span>
</span>} ]</code></pre><h2 id=create-a-product>Create a product</h2><p>Now we can retrieve the set of bottles, let’s create a new one. Unlike the previous REST API endpoint, this one need to read the request’s body. For performance reason, it should be explicitly enabled. Don’t be scared… it’s just a handler.</p><p>In the <code>start</code> method, add these lines just below the line ending by <code>getAll</code>:</p><pre><code class="hljs java">router.route(<span class=hljs-string>"/api/whiskies*"</span>).handler(BodyHandler.create());
router.post(<span class=hljs-string>"/api/whiskies"</span>).handler(<span class=hljs-keyword>this</span>::addOne);</code></pre><p>The first line enables the reading of the request body for all routes under “/api/whiskies”. We could have enabled it globally with <code>router.route().handler(BodyHandler.create())</code>.</p><p>The second line maps <code>POST</code> requests on <code>/api/whiskies</code> to the <code>addOne</code> method. Let’s create this method:</p><pre><code class="hljs java"><span class=hljs-function><span class=hljs-keyword>private</span> <span class=hljs-keyword>void</span> <span class=hljs-title>addOne</span><span class=hljs-params>(RoutingContext routingContext)</span> </span>{
  <span class=hljs-keyword>final</span> Whisky whisky = Json.decodeValue(routingContext.getBodyAsString(),
      Whisky.class);
  products.put(whisky.getId(), whisky);
  routingContext.response()
      .setStatusCode(<span class=hljs-number>201</span>)
      .putHeader(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"application/json; charset=utf-8"</span>)
      .end(Json.encodePrettily(whisky));
}</code></pre><p>The method starts by retrieving the <code>Whisky</code> object from the request body. It just reads the body into a String and passes it to the <code>Json.decodeValue</code> method. Once created it adds it to the <em>backend</em> map and returns the created bottle as JSON.</p><p>Let’s try this. Rebuild and restart the application with:</p><pre><code class=hljs>mvn clean package
java -jar target/<span class=hljs-keyword>my</span>-<span class=hljs-keyword>first</span>-app-<span class=hljs-number>1.0</span>-SNAPSHOT-fat.jar</code></pre><p>Then, refresh the HTML page and click on the <code>Add a new bottle</code> button. Enter the data such as: “Jameson” as name and “Ireland” as origin (purists would have noticed that this is actually a Whiskey and not a Whisky). The bottle should be added to the table.</p><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=title>Status 201 ?</span><br><span class=content>As you can see, we have set the response status to <code>201</code>. It means <code>CREATED</code>, and is the generally used in REST API that create an entity. By default vert.x web is setting the status to <code>200</code> meaning <code>OK</code>.</span></td></tr></tbody></table></div></p><h3 id=finishing-a-bottle>Finishing a bottle</h3><p>Well, bottles do not last forever, so we should be able to delete a bottle. In the <code>start</code> method, add this line:</p><pre><code class="hljs java">router.delete(<span class=hljs-string>"/api/whiskies/:id"</span>).handler(<span class=hljs-keyword>this</span>::deleteOne);</code></pre><p>In the URL, we define a <em>path parameter</em> <code>:id</code>. So, when handling a matching request, Vert.x extracts the path segment corresponding to the parameter and let us access it in the handler method. For instance, <code>/api/whiskies/0</code> maps <code>id</code> to <code>0</code>.</p><p>Let’s see how the parameter can be used in the handler method. Create the <code>deleteOne</code> method as follows:</p><pre><code class="hljs java"><span class=hljs-function><span class=hljs-keyword>private</span> <span class=hljs-keyword>void</span> <span class=hljs-title>deleteOne</span><span class=hljs-params>(RoutingContext routingContext)</span> </span>{
  String id = routingContext.request().getParam(<span class=hljs-string>"id"</span>);
  <span class=hljs-keyword>if</span> (id == <span class=hljs-keyword>null</span>) {
    routingContext.response().setStatusCode(<span class=hljs-number>400</span>);
  } <span class=hljs-keyword>else</span> {
    Integer idAsInteger = Integer.valueOf(id);
    products.remove(idAsInteger);
  }
  routingContext.response().setStatusCode(<span class=hljs-number>204</span>).end();
}</code></pre><p>The <em>path parameter</em> is retrieved using <code>routingContext.request().getParam(&quot;id&quot;)</code>. It checks whether it’s <code>null</code> (not set), and in this case returns a <code>Bad Request</code> response (status code 400). Otherwise, it removes it from the <em>backend</em> map.</p><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=title>Status 204 ?</span><br><span class=content>As you can see, we have set the response status to <code>204 - NO CONTENT</code>. Response to the HTTP Verb <code>delete</code> have generally no content.</span></td></tr></tbody></table></div></p><h3 id=the-other-methods>The other methods</h3><p>We won’t detail <code>getOne</code> and <code>updateOne</code> as the implementations are straightforward and very similar. Their implementations are available on <a href=https://github.com/cescoffier/my-vertx-first-app/blob/post-3/src/main/java/io/vertx/blog/first/MyFirstVerticle.java>Github</a>.</p><h3 id=cheers->Cheers !</h3><p>It’s time to conclude this post. We have seen how Vert.x Web lets you implement a REST API easily and how it can serve static resources. A bit more fancy than before, but still pretty easy.</p><p>Next time, we are going to improve our tests to cover the REST API.</p><p>Say Tuned &amp; Happy Coding !</p></article><hr></article><article class=blog-post><h2 class=blog-post-title><a href=/blog/vert-x-application-configuration/index.html>Vert.x Application Configuration</a></h2><p class=blog-post-meta>20th July 2015 by <a href=http://github.com/cescoffier>cescoffier</a></p><article><h2 id=previously-in-introduction-to-vert-x->Previously in ‘Introduction to Vert.x’</h2><p>In <a href=/blog/my-first-vert-x-3-application/index.html>this post</a>, we developed a very simple Vert.x 3 application, and saw how this application can be tested, packaged and executed. That was nice, isn’t it ? Well, ok, that was only the beginning. In this post, we are going to enhance our application to support <em>external</em> configuration.</p><p>So just to remind you, we have an application starting a HTTP server on the port 8080 and replying a polite “Hello” message to all HTTP requests. The previous code is available <a href=https://github.com/cescoffier/my-vertx-first-app/tree/post-1>here</a>. The code developed in this post is in the <a href=https://github.com/cescoffier/my-vertx-first-app/tree/post-2>post-2 branch</a>.</p><h2 id=so-why-do-we-need-configuration->So, why do we need configuration?</h2><p>That’s a good question. The application works right now, but well, let’s say you want to deploy it on a machine where the port 8080 is already taken. We would need to change the port in the application code and in the test, just for this machine. That would be sad. Fortunately, Vert.x applications are configurable.</p><p>Vert.x configurations are using the JSON format, so don’t expect anything complicated. They can be passed to verticle either from the command line, or using an API. Let’s have a look.</p><h2 id=no-8080-anymore>No ‘8080’ anymore</h2><p>The first step is to modify the <code>io.vertx.blog.first.MyFirstVerticle</code> class to not bind to the port 8080, but to read it from the configuration:</p><pre><code class="hljs java"><span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>(Future&lt;Void&gt; fut)</span> </span>{
  vertx
      .createHttpServer()
      .requestHandler(r -&gt; {
        r.response().end(<span class=hljs-string>"&lt;h1&gt;Hello from my first "</span> +
            <span class=hljs-string>"Vert.x 3 application&lt;/h1&gt;"</span>);
      })
      .listen(
          <span class=hljs-comment>// Retrieve the port from the configuration,</span>
          <span class=hljs-comment>// default to 8080.</span>
          config().getInteger(<span class=hljs-string>"http.port"</span>, <span class=hljs-number>8080</span>),
          result -&gt; {
            <span class=hljs-keyword>if</span> (result.succeeded()) {
              fut.complete();
            } <span class=hljs-keyword>else</span> {
              fut.fail(result.cause());
            }
          }
      );
}</code></pre><p>So, the only difference with the previous version is <code>config().getInteger(&quot;http.port&quot;, 8080)</code>. Here, our code is now requesting the configuration and check whether the <em>http.port</em> property is set. If not, the port 8080 is used as fall-back. The retrieved configuration is a <code>JsonObject</code>.</p><p>As we are using the port 8080 by default, you can still package our application and run it as before:</p><pre><code class=hljs>mvn clean package
java -jar target/<span class=hljs-keyword>my</span>-<span class=hljs-keyword>first</span>-app-<span class=hljs-number>1.0</span>-SNAPSHOT-fat.jar</code></pre><p>Simple right ?</p><h2 id=api-based-configuration-random-port-for-the-tests>API-based configuration - Random port for the tests</h2><p>Now that the application is configurable, let’s try to provide a configuration. In our test, we are going to configure our application to use the port 8081. So, previously we were deploying our verticle with:</p><pre><code class="hljs java">vertx.deployVerticle(MyFirstVerticle.class.getName(), context.asyncAssertSuccess());</code></pre><p>Let’s now pass some <em>deployment options</em>:</p><pre><code class="hljs java">port = <span class=hljs-number>8081</span>;
DeploymentOptions options = <span class=hljs-keyword>new</span> DeploymentOptions()
    .setConfig(<span class=hljs-keyword>new</span> JsonObject().put(<span class=hljs-string>"http.port"</span>, port)
);
vertx.deployVerticle(MyFirstVerticle.class.getName(), options, context.asyncAssertSuccess());</code></pre><p>The <code>DeploymentOptions</code> object lets us customize various parameters. In particular, it lets us inject the <code>JsonObject</code> retrieved by the verticle when using the <code>config()</code> method.</p><p>Obviously, the test connecting to the server needs to be slightly modified to use the right port (<code>port</code> is a field):</p><pre><code class="hljs java">vertx.createHttpClient().getNow(port, <span class=hljs-string>"localhost"</span>, <span class=hljs-string>"/"</span>, response -&gt; {
  response.handler(body -&gt; {
    context.assertTrue(body.toString().contains(<span class=hljs-string>"Hello"</span>));
    async.complete();
  });
});</code></pre><p>Ok, well, this does not really fix our issue. What happens when the port 8081 is used too. Let’s now pick a random port:</p><pre><code class="hljs java">ServerSocket socket = <span class=hljs-keyword>new</span> ServerSocket(<span class=hljs-number>0</span>);
port = socket.getLocalPort();
socket.close();

DeploymentOptions options = <span class=hljs-keyword>new</span> DeploymentOptions()
    .setConfig(<span class=hljs-keyword>new</span> JsonObject().put(<span class=hljs-string>"http.port"</span>, port)
    );

vertx.deployVerticle(MyFirstVerticle.class.getName(), options, context.asyncAssertSuccess());</code></pre><p>So, the idea is very simple. We open a <em>server socket</em> that would pick a random port (that’s why we put 0 as parameter). We retrieve the used port and close the socket. Be aware that this method is <strong>not</strong> perfect and may fail if the picked port becomes used between the <code>close</code> method and the start of our HTTP server. However, it would work fine in the very high majority of the case.</p><p>With this in place, our test is now using a random port. Execute them with:</p><pre><code class=hljs><span class=hljs-title>mvn</span> clean test</code></pre><h2 id=external-configuration-let-s-run-on-another-port>External configuration - Let’s run on another port</h2><p>Ok, well random port is not what we want in <em>production</em>. Could you imagine the face of your production team if you tell them that your application is picking a random port. It can actually be funny, but we should never mess with the production team.</p><p>So for the actual execution of your application, let’s pass the configuration in an external file. The configuration is stored in a <em>json</em> file.</p><p>Create the <code>src/main/conf/my-application-conf.json</code> with the following content:</p><pre><code class="hljs javascript">{
  <span class=hljs-string>"http.port"</span> : <span class=hljs-number>8082</span>
}</code></pre><p>And now, to use this configuration just launch your application with:</p><pre><code class=hljs>java -jar target/<span class=hljs-keyword>my</span>-<span class=hljs-keyword>first</span>-app-<span class=hljs-number>1.0</span>-SNAPSHOT-fat.jar -conf src/main/conf/<span class=hljs-keyword>my</span>-<span class=hljs-type>application</span>-conf.json</code></pre><p>Open a browser on <a href=http://localhost:8082>http://localhost:8082</a>, here it is !</p><p>How does that work ? Remember, our <em>fat jar</em> is using the <code>Starter</code> class (provided by Vert.x) to launch our application. This class is reading the <code>-conf</code> parameter and create the corresponding deployment options when deploying our verticle.</p><h2 id=conclusion>Conclusion</h2><p>After having developed your first Vert.x application, we have seen how this application is configurable, and this without adding any complexity to our application. Next time we are going to see how we can use vertx-web to develop a small application serving static pages and a REST API. A bit more fancy, but still very simple.</p><p>Happy Coding and &amp; Stay Tuned!</p></article><hr></article><article class=blog-post><h2 class=blog-post-title><a href=/blog/my-first-vert-x-3-application/index.html>My first Vert.x 3 Application</a></h2><p class=blog-post-meta>14th July 2015 by <a href=http://github.com/cescoffier>cescoffier</a></p><article><p>Let’s say, you heard someone saying that Vert.x is <em>awesome</em>. Ok great, but you may want to try it by yourself. Well, the next natural question is “where do I start ?”. This post is a good starting point. It shows how is built a very simple vert.x application (nothing fancy), how it is tested and how it is packaged and executed. So, everything you need to know before building your own groundbreaking application.</p><p>The code developed in this post is available on <a href=https://github.com/cescoffier/my-vertx-first-app>github</a>. This post is part of the <em>Introduction to Vert.x series</em>. The code of this post in in the <a href=https://github.com/cescoffier/my-vertx-first-app/tree/post-1>post-1 branch</a>.</p><h2 id=let-s-start->Let’s start !</h2><p>First, let’s create a project. In this post, we use Apache Maven, but you can use Gradle or the build process tool you prefer. You could use the Maven jar archetype to create the structure, but basically, you just need a directory with:</p><ol><li>a <code>src/main/java</code> directory</li><li>a <code>src/main/test</code> directory</li><li>a <code>pom.xml</code> file</li></ol><p>So, you would get something like:</p><pre><code class=hljs>.
├── pom<span class=hljs-class>.xml</span>
├── src
│   ├── main
│   │   └── java
│   └── test
│       └── java</code></pre><p>Let’s create the <code>pom.xml</code> file with the following content:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>project</span> <span class=hljs-attribute>xmlns</span>=<span class=hljs-value>"http://maven.apache.org/POM/4.0.0"</span>
         <span class=hljs-attribute>xmlns:xsi</span>=<span class=hljs-value>"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class=hljs-attribute>xsi:schemaLocation</span>=<span class=hljs-value>"http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>modelVersion</span>&gt;</span>4.0.0<span class=hljs-tag>&lt;/<span class=hljs-title>modelVersion</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>io.vertx.blog<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>my-first-app<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>1.0-SNAPSHOT<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>

  <span class=hljs-tag>&lt;<span class=hljs-title>dependencies</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>dependency</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>io.vertx<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>vertx-core<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>3.0.0<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>dependency</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>dependencies</span>&gt;</span>

  <span class=hljs-tag>&lt;<span class=hljs-title>build</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>plugins</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>plugin</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>maven-compiler-plugin<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>3.3<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>source</span>&gt;</span>1.8<span class=hljs-tag>&lt;/<span class=hljs-title>source</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>target</span>&gt;</span>1.8<span class=hljs-tag>&lt;/<span class=hljs-title>target</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>plugin</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>plugins</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>build</span>&gt;</span>

<span class=hljs-tag>&lt;/<span class=hljs-title>project</span>&gt;</span></code></pre><p>This <code>pom.xml</code> file is pretty straightforward:</p><ul><li>it declares a dependency on <code>vertx-core</code></li><li>it configures the <em>maven-compiler-plugin</em> to use Java 8.</li></ul><p>This second point is important, Vert.x applications require Java 8.</p><h2 id=let-s-code->Let’s code !</h2><p>Ok, now we have made the <code>pom.xml</code> file. Let’s do some real coding… Create the <code>src/main/java/io/vertx/blog/first/MyFirstVerticle.java</code> file with the following content:</p><pre><code class="hljs java"><span class=hljs-keyword>package</span> io.vertx.blog.first;

<span class=hljs-keyword>import</span> io.vertx.core.AbstractVerticle;
<span class=hljs-keyword>import</span> io.vertx.core.Future;

<span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>MyFirstVerticle</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>AbstractVerticle</span> </span>{

  <span class=hljs-annotation>@Override</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>(Future&lt;Void&gt; fut)</span> </span>{
    vertx
        .createHttpServer()
        .requestHandler(r -&gt; {
          r.response().end(<span class=hljs-string>"&lt;h1&gt;Hello from my first "</span> +
              <span class=hljs-string>"Vert.x 3 application&lt;/h1&gt;"</span>);
        })
        .listen(<span class=hljs-number>8080</span>, result -&gt; {
          <span class=hljs-keyword>if</span> (result.succeeded()) {
            fut.complete();
          } <span class=hljs-keyword>else</span> {
            fut.fail(result.cause());
          }
        });
  }
}</code></pre><p>This is actually our not fancy application. The class extends <code>AbstractVerticle</code>. In the Vert.x world, a <em>verticle</em> is a component. By extending <code>AbstractVerticle</code>, our class gets access to the <code>vertx</code> field.</p><p>The <code>start</code> method is called when the verticle is deployed. We could also implement a <code>stop</code> method, but in this case Vert.x takes care of the garbage for us. The <code>start</code> method receives a <code>Future</code> object that will let us inform Vert.x when our start sequence is completed or report an error. One of the particularity of Vert.x is its asynchronous / non-blocking aspect. When our verticle is going to be deployed it won’t wait until the start method has been completed. So, the <code>Future</code> parameter is important to notify of the completion.</p><p>The <code>start</code> method creates a HTTP server and attaches a request handler to it. The request handler is a lambda, passed in the <code>requestHandler</code> method, called every time the server receives a request. Here, we just reply <code>Hello ...</code> (nothing fancy I told you). Finally, the server is bound to the 8080 port. As this may fails (because the port may already be used), we pass another lambda expression checking whether or not the connection has succeeded. As mentioned above it calls either <code>fut.complete</code> in case of success or <code>fut.fail</code> to report an error.</p><p>Let’s try to compile the application using:</p><pre><code class=hljs>mvn clean <span class=hljs-keyword>compile</span></code></pre><p>Fortunately, it should succeed.</p><p>That’s all for the application.</p><h2 id=let-s-test>Let’s test</h2><p>Well, that’s good to have developed an application, but we can never be too careful, so let’s test it. The test uses JUnit and <a href="http://vertx.io/docs/vertx-unit/java/">vertx-unit</a> - a framework delivered with vert.x to make the testing of vert.x application more natural.</p><p>Open the <code>pom.xml</code> file to add the two following dependencies:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>dependency</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>junit<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>junit<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>4.12<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>scope</span>&gt;</span>test<span class=hljs-tag>&lt;/<span class=hljs-title>scope</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>dependency</span>&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>dependency</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>io.vertx<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>vertx-unit<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>3.0.0<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>scope</span>&gt;</span>test<span class=hljs-tag>&lt;/<span class=hljs-title>scope</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>dependency</span>&gt;</span></code></pre><p>Now create the <code>src/test/java/io/vertx/blog/first/MyFirstVerticleTest.java</code> with the following content:</p><pre><code class="hljs java"><span class=hljs-keyword>package</span> io.vertx.blog.first;

<span class=hljs-keyword>import</span> io.vertx.core.Vertx;
<span class=hljs-keyword>import</span> io.vertx.ext.unit.Async;
<span class=hljs-keyword>import</span> io.vertx.ext.unit.TestContext;
<span class=hljs-keyword>import</span> io.vertx.ext.unit.junit.VertxUnitRunner;
<span class=hljs-keyword>import</span> org.junit.After;
<span class=hljs-keyword>import</span> org.junit.Before;
<span class=hljs-keyword>import</span> org.junit.Test;
<span class=hljs-keyword>import</span> org.junit.runner.RunWith;

<span class=hljs-annotation>@RunWith</span>(VertxUnitRunner.class)
<span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>MyFirstVerticleTest</span> </span>{

  <span class=hljs-keyword>private</span> Vertx vertx;

  <span class=hljs-annotation>@Before</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>setUp</span><span class=hljs-params>(TestContext context)</span> </span>{
    vertx = Vertx.vertx();
    vertx.deployVerticle(MyFirstVerticle.class.getName(),
        context.asyncAssertSuccess());
  }

  <span class=hljs-annotation>@After</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>tearDown</span><span class=hljs-params>(TestContext context)</span> </span>{
    vertx.close(context.asyncAssertSuccess());
  }

  <span class=hljs-annotation>@Test</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>testMyApplication</span><span class=hljs-params>(TestContext context)</span> </span>{
    <span class=hljs-keyword>final</span> Async async = context.async();

    vertx.createHttpClient().getNow(<span class=hljs-number>8080</span>, <span class=hljs-string>"localhost"</span>, <span class=hljs-string>"/"</span>,
     response -&gt; {
      response.handler(body -&gt; {
        context.assertTrue(body.toString().contains(<span class=hljs-string>"Hello"</span>));
        async.complete();
      });
    });
  }
}</code></pre><p>This is a JUnit test for our verticle. The test uses vertx-unit, so we use a custom runner. vert.x-unit makes easy to test asynchronous interactions, which are the basis of vert.x applications.</p><p>In the <code>setUp</code> method, we creates an instance of <code>Vertx</code> and deploy our verticle. You may have noticed that unlike the traditional JUnit <code>@Before</code> method, it receives a <code>TestContext</code>. This object lets us control the asynchronous aspect of our test. For instance, when we deploy our verticle, it starts asynchronously, as most Vert.x interactions. We cannot check anything until it gets started correctly. So, as second argument of the <code>deployVerticle</code> method, we pass a result handler: <code>context.asyncAssertSuccess()</code>. It fails the test if the verticle does not start correctly. In addition it waits until the verticle has completed its start sequence. Remember, in our verticle, we call <code>fut.complete()</code>. So it waits until this method is called, and in the case of a failures, fails the test.</p><p>Well, the <code>tearDown</code> method is straightforward, and just terminates the <code>vertx</code> instance we created.</p><p>Let’s now have a look to the test of our application: the <code>testMyApplication</code> method. The test emits a request to our application and checks the result. Emitting the request and receiving the response is asynchronous. So we need a way to control this. As the <code>setUp</code> and <code>tearDown</code> methods, the test method receives a <code>TestContext</code>. From this object we creates an <em>async handle</em> (<code>async</code>) that lets us notify the test framework when the test has completed (using <code>async.complete()</code>).</p><p>So, once the <em>async handle</em> is created, we create a HTTP client and emits a HTTP request handled by our application with the <code>getNow()</code> method (<code>getNow</code> is just a shortcut for <code>get(...).end()</code>). The response is handled by a lambda. In this lambda we retrieves the response body by passing another lambda to the <code>handler</code> method. The <code>body</code> argument is the response body (as a <code>buffer</code> object). We check that the body contains the <code>&quot;Hello&quot;</code> String and declare the test complete.</p><p>Let’s take a minute to mention the <em>assertions</em>. Unlike in traditional JUnit tests, it uses <code>context.assert...</code>. Indeed, if the assertion fails, it will interrupt the test immediately. So it’s pretty important to always uses these assertion methods because of the asynchronous aspect of the Vert.x application and so tests.</p><p>Our test can be run from an IDE, or using Maven:</p><pre><code class=hljs><span class=hljs-title>mvn</span> clean test</code></pre><h2 id=packaging>Packaging</h2><p>So, let’s sum up. We have an application and a test. Well, let’s now package the application. In this post we package the application in a <em>fat jar</em>. A <em>fat jar</em> is a standalone executable Jar file containing all the dependencies required to run the application. This is a very convenient way to package Vert.x applications as it’s only one file. It also make them easy to execute.</p><p>To create a <em>fat jar</em>, edit the <code>pom.xml</code> file and add the following snippet just before <code>&lt;/plugins&gt;</code>:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>plugin</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>org.apache.maven.plugins<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>maven-shade-plugin<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>2.3<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>executions</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>phase</span>&gt;</span>package<span class=hljs-tag>&lt;/<span class=hljs-title>phase</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>shade<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>transformers</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>transformer</span>
            <span class=hljs-attribute>implementation</span>=<span class=hljs-value>"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>manifestEntries</span>&gt;</span>
              <span class=hljs-tag>&lt;<span class=hljs-title>Main-Class</span>&gt;</span>io.vertx.core.Starter<span class=hljs-tag>&lt;/<span class=hljs-title>Main-Class</span>&gt;</span>
              <span class=hljs-tag>&lt;<span class=hljs-title>Main-Verticle</span>&gt;</span>io.vertx.blog.first.MyFirstVerticle<span class=hljs-tag>&lt;/<span class=hljs-title>Main-Verticle</span>&gt;</span>
            <span class=hljs-tag>&lt;/<span class=hljs-title>manifestEntries</span>&gt;</span>
          <span class=hljs-tag>&lt;/<span class=hljs-title>transformer</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>transformers</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>artifactSet</span>/&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>outputFile</span>&gt;</span>${project.build.directory}/${project.artifactId}-${project.version}-fat.jar<span class=hljs-tag>&lt;/<span class=hljs-title>outputFile</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>executions</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>plugin</span>&gt;</span></code></pre><p>It uses the <a href="https://maven.apache.org/plugins/maven-shade-plugin/">maven-shade-plugin</a> to create the <code>fat jar</code>. In the <code>manifestEntries</code> it indicates the name of our verticle. You may wonder from where comes the <code>Starter</code> class. It’s actually a class from vert.x, that is going to create the <code>vertx</code> instance and deploy our verticle.</p><p>So, with this plugin configured, let’s launch:</p><pre><code class=hljs>mvn clean <span class=hljs-package><span class=hljs-keyword>package</span></span></code></pre><p>This is going to create <code>target/my-first-app-1.0-SNAPSHOT-fat.jar</code> embedding our application along with all the dependencies (including vert.x itself).</p><h2 id=executing-our-application>Executing our application</h2><p>Well, it’s nice to have a <em>fat jar</em>, but we want to see our application running! As said above, thanks to the <em>fat jar</em> packaging, running Vert.x application is easy as:</p><pre><code class=hljs>java -jar target/<span class=hljs-keyword>my</span>-<span class=hljs-keyword>first</span>-app-<span class=hljs-number>1.0</span>-SNAPSHOT-fat.jar</code></pre><p>Then, open a browser to <a href=http://localhost:8080>http://localhost:8080</a>.</p><p>To stop the application, hit <code>CTRL+C</code>.</p><h2 id=conclusion>Conclusion</h2><p>This Vert.x 3 crash class has presented how you can develop a simple application using Vert.x 3, how to test it, package it and run it. So, you now know everything you need to build amazing system on top of Vert.x 3. Next time we will see how to configure our application.</p><p>Happy coding &amp; Stay tuned !</p></article><hr></article><article class=blog-post><h2 class=blog-post-title><a href=/blog/vert-x3-says-hello-to-npm-users/index.html>Vert.x3 says &quot;hello&quot; to NPM users</a></h2><p class=blog-post-meta>13th July 2015 by <a href=http://github.com/pmlopes>pmlopes</a></p><article><p>In programming literature it has become the standard to create a hello world program as the first example. In this<br>article I’ll be demonstrating how <code>NPM</code> users can quickly get started with <code>vert.x</code>. You will see that it is not<br>that different and in fact it can be done using the tools you’re used to. Note that although we are using <code>NPM</code> we are<br>not relying on <code>node.js</code>, all <code>javascript</code> code runs on the <code>JVM</code>.</p><h2 id=hello-world-examples>Hello World Examples</h2><p>Here are four simple hello world examples. The comments in the code explain how the code works and the text around it<br>explain what it does and how to test it.</p><h2 id=hello-console>Hello Console</h2><p>This example is about as plain as it can get. It prints the words “<code>Hello World</code>“ to the terminal. If you’re a<br>javascript developer you should be already used to <code>npm</code> and know that you always start a project with the file<br><code>package.json</code>:</p><pre><code class="hljs javascript">{
  <span class=hljs-string>"name"</span>: <span class=hljs-string>"vertx3-hello-console"</span>,
  <span class=hljs-string>"private"</span>: <span class=hljs-literal>true</span>,
  <span class=hljs-string>"dependencies"</span>: {
    <span class=hljs-string>"vertx3-min"</span>: <span class=hljs-string>"3.0.0-1"</span>
  },
  <span class=hljs-string>"scripts"</span>: {
    <span class=hljs-string>"start"</span>: <span class=hljs-string>"./node_modules/.bin/vertx run server.js"</span>
  }
}</code></pre><p>Note that we have a dependency wich is obvious <code>vert.x</code> now note that there are 3 flavours of this dependency:</p><ul><li><a href=https://www.npmjs.com/package/vertx3-min>min</a></li><li><a href=https://www.npmjs.com/package/vertx3-base>base</a></li><li><a href=https://www.npmjs.com/package/vertx3-full>full</a></li></ul><p>According to your needs you can pick a different flavour, since for a simple hello world we only need the minimal that<br>is the one we add to the dependency property.</p><p>Now we need to do a simple hello app, we will call this file “<code>server.js</code>“:</p><pre><code class="hljs javascript"><span class=hljs-comment>// Call the console.log function.</span>
<span class=hljs-built_in>console</span>.log(<span class=hljs-string>"Hello World"</span>);</code></pre><p>You can run this by executing:</p><pre><code class=hljs><span class=hljs-built_in>npm</span> install
<span class=hljs-built_in>npm</span> start</code></pre><p>The first command retrieve the vert.x stack while the seconds starts your program.</p><h2 id=hello-http>Hello HTTP</h2><p>I’d guess that while it’s not the only use case for <code>vert.x</code>, most people are using it as a web application platform. So<br>the next example will be a simple HTTP server that responds to every request with the plain text message “<code>Hello World</code>“<br><code>server.js</code>:</p><pre><code class=hljs><span class=hljs-tag>vertx</span><span class=hljs-class>.createHttpServer</span>()
  <span class=hljs-class>.requestHandler</span>(function (req) {
    <span class=hljs-attribute>req</span>.<span class=hljs-function>response</span>()
      .<span class=hljs-function>putHeader</span>(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"text/plain"</span>)
      .<span class=hljs-function>end</span>(<span class=hljs-string>"Hello World!"</span>);
})<span class=hljs-class>.listen</span>(<span class=hljs-number>8080</span>);</code></pre><p>Now you can reuse the same <code>package.json</code> we’ve just defined in the previous section and start the server with<br><code>npm start</code>. Once the server starts you can open a browser to <code>http://localhost:8080</code> and enjoy the message.</p><h2 id=hello-tcp>Hello TCP</h2><p><code>Vert.x</code> also makes an excellent TCP server, and here is an example that responds to all TCP connections with the<br>message “Hello World” and then closes the connection <code>server.js</code>:</p><pre><code class=hljs>var server = vertx.createNetServer();
server.connectHandler(function (<span class=hljs-keyword>socket</span>) {
  <span class=hljs-keyword>socket</span>.<span class=hljs-keyword>write</span>(<span class=hljs-string>"Hello World!\n"</span>);
  <span class=hljs-keyword>socket</span>.<span class=hljs-keyword>close</span>();
});

server.<span class=hljs-keyword>listen</span>(<span class=hljs-number>7000</span>, <span class=hljs-string>"localhost"</span>);</code></pre><p>Again reuse the previous <code>package.json</code> and test it by doing <code>telnet localhost 7000</code>.</p><h2 id=hello-web>Hello Web</h2><p>Often you won’t be using <code>vert.x</code> built-in libraries because they are designed to be very low level. This makes <code>vert.x</code><br>quick, nimble, and easy to maintain, but if you are planning to build a complex application you want some productivity<br>and rely on a simple web framework. For this specific case there is <code>vert.x web</code>,<br><a href=http://vertx.io/docs/#web>a simple, yet productive framework</a>, to build fast web application with routing, template<br>rendering, lots of middleware etc…usually not enough to get started on a real world application. This example shows an<br>HTTP server that responds with “Hello World” to all requests to “/“ and responds with a 404 error to everything else<br><code>server.js</code>:</p><pre><code class=hljs><span class=hljs-keyword>var</span> Router = require(<span class=hljs-string>"vertx-web-js/router"</span>);
<span class=hljs-keyword>var</span> server = vertx.createHttpServer();

<span class=hljs-keyword>var</span> router = Router.router(vertx);

router.<span class=hljs-keyword>get</span>(<span class=hljs-string>"/"</span>).handler(<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-params>(ctx)</span> </span>{
  <span class=hljs-comment>// This handler will be called for "/" requests</span>
  <span class=hljs-keyword>var</span> response = ctx.response();
  response.putHeader(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"text/plain"</span>);

  <span class=hljs-comment>// Write to the response and end it</span>
  response.end(<span class=hljs-string>"Hello World!"</span>);
});

server.requestHandler(router.accept).listen(<span class=hljs-number>8080</span>);</code></pre><p>In order to test this, you will need to install the <code>vertx3-full</code> stack. There are two ways to do this. You can either<br>install it globally <code>npm install -g vertx3-full</code> or add it as a dependency to our <code>package.json</code> as we have done before,<br>for example <code>package.json</code>:</p><pre><code class="hljs javascript">{
  <span class=hljs-string>"name"</span>: <span class=hljs-string>"vertx3-hello-web"</span>,
  <span class=hljs-string>"private"</span>: <span class=hljs-literal>true</span>,
  <span class=hljs-string>"dependencies"</span>: {
    <span class=hljs-string>"vertx3-full"</span>: <span class=hljs-string>"3.0.0-1"</span>
  },
  <span class=hljs-string>"scripts"</span>: {
    <span class=hljs-string>"start"</span>: <span class=hljs-string>"./node_modules/.bin/vertx run server.js"</span>
  }
}</code></pre><p>That’s it for now, Hopefully this will help you get started working with <code>vert.x</code>!</p></article><hr></article><article class=blog-post><h2 class=blog-post-title><a href=/blog/checklist-for-migrating-from-vert-x-2-1-x-to-vert-x-3-part-one/index.html>Checklist for Migrating from Vert.x 2.1.x to Vert.x 3 - Part One</a></h2><p class=blog-post-meta>6th July 2015 by <a href=http://github.com/bytor99999>bytor99999</a></p><article><p>This blog post presents feedbacks from a project migration using Vert.x 2 to Vert.x 3.</p><h2 id=we-are-in-the-process-of-converting-our-vert-x-2-1-5-application-to-vert-x-3-0->We are in the process of converting our Vert.x 2.1.5 application to Vert.x 3.0.</h2><p>So while upgrading our application, I thought I should note down all the changes that we had to do in the process. Since Vert.x 3 is a major upgrade from the previous version, with so many changes.</p><p>It requires re-thinking your current 2.x Vert.x application. There are new classes, new apis, and a new package structure that has greatly simplified things that we used to have to work around. Therefore in our upgrade it required us to refactor and remove any unnecessary <em>“hacks”</em> that weren’t available in 2 that are now a part of Vert.x 3 that you really want and need to take advantage of. (I don’t mean there are hacks in 3.x, just that we had in our application with Vert.x 2.x)</p><p>There are <em>Metrics</em>, and <em>Clustered shared data</em>, with locking and many more features that are amazing new additions. These are things we had to hack into our application with Vert.x 2.x. We added our own <code>MetricsRegistry</code> from <a href="https://dropwizard.github.io/metrics/3.1.0/getting-started/">DropWizard</a> which meant making our own <code>Main</code> class that called Vert.x’s <code>Starter</code> class after starting up the registry, but only in our <em>Devops</em> server deploys, not our developer machines. And we had to build our own distributed locked of clustered data that also required writing a comprehensive distributed timers. (The timers got fixed with a better actor model). But now we can use what Vert.x gives us internally for those use cases.</p><p>This blog post is part one, as I am sure there will be some new changes that we need to do that we haven’t gotten to yet. Which as we go, will post in part two. Also that this post is a work in progress in that whenever you are upgrading and refactoring your code, it doesn’t leave much time for taking detailed notes, or writing beautiful prose. I am a terrible writer even when I can fully concentrate on it. So the first draft will just be a list of my notes. These notes are not in any particular order, but some things like tests you might want to save for last. (Just DON’T delete your tests, tests are very important)</p><p>One of the first things that Vert.x has changed is the whole <em>classloader</em> setup. Read the Vert.x Docs for more information but basically, we have a flat <em>classloader</em> system now. YAY! And one of the first things I noticed that is gone is the <code>Platform</code> module.</p><h2 id=changes-we-have-made->Changes we have made.</h2><h3 id=dependency-changes>Dependency changes</h3><ol><li><p>So the first thing we did was to remove the <code>vert.x-platform</code> dependency from our <code>pom</code> file (Build dependency file of whatever build system you use) This also means that you will be removing any import statements from your code that has <code>.platform</code>. Which leads us to the next point.</p></li><li><p>Change all the imports for Vertx. from <code>org.vertx</code> to <code>io.vertx</code>. This could be a lot of work, as it is in every class you use Vert.x in. We had at least 250 locations to change here. Some classes have moved packages and “jars” that have them, so there will be some new jars to include as dependencies and different import statements for them.</p></li><li><p>If using a language other than Java, change the dependency to <code>vertx-lang-&lt;&lt;language&gt;&gt;</code></p></li><li><p>Remove any modules references that are using Vert.x 2.x stuff. You can get an odd error like<br><em>The type org.vertx.java.core.json.JsonObject cannot be resolved. It is indirectly referenced from required .class files</em>.</p></li><li><p><code>testtools</code> dependency is gone. There is now Vertx-unit. So all your previous tests need to be completely re-written in the new style. This can be really difficult and time consuming as the tests you already have written really do need to be re-written from scratch. But these tests are also the backbone in knowing if your code is working. So this could take months if you have a really full set of test suites already. Also note the list below is to convert your JUnit Integration tests. as vertx-unit first and foremost provides its own testing framework/suite but it also works in JUnit, and if you are using JUnit you need to do the following</p><ul><li>Remove all the imports to <code>TestTools</code>, including <code>VertxAssert</code>. I would do a find/replace to replace all the <code>VertxAssert</code> to <code>testContext</code> for when you have to add <code>TestContext</code> to all your <code>@Test</code> methods. I recommend naming the parameter <code>testContext</code>, just to put more context, into your context. Because if you just have <code>context</code> as your parameter name, how do you know what context the context is? Sorry, that was too much fun. Basically, what I am saying is if you have say <code>Spring ApplicationContext</code> in with your integration tests with Vert.x what does <code>context</code> represent? Spring or Vert.x test context.</li><li>Add <code>@RunWith(VertxUnitRunner.class)</code> above your test class</li><li>Remove any <code>VertxAssert.testComplete()</code> those are gone. It needs <code>TestContext.async().complete()</code>. It is also important to understand what <code>async()</code> means. When to call it, when to complete it. It also allows you to do multiple <code>async()</code> calls and nested ones. I think I needed that when I had a test that was a longer use case of many messages being sent, but only after responses to other ones occurred. For instance, to do chat in our app, you have to connect, subscribe, friend someone, then you can send a chat message. So that is 4 total Vert.x Messages sent from the Test client. And you can subscribe until connect completed, and you can send or receive messages unless you are subscribed and have a friend. So we need to have a few <code>async()</code> calls in that scenario.</li><li>What is in your <code>start</code> method override. Make that an <code>@Before</code>.</li><li>What is in your <code>stop</code> method override. Make that an <code>@After</code>.</li><li>If you have your assertions have custom message <em>strings</em> to log out when they fail, that parameter is now at the end of the <code>assert</code> method call. Yes, this one can be painful.</li></ul></li></ol><h3 id=build-changes>Build Changes</h3><ol><li><p>Remove all <em>vertx maven plugin</em> code to generate modules, instead create <em>fat</em> jars, which requires adding the <em>Shade maven plugin</em> to put all jar files into a big fat jar. The vertx-examples project has <a href=https://github.com/vert-x3/vertx-examples/tree/master/maven-simplest>simplest-maven</a> which has the stuff to create the fat jar. <a href=https://github.com/vert-x3/vertx-examples/tree/master/gradle-simplest>simplest-gradle</a> is the gradle equivalent.</p></li><li><p>If you were running your application with <code>runMod</code> or something like that then you need to create a <em>fat</em> jar, changing the build file as in <a href=https://github.com/vert-x3/vertx-examples/blob/master/maven-simplest/pom.xml>this one</a> and create a Main class like here <a href=https://github.com/vert-x3/vertx-examples/blob/master/maven-simplest/src/main/java/io/vertx/example/HelloWorldEmbedded.java>this one</a>.</p></li></ol><h3 id=class-code-changes>Class/Code Changes</h3><ol><li><p><code>Verticle</code> is now an interface and not a class to extend, so using Groovy as an example you now extend <code>GroovyVerticle</code>. In Java extend <code>AbstractVerticle</code> instead.</p></li><li><p>There is no <code>registerHandler</code> on the eventBus anymore. So everywhere you do that has to change to create/call <code>consumer()</code> and to unregister that handler, you have to have a reference to the <code>MessageConsumer</code> that <code>consumer()</code> call returns and call its <code>unregister</code> method.</p></li><li><p><code>JsonObject.toMap()</code> changed to <code>JsonObject.getMap()</code></p></li><li><p><code>JsonObject</code> also removed all the <code>putXXX</code> methods with just one <code>put</code> method with overloaded versions for different types.</p></li><li><p><code>JsonObjectMessage</code> no longer exists. What replaces depends on what you are doing. Meaning, if it is an <code>async</code> callback to a deploy, you will get a <code>Message</code> instance back that has <code>succeeded()</code> or <code>failed()</code> methods as well as <code>body()</code> to check any results. If it is a <code>Consumer</code>, it is typically a straight forward<br><code>JsonObject</code>. If you are in Groovy it is also a <code>JsonObject</code>, but the <code>body()</code> is a <code>Map</code> which you can use directly now, instead of having to convert from <code>JsonObject</code> to <code>Map</code>.</p></li><li><p>There isn’t a <code>container</code> variable in <code>Verticles</code> anymore for deploying verticles and also a config file. You need to use <code>vertx.getOrCreateContext().config()</code> to get to it. I used that in the SockJS Example code below.</p></li><li><p><code>SharedData</code> no longer has shared sets. It has a <code>Map</code> of <code>SharedData</code>, so an entry in that <code>Map</code> of shared data could be the name of the set as the key, and a <code>Set</code> as the value. It actually gives you more flexibility of what you put into Shared data, so this is actually a big win for us.</p></li><li><p>Getting the <code>writeHandlerID</code> from a Socket type, is now a method call instead of <code>.writeHandlerID</code>, so <code>.writeHandlerID()</code></p></li><li><p><code>SockJSSocket</code> is in <em>vertx-web</em> package now, so include it to get the class.</p></li><li><p>There isn’t a <code>SockJSServer</code> class anymore either. So you will create a <code>WebServer</code>, a <code>Router</code><br>and set SSL (if you are using SSL on the WebServer) then create a <code>SockJSHandler</code> to assign to the router via the <code>route()</code> method and <code>handler()</code> methods in the Router api.<br>Here is an example of our code. Although I haven’t tested it yet. ;)</p></li></ol><pre><code class="hljs groovy"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>MyVerticle</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>GroovyVerticle</span> {</span>
  Router router

  <span class=hljs-annotation>@Override</span>
  <span class=hljs-typename>void</span> start() <span class=hljs-keyword>throws</span> Exception {
     router = Router.router(vertx)
     (Map&lt;String, Object&gt;) sslConfig =
        (Map&lt;String, Object&gt;)vertx.getOrCreateContext()
          .config().get(<span class=hljs-string>'ssl'</span>)

     HttpServer sslHttpServer = vertx.createHttpServer(
<span class=hljs-label>         SSL:</span> <span class=hljs-literal>true</span>,
<span class=hljs-label>         keyStorePath:</span> sslConfig.get(<span class=hljs-string>"keystore"</span>),
<span class=hljs-label>         keyStorePassword:</span> sslConfig.get(<span class=hljs-string>"password"</span>))

     startWebApiServer(sslHttpServer)
  }

  <span class=hljs-keyword>private</span> <span class=hljs-typename>void</span> startWebApiServer(<span class=hljs-keyword>final</span> HttpServer httpServer) {
    <span class=hljs-keyword>def</span> sockHandler = SockJSHandler.create(vertx, [:])
    sockHandler.socketHandler {
      SockJSSocket ws -&gt; sockJSConnectHandler(ws)
    }
    router.route(<span class=hljs-string>"/hdpoker"</span>).handler(sockHandler)
    httpServer.requestHandler(router.&amp;accept)
    httpServer.listen()
  }

}</code></pre><h4 id=more-testing-change>More testing change</h4><p>Testing messages in Integration Tests. To tell the test method that this has async calls put<br><code>Async async = testContext.async()</code> as the first line in the test method. Yes, this is a little redundant from above, but I always forgot to put <code>async()</code> calls in my integration tests and they would pass so quickly, without sending anything out, because it wasn’t waiting anymore</p><h3 id=runtime-changes>Runtime changes</h3><p>If you don’t use Vert.x built-in Logging and need to use slf4j, then remember that you should set a system property called <code>vertx.logger-delegate-factory-class-name</code> with the name of a Java class which implements the interface <code>LoggerFactory</code>. Vert.x provides pre-built implementations for Log4J and SLF4J with the class names <code>io.vertx.core.logging.Log4jLogDelegateFactory</code> and <code>io.vertx.core.logging.SLF4JLogDelegateFactory</code>.</p><h2 id=still-working>Still working</h2><p>Well, that is all I have for you folks so far. We are still not done, as we haven’t gotten our application running with real clients just yet. But we do have all our integration tests from before completely passing<br>so, if something does come up, it should be a small one (KNOCK ON WOOD)</p><p>Please feel free to post on the Vert.x Google Group with any comments or suggestions on what to add to this blog post or for Part Two.</p><p>Thanks</p><p>Mark S</p></article><hr></article><nav class=pagination><a href=http://vertx.io/blog/page-2.html class=pagination__link--older>&lt; Older</a></nav></div><div class="col-sm-4 blog-sidebar"><div class=blog-contribute><h4>Recent Posts</h4><ul><li><a href=/blog/some-rest-with-vert-x/index.html>Some Rest with Vert.x</a></li><li><a href=/blog/vert-x-application-configuration/index.html>Vert.x Application Configuration</a></li><li><a href=/blog/my-first-vert-x-3-application/index.html>My first Vert.x 3 Application</a></li><li><a href=/blog/vert-x3-says-hello-to-npm-users/index.html>Vert.x3 says &quot;hello&quot; to NPM users</a></li><li><a href=/blog/checklist-for-migrating-from-vert-x-2-1-x-to-vert-x-3-part-one/index.html>Checklist for Migrating from Vert.x 2.1.x to Vert.x 3 - Part One</a></li><li><a href=/blog/vert-x3-and-postgresql-json-type/index.html>Vert.x3 and PostgreSQL JSON type</a></li></ul><hr><p>Have something interesting to say about Vert.x? Want to contribute to this blog? Just check the <a href=https://github.com/vert-x3/vertx-web-site/blob/web-site-3.0.0/BLOG.md>instructions</a>.</p><p></p></div></div></div></div><footer><div class=container><div class=row><div class="col-xs-6 col-sm-3 col-md-3 col-lg-2"><h2>Vert.x</h2><ul class=list-unstyled><li><a href="http://vertx.io/">Home</a></li><li><a href=https://bintray.com/vertx/downloads/distribution/view>Download</a></li><li><a href="http://vertx.io/docs/">Documentation</a></li><li><a href=https://github.com/vert-x3/wiki/wiki>Wiki</a></li><li><a href="http://vertx.io/vertx2/" class=vertx-2-link>Vert.x 2</a></li></ul></div><div class="col-xs-6 col-sm-3 col-md-3 col-lg-2"><h2>Community</h2><ul class=list-unstyled><li><a href="http://vertx.io/community/">Help &amp; Contributors</a></li><li><a href=https://groups.google.com/forum/?fromgroups#!forum/vertx>User Group</a></li><li><a href=https://groups.google.com/forum/?fromgroups#!forum/vertx-dev>Developer Group</a></li></ul></div><div class="col-xs-12 col-sm-6 col-lg-offset-2 col-md-6 copyright"><p>Vert.x is open source and dual licensed under the <a href=https://www.eclipse.org/org/documents/epl-v10.php>Eclipse Public License 1.0</a> and <a href=https://www.apache.org/licenses/LICENSE-2.0.html>Apache License 2.0</a>.</p><p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>Design by <a href=http://www.michel-kraemer.com>Michel Kr&auml;mer</a>. <a href=http://www.entypo.com>Entypo pictograms</a> by Daniel Bruce.</p><div class=row><div class="col-xs-12 col-lg-offset-2 col-md-5"><img class="logo eclipse-logo" src=http://vertx.io/assets/eclipse_logo_grey_small.png width=204 height=48></div><div class="col-xs-12 col-md-offset-2 col-lg-offset-0 col-md-5"><img class="logo cloudbees-logo" src=http://vertx.io/assets/Button-Built-on-CB-1-grey.png width=184 height=48></div></div></div></div></div></footer><script src=http://static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.min.js></script><script src=http://vertx.io/javascripts/bootstrap.min.js></script><script src=http://vertx.io/javascripts/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>