<!DOCTYPE html><html lang=en><head><title>Blog</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta content="width=device-width,initial-scale=1" name=viewport><meta content="Vert.x is a tool-kit for building reactive applications on the JVM." name=description><link href=http://vertx.io/stylesheets/main.css media=screen rel=stylesheet><link href=http://vertx.io/stylesheets/font-awesome.min.css media=screen rel=stylesheet><link href=http://vertx.io/javascripts/styles/rainbow.min.css media=screen rel=stylesheet><!--[if lt IE 9]><script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script><![endif]--><link href=http://vertx.io/assets/favicons/vertx-favicon-5.ico rel="shortcut icon"><link href="http://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel=stylesheet type=text/css><link rel=alternate type=application/rss+xml title=RSS href=http://vertx.io/feed.xml><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('send', 'pageview');</script></head><body><a href="http://www.reactivemanifesto.org/" id=reactive-manifesto-banner><img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000" src=http://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png></a> <a id=skippy class="sr-only sr-only-focusable" href=#content><div class=container><span class=skiplink-text>Skip to main content</span></div></a><header class="navbar navbar-default navbar-static-top" id=top role=banner><div class=container><div class=navbar-header><button class="navbar-toggle collapsed" type=button data-toggle=collapse data-target=#vertx-navbar-collapse><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button> <a href="http://vertx.io/" class=navbar-brand><img alt=Brand src=http://vertx.io/assets/logo-sm.png></a></div><nav class="collapse navbar-collapse" id=vertx-navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=https://bintray.com/vertx/downloads/distribution/3.1.0/view>Download</a></li><li><a href="http://vertx.io/docs/">Documentation</a></li><li><a href=https://github.com/vert-x3/wiki/wiki>Wiki</a></li><li><a href="http://vertx.io/community/">Community</a></li><li><a href="http://vertx.io/blog/">Blog</a></li><li><a href="http://vertx.io/vertx2/" class=vertx-2-link>Vert.x 2</a></li></ul></nav></div></header><div class=container><div class="row blog"><div class="col-sm-8 blog-main"><article class=blog-post><h2 class=blog-post-title><a href="http://vertx.io/blog/vert-x-3-1-0-is-released/">Vert.x 3.1.0 is released !</a></h2><p class=blog-post-meta>8th October 2015 by <a href=http://github.com/purplefox>purplefox</a></p><article><p>I’m pleased to announce the release of Vert.x 3.1!</p><p>Some of the highlights of this release include:</p><ul><li><p><a href="http://vertx.io/docs/vertx-sync/java/">Vertx-sync</a> is a set of utilities that allow you to perform asynchronous operations and receive events in a synchronous way, but without blocking kernel threads.</p></li><li><p><a href="http://vertx.io/docs/vertx-stomp/java/">Vertx-stomp</a> is an implementation of a STOMP server and client. You can use the STOMP server with other clients and use the STOMP client with other servers. The server and the client supports the version 1.0, 1.1 and 1.2 of the STOMP protocol. The STOMP server can also be used as a bridge with the vert.x event bus.</p></li><li><p><a href="http://vertx.io/docs/vertx-shell/java/">Vertx-shell</a> is a command line interface for the Vert.x runtime available from regular terminals using different protocols.</p></li><li><p>Re-implementation of the Starter class and related functionality. And now redeploy is back!</p></li></ul><p>Full release notes can be found here:</p><p><a href=https://github.com/vert-x3/wiki/wiki/3.1-Release-Notes>https://github.com/vert-x3/wiki/wiki/3.1-Release-Notes</a></p><p>Breaking changes here:</p><p><a href=https://github.com/vert-x3/wiki/wiki/3.1.0---Breaking-changes>https://github.com/vert-x3/wiki/wiki/3.1.0---Breaking-changes</a></p><p>NPM for the event-bus client here:</p><p><a href=https://www.npmjs.com/package/vertx3-eventbus-client>https://www.npmjs.com/package/vertx3-eventbus-client</a></p><p>Many thanks to all the committers and community whose contributions made this possible.</p><p>A special thanks to the full-time team - Clement, Julien and Paulo who put in a lot of work to get this out :)</p><p>Next stop is Vert.x 3.2 which we hope to have out before Christmas.</p><p>The artifacts have been deployed to <a href=http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22io.vertx%22%20AND%20v%3A%223.1.0%22>Maven Central</a> and you can get the distribution on <a href=https://bintray.com/vertx/downloads/distribution/3.1.0/view>Bintray</a>.</p></article><hr></article><article class=blog-post><h2 class=blog-post-title><a href="http://vertx.io/blog/contract-driven-rest-services-with-vert-x3/">Contract Driven REST Services with Vert.x3</a></h2><p class=blog-post-meta>17th September 2015 by <a href=http://github.com/pmlopes>pmlopes</a></p><article><p>We see a new trend in development where we are shifting from developing applications to develop APIs. More and more we see services being offered as REST APIs that we are allowed to consume and we already see this trend from the big names in the industry, e.g.: <a href="https://developers.facebook.com/">Facebook</a>, <a href=https://www.mediawiki.org/wiki/API:Main_page>Wikipedia</a>, <a href=https://developer.amazon.com/public/apis>Amazon</a>, <a href=https://dev.twitter.com/overview/documentation>Twitter</a>, <a href="https://developers.google.com/apis-explorer/#p/">Google</a> and <a href=https://www.reddit.com/dev/api>Reddit</a> they all offer APIs.</p><p>Of course making an REST API using Vert.x is quite simple, just use <a href=http://vertx.io/docs/#web>Vert.x Web</a> and you can start writing your API in seconds, however an API without documentation is not an API since no developer will know how to use it. However this is one of the most sensitive issues to tackle in software development, nobody likes to write documentation. However, in the REST age where REST-based web-services are ubiquitous, documentation for public web-services is a necessity. There are a lot of tools out there, two of the most popular are without a doubt:</p><ul><li><a href=http://swagger.io>Swagger</a></li><li><a href=http://raml.org>RAML</a></li></ul><p>Both frameworks have a large ecosystem of tools and tooling around but they tackle the documentation from two different perspectives. While Swagger is purely a documentation tool it tackles the problem from bottom up and RAML does document top down. They both rely on a document (<code>JSON</code> for Swagger, <code>YAML</code> for RAML).</p><p>I’ll now go over building a simple Hello World API, document it and test it. For this example I’ll choose RAML since it feels more natural to the way we code with Vert.x Web.</p><h2 id=define-the-hello-world-api>Define the Hello World API</h2><p>We need a contract and as with any other development we need some specification, You can learn about RAML in its <a href=http://raml.org>website</a> and quickly see how easy it is to get started. So we start with the following specification:</p><h2 id=-pre-code-raml-span-class-hljs-number-0-8-span-><pre><code>#%RAML <span class=hljs-number>0.8</span></code></pre></h2><p><span class=hljs-string>title:</span> Hello world REST API <span class=hljs-string>baseUri:</span> <span class=hljs-string>http:</span><span class=hljs-comment>//localhost:8080/</span> <span class=hljs-string>version:</span> v1</p><p>/<span class=hljs-string>hello:</span> <span class=hljs-label>get:</span> <span class=hljs-label>responses:</span> <span class=hljs-label>200:</span> <span class=hljs-label>body:</span> application/<span class=hljs-string>json:</span> <span class=hljs-label>schema:</span> | { <span class=hljs-string>“$schema”</span>: <span class=hljs-string>“<a href=http://json-schema.org/schema>http://json-schema.org/schema</a>“</span>, <span class=hljs-string>“type”</span>: <span class=hljs-string>“object”</span>, <span class=hljs-string>“description”</span>: <span class=hljs-string>“Hello World Greeting”</span>, <span class=hljs-string>“properties”</span>: { <span class=hljs-string>“greeting”</span>: { <span class=hljs-string>“type”</span>: <span class=hljs-string>“string”</span> } }, <span class=hljs-string>“required”</span>: [ <span class=hljs-string>“greeting”</span> ] }</p><p>So if you didn’t understood why I named RAML as a top down documentation tool, I think it becomes clear now. So there are some basic definition on the top of the file like, <code>title</code>, <code>baseUri</code> and <code>version</code> which should be self explanatory.</p><p>And then we start with the API documentation, so we specify that at the <code>URL</code> <code>/hello</code> using the HTTP verb <code>GET</code> you are expected to get a response with status code <code>200</code> and the body of the response should have content type <code>application/json</code>. This is a very minimal document, one could go over and specify the <a href="http://json-schema.org/"><code>json schema</code></a> for the response, input values, etc…, however lets just keep it simple for this example.</p><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=title>IDE ?</span><br><span class=content>if you do not like to write yaml in your editor you can always use the <a href=http://raml.org/projects.html>API Designer</a> which gives you instant feedback on your API document and provides a testing platform</span></td></tr></tbody></table></div>.</p><h2 id=implement-the-api>Implement the API</h2><p>So you got your contract, time to implement it, this is a very simple API so I’ll jump to the code immediately:</p><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>App</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>AbstractVerticle</span> </span>{
  <span class=hljs-annotation>@Override</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>()</span> </span>{
    Router router = Router.router(vertx);

    router.get(<span class=hljs-string>"/hello"</span>).handler(rc -&gt; {
      rc.response()
          .putHeader(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"application/json"</span>)
          .end(<span class=hljs-keyword>new</span> JsonObject().put(<span class=hljs-string>"greeting"</span>, <span class=hljs-string>"Hello World!"</span>).encode());
    });

    vertx.createHttpServer().requestHandler(router::accept).listen(<span class=hljs-number>8080</span>);
  }
}</code></pre><p>As you can see the code resembles the contract document, when there is a <code>GET</code> request to <code>/hello</code> we send to the client a empty <code>JSON</code> document <code>{}</code>.</p><h2 id=are-we-done->Are we done?</h2><p>The answer is <strong>NO!!!</strong> how can we be sure that our implementation does comply to the contract? We need to test. As I wrote before there is no specific support for Vert.x from RAML or other tools however in this case it is not a problem we can still test our code without having the need to implement a test framework from the ground up.</p><h2 id=testing-our-contract>Testing our contract</h2><p>The initial step is to setup a test, this should be trivial we are using Java (although we could test any of Vert.x supported languages using the same technique). We create a <a href="http://junit.org/">JUnit</a> unit test.</p><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=content>JUnit ? ! For this example I will be using JUnit instead of Vert.x Test mostly to let you know that Vert.x isn’t an opinionated framework, so you are free to choose the tool that best fits you.</span></td></tr></tbody></table></div></p><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>APITest</span> </span>{

  <span class=hljs-annotation>@BeforeClass</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>void</span> <span class=hljs-title>bootApp</span><span class=hljs-params>()</span> </span>{
    Runner.run(App.class);
  }

  <span class=hljs-annotation>@Test</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>testHelloEndpoint</span><span class=hljs-params>()</span> </span>{
  }
}</code></pre><p>So at this moment you have a simple test, I’ll share the code of the runner class (basically it just instantiates a <code>Vertx</code> instance and load the <code>verticle</code> we just implemented above) and has a empty test <code>testHelloEndpoint</code>.</p><h3 id=load-the-api-definition-into-the-test>Load the API definition into the test</h3><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>APITest</span> </span>{

  <span class=hljs-keyword>private</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>final</span> RamlDefinition api = RamlLoaders.fromClasspath()
        .load(<span class=hljs-string>"/api/hello.raml"</span>)
        .assumingBaseUri(<span class=hljs-string>"http://localhost:8080/"</span>);

  <span class=hljs-keyword>private</span> CheckingWebTarget checking;

  ...
}</code></pre><p>So the first step is to load the <code>API</code> definition into our test and have a reference to a <code>CheckingWebTarget</code> object. The checking object is where you can perform assertions, but to do this we need some client make REST calls in order to test.</p><h3 id=create-a-rest-client>Create a REST client</h3><p>There are many options for this, you could use <code>JAX-RS</code>, <code>RestAssured</code>, <code>RestEasy</code>, etc… so I’ll pick <code>RestEasy</code> for now:</p><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>APITest</span> </span>{

  <span class=hljs-keyword>private</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>final</span> RamlDefinition api = RamlLoaders.fromClasspath()
      .load(<span class=hljs-string>"/api/hello.raml"</span>)
      .assumingBaseUri(<span class=hljs-string>"http://localhost:8080/"</span>);

  <span class=hljs-keyword>private</span> ResteasyClient client = <span class=hljs-keyword>new</span> ResteasyClientBuilder().build();
  <span class=hljs-keyword>private</span> CheckingWebTarget checking;

  <span class=hljs-annotation>@BeforeClass</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>void</span> <span class=hljs-title>bootApp</span><span class=hljs-params>()</span> </span>{
    Runner.run(App.class);
  }

  <span class=hljs-annotation>@Before</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>createTarget</span><span class=hljs-params>()</span> </span>{
    checking = api.createWebTarget(client.target(<span class=hljs-string>"http://localhost:8080"</span>));
  }

  ...
}</code></pre><h3 id=implement-the-test>Implement the test</h3><p>All of the boilerplate code is in place and if you look at the previous section you will see that it wasn’t that bad, just a few lines and you loaded the RAML contract, created a REST client and started up your application and all this under ~10 lines of code.</p><p>So lets finish and implement the verification of the contract:</p><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>APITest</span> </span>{
  ...

  <span class=hljs-annotation>@Test</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>testHelloEndpoint</span><span class=hljs-params>()</span> </span>{
    checking.path(<span class=hljs-string>"/hello"</span>).request().get();
    Assert.assertThat(checking.getLastReport(), RamlMatchers.hasNoViolations());
  }
}</code></pre><p>Once you run your tests, you will see:</p><pre><code class=hljs>13:09:28.200 [main] DEBUG o.a.h.i.conn.DefaultClientConnection - Sending request: GET /hello HTTP/1.1
13:09:28.201 [<span class=hljs-link_label>main</span>] DEBUG org.apache.http.wire -  &gt;&gt; "GET /hello HTTP/1.1[<span class=hljs-link_label>\r</span>][<span class=hljs-link_reference>\n</span>]"
13:09:28.202 [<span class=hljs-link_label>main</span>] DEBUG org.apache.http.wire -  &gt;&gt; "Accept-Encoding: gzip, deflate[<span class=hljs-link_label>\r</span>][<span class=hljs-link_reference>\n</span>]"
13:09:28.202 [<span class=hljs-link_label>main</span>] DEBUG org.apache.http.wire -  &gt;&gt; "Host: localhost:8080[<span class=hljs-link_label>\r</span>][<span class=hljs-link_reference>\n</span>]"
13:09:28.202 [<span class=hljs-link_label>main</span>] DEBUG org.apache.http.wire -  &gt;&gt; "Connection: Keep-Alive[<span class=hljs-link_label>\r</span>][<span class=hljs-link_reference>\n</span>]"
13:09:28.202 [<span class=hljs-link_label>main</span>] DEBUG org.apache.http.wire -  &gt;&gt; "[<span class=hljs-link_label>\r</span>][<span class=hljs-link_reference>\n</span>]"
13:09:28.202 [main] DEBUG org.apache.http.headers - &gt;&gt; GET /hello HTTP/1.1
13:09:28.202 [main] DEBUG org.apache.http.headers - &gt;&gt; Accept-Encoding: gzip, deflate
13:09:28.203 [main] DEBUG org.apache.http.headers - &gt;&gt; Host: localhost:8080
13:09:28.203 [main] DEBUG org.apache.http.headers - &gt;&gt; Connection: Keep-Alive
13:09:28.412 [<span class=hljs-link_label>main</span>] DEBUG org.apache.http.wire -  <span class=xml><span class=hljs-tag>&lt;&lt; "<span class=hljs-attribute>HTTP</span>/<span class=hljs-attribute>1.1</span> <span class=hljs-attribute>200</span> <span class=hljs-attribute>OK</span>[\<span class=hljs-attribute>r</span>][\<span class=hljs-attribute>n</span>]"
<span class=hljs-attribute>13:09:28.413</span> [<span class=hljs-attribute>main</span>] <span class=hljs-attribute>DEBUG</span> <span class=hljs-attribute>org.apache.http.wire</span> <span class=hljs-attribute>-</span>  &lt;&lt; "<span class=hljs-attribute>content-type:</span> <span class=hljs-attribute>application</span>/<span class=hljs-attribute>json</span>[\<span class=hljs-attribute>r</span>][\<span class=hljs-attribute>n</span>]"
<span class=hljs-attribute>13:09:28.413</span> [<span class=hljs-attribute>main</span>] <span class=hljs-attribute>DEBUG</span> <span class=hljs-attribute>org.apache.http.wire</span> <span class=hljs-attribute>-</span>  &lt;&lt; "<span class=hljs-attribute>Content-Length:</span> <span class=hljs-attribute>2</span>[\<span class=hljs-attribute>r</span>][\<span class=hljs-attribute>n</span>]"
<span class=hljs-attribute>13:09:28.413</span> [<span class=hljs-attribute>main</span>] <span class=hljs-attribute>DEBUG</span> <span class=hljs-attribute>org.apache.http.wire</span> <span class=hljs-attribute>-</span>  &lt;&lt; "[\<span class=hljs-attribute>r</span>][\<span class=hljs-attribute>n</span>]"
<span class=hljs-attribute>13:09:28.414</span> [<span class=hljs-attribute>main</span>] <span class=hljs-attribute>DEBUG</span> <span class=hljs-attribute>o.a.h.i.conn.DefaultClientConnection</span> <span class=hljs-attribute>-</span> <span class=hljs-attribute>Receiving</span> <span class=hljs-attribute>response:</span> <span class=hljs-attribute>HTTP</span>/<span class=hljs-attribute>1.1</span> <span class=hljs-attribute>200</span> <span class=hljs-attribute>OK</span>
<span class=hljs-attribute>13:09:28.414</span> [<span class=hljs-attribute>main</span>] <span class=hljs-attribute>DEBUG</span> <span class=hljs-attribute>org.apache.http.headers</span> <span class=hljs-attribute>-</span> &lt;&lt; <span class=hljs-attribute>HTTP</span>/<span class=hljs-attribute>1.1</span> <span class=hljs-attribute>200</span> <span class=hljs-attribute>OK</span>
<span class=hljs-attribute>13:09:28.415</span> [<span class=hljs-attribute>main</span>] <span class=hljs-attribute>DEBUG</span> <span class=hljs-attribute>org.apache.http.headers</span> <span class=hljs-attribute>-</span> &lt;&lt; <span class=hljs-attribute>content-type:</span> <span class=hljs-attribute>application</span>/<span class=hljs-attribute>json</span>
<span class=hljs-attribute>13:09:28.415</span> [<span class=hljs-attribute>main</span>] <span class=hljs-attribute>DEBUG</span> <span class=hljs-attribute>org.apache.http.headers</span> <span class=hljs-attribute>-</span> &lt;&lt; <span class=hljs-attribute>Content-Length:</span> <span class=hljs-attribute>2</span>
<span class=hljs-attribute>13:09:28.429</span> [<span class=hljs-attribute>main</span>] <span class=hljs-attribute>DEBUG</span> <span class=hljs-attribute>org.apache.http.wire</span> <span class=hljs-attribute>-</span>  &lt;&lt; "{}"
<span class=hljs-attribute>Tests</span> <span class=hljs-attribute>run:</span> <span class=hljs-attribute>1</span>, <span class=hljs-attribute>Failures:</span> <span class=hljs-attribute>0</span>, <span class=hljs-attribute>Errors:</span> <span class=hljs-attribute>0</span>, <span class=hljs-attribute>Skipped:</span> <span class=hljs-attribute>0</span>, <span class=hljs-attribute>Time</span> <span class=hljs-attribute>elapsed:</span> <span class=hljs-attribute>1.076</span> <span class=hljs-attribute>sec</span>

<span class=hljs-attribute>Results</span> <span class=hljs-attribute>:</span>

<span class=hljs-attribute>Tests</span> <span class=hljs-attribute>run:</span> <span class=hljs-attribute>1</span>, <span class=hljs-attribute>Failures:</span> <span class=hljs-attribute>0</span>, <span class=hljs-attribute>Errors:</span> <span class=hljs-attribute>0</span>, <span class=hljs-attribute>Skipped:</span> <span class=hljs-attribute>0</span></span></span></code></pre><p>And we are done, we now have a API that follow the contract, you can now keep developing your API and implementation and have a test driven approach to be sure that the contract is not broken.</p><h2 id=next-steps>Next steps</h2><p>Until now you have learn how to integrate RAML into Vert.x and CI, however the users of your API will not be able to know much about the API yet since its documentation is not publicly available. So lets publish online the documentation of your API, of course if your API is private you do not need to follow these steps.</p><p>In order to do this all we need it to include in our application the <a href=https://github.com/mulesoft/api-console>RAML console</a>, the fastest way to do this is just download a <a href=https://github.com/mulesoft/api-console/releases>release</a> to <code>src/main/resouces/webroot</code> and in the original application [Vert.x Router] we add a Static Content Handler to serve the console files. Your application source code should look like this:</p><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>App</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>AbstractVerticle</span> </span>{
  <span class=hljs-annotation>@Override</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>()</span> </span>{
    Router router = Router.router(vertx);

    router.get(<span class=hljs-string>"/hello"</span>).handler(rc -&gt; {
      rc.response()
          .putHeader(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"application/json"</span>)
          .end(<span class=hljs-keyword>new</span> JsonObject().put(<span class=hljs-string>"greeting"</span>, <span class=hljs-string>"Hello World!"</span>).encode());
    });

    <span class=hljs-comment>// optionally enable the web console so users can play with your API</span>
    <span class=hljs-comment>// online from their web browsers</span>
    router.route().handler(StaticHandler.create());

    vertx.createHttpServer().requestHandler(router::accept).listen(<span class=hljs-number>8080</span>);
  }
}</code></pre><p>Once you start you application open a browser pointing at the <a href="http://localhost:8080?raml=/api/hello.raml">console</a>. Once you do that you should be presented with something similar to this:</p><p><img src=/assets/blog/vertx3-contract-driven-rest-services/raml-console.png alt=apiconsole></p><h2 id=article-source-code>Article source code</h2><p>You can get the full source code for this article <a href=https://github.com/pmlopes/vert-x3-experiments/tree/experiments/raml>here</a>.</p></article><hr></article><article class=blog-post><h2 class=blog-post-title><a href="http://vertx.io/blog/writing-secure-vert-x-web-apps/">Writing secure Vert.x Web apps</a></h2><p class=blog-post-meta>14th September 2015 by <a href=http://github.com/pmlopes>pmlopes</a></p><article><p>This is a starting guide for securing vert.x web applications. It is by no means a comprehensive guide on web application security such as <a href=https://www.owasp.org>OWASP</a>. Standard rules and practices apply to vert.x apps as if they would to any other web framework.</p><p>The post will cover the items that always seem to come up on forums.</p><h2 id=don-t-run-as-root>Don’t run as root</h2><p>It is a common practise that your devops team member will constantly say, one shall run a service with the least amount of privileges necessary and no more. Although this might sound like folklore to less experienced developers that hit an issue when trying to run on privileged ports 80, 443, running as root solves it quickly but open a door to bigger problems. Lets look at this code:</p><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>App</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>AbstractVerticle</span> </span>{
  <span class=hljs-annotation>@Override</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>()</span> </span>{

    Router router = Router.router(vertx);

    router.route().handler(StaticHandler.create(<span class=hljs-string>""</span>));

    vertx.createHttpServer().requestHandler(router::accept).listen(<span class=hljs-number>80</span>);
  }
}</code></pre><p>When started with the <code>CWD</code> set to <code>/</code> (<code>java -Dvertx.cwd=/ ...</code>) you just created a simple file server for all your server storage. Now imagine that you want to start this application you will hit the error:</p><pre><code class=hljs>Aug <span class=hljs-number>26</span>, <span class=hljs-number>2015</span> <span class=hljs-number>2</span>:<span class=hljs-number>02</span>:<span class=hljs-number>18</span> PM io<span class=hljs-class>.vertx</span><span class=hljs-class>.core</span><span class=hljs-class>.http</span><span class=hljs-class>.impl</span><span class=hljs-class>.HttpServerImpl</span>
SEVERE: java<span class=hljs-class>.net</span><span class=hljs-class>.SocketException</span>: Permission denied</code></pre><p>So if you do now run as <code>root</code> it will start, however in your browser now try to navigate to: <code>http://localhost/etc/shadow</code> congratulations you just exposed your server <code>logins</code> <strong>and</strong> <code>passwords</code>!</p><p>There are several ways to run as a under privileged user, you can use <code>iptables</code> to forward requests to higher ports, use <code>authbind</code>, run behind a proxy like <code>ngnix</code>, etc…</p><h2 id=sessions>Sessions</h2><p>Many applications are going to deal with user sessions at some point.</p><p>Session cookies should have the <code>SECURE</code> and <code>HTTPOnly</code> flags set. This ensures that they can only be sent over <code>HTTPS</code> (you are using <code>HTTPS</code> right?) and there is no script access to the cookie client side:</p><pre><code class="hljs java">Router router = Router.router(vertx);

    router.route().handler(CookieHandler.create());
    router.route().handler(SessionHandler
        .create(LocalSessionStore.create(vertx))
        .setCookieHttpOnlyFlag(<span class=hljs-keyword>true</span>)
        .setCookieSecureFlag(<span class=hljs-keyword>true</span>)
    );

    router.route().handler(routingContext -&gt; {

      Session session = routingContext.session();

      Integer cnt = session.get(<span class=hljs-string>"hitcount"</span>);
      cnt = (cnt == <span class=hljs-keyword>null</span> ? <span class=hljs-number>0</span> : cnt) + <span class=hljs-number>1</span>;

      session.put(<span class=hljs-string>"hitcount"</span>, cnt);

      routingContext.response().end(<span class=hljs-string>"Hitcount: "</span> + cnt);
    });

    vertx.createHttpServer().requestHandler(router::accept).listen(<span class=hljs-number>8080</span>);</code></pre><p>And in this case when inspecting your browser you should see:</p><p><img src=/assets/blog/vertx3-secure-webapps/nocookie.png alt=nocookie></p><p>Of course if you do not do that any script on your browser has the capability of reading, sniffing hijacking or tampering your sessions.</p><h2 id=security-headers>Security Headers</h2><p>There are plenty of security headers that help improve security with just a couple of lines of code. There is no need to explain them here since there are good <a href=http://recxltd.blogspot.nl/2012/03/seven-web-server-http-headers-that.html>articles</a> online that will probably do it better than me.</p><p>Here is how one could implement a couple of them:</p><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>App</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>AbstractVerticle</span> </span>{

  <span class=hljs-annotation>@Override</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>()</span> </span>{

    Router router = Router.router(vertx);
    router.route().handler(ctx -&gt; {
      ctx.response()
          <span class=hljs-comment>// do not allow proxies to cache the data</span>
          .putHeader(<span class=hljs-string>"Cache-Control"</span>, <span class=hljs-string>"no-store, no-cache"</span>)
          <span class=hljs-comment>// prevents Internet Explorer from MIME - sniffing a</span>
          <span class=hljs-comment>// response away from the declared content-type</span>
          .putHeader(<span class=hljs-string>"X-Content-Type-Options"</span>, <span class=hljs-string>"nosniff"</span>)
          <span class=hljs-comment>// Strict HTTPS (for about ~6Months)</span>
          .putHeader(<span class=hljs-string>"Strict-Transport-Security"</span>, <span class=hljs-string>"max-age="</span> + <span class=hljs-number>15768000</span>)
          <span class=hljs-comment>// IE8+ do not allow opening of attachments in the context of this resource</span>
          .putHeader(<span class=hljs-string>"X-Download-Options"</span>, <span class=hljs-string>"noopen"</span>)
          <span class=hljs-comment>// enable XSS for IE</span>
          .putHeader(<span class=hljs-string>"X-XSS-Protection"</span>, <span class=hljs-string>"1; mode=block"</span>)
          <span class=hljs-comment>// deny frames</span>
          .putHeader(<span class=hljs-string>"X-FRAME-OPTIONS"</span>, <span class=hljs-string>"DENY"</span>);
    });

    vertx.createHttpServer().requestHandler(router::accept).listen(<span class=hljs-number>8080</span>);
  }
}</code></pre><h2 id=cross-site-request-forgery-csrf-protection>Cross-Site Request Forgery (CSRF) Protection</h2><p>Vert.x web provides CSRF protection using an included handler. To enable CSRF protections you need to add it to your router as you would add any other handler:</p><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>App</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>AbstractVerticle</span> </span>{

  <span class=hljs-annotation>@Override</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>()</span> </span>{

    Router router = Router.router(vertx);

    router.route().handler(CookieHandler.create());
    router.route().handler(SessionHandler
        .create(LocalSessionStore.create(vertx))
        .setCookieHttpOnlyFlag(<span class=hljs-keyword>true</span>)
        .setCookieSecureFlag(<span class=hljs-keyword>true</span>)
    );
    router.route().handler(CSRFHandler.create(<span class=hljs-string>"not a good secret"</span>));

    router.route().handler(ctx -&gt; {
      ...
    });</code></pre><p>The handler adds a CSRF token to requests which mutate state. In order change the state a (<code>XSRF-TOKEN</code>) cookie is set with a unique token, that is expected to be sent back in a (<code>X-XSRF-TOKEN</code>) header.</p><h2 id=limit-uploads>Limit uploads</h2><p>When dealing with uploads <strong>always</strong> define a upper bound, otherwise you will be vulnerable to <code>DDoS</code> attacks. For example lets say that you have the following code:</p><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>App</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>AbstractVerticle</span> </span>{

  <span class=hljs-annotation>@Override</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>()</span> </span>{

    Router router = Router.router(vertx);

    router.route().handler(BodyHandler.create());

    router.route().handler(ctx -&gt; {
      ...</code></pre><p>Now a bad intentioned person could generate a random file with 1GB of trash:</p><pre><code class=hljs>dd <span class=hljs-variable>if=</span>/dev/urandom <span class=hljs-variable>of=</span>ddos <span class=hljs-variable>bs=</span><span class=hljs-number>1</span>G <span class=hljs-variable>count=</span><span class=hljs-number>1</span></code></pre><p>And then upload it to your server:</p><pre><code class=hljs>curl --data-binary <span class=hljs-string>"@ddos"</span> -H <span class=hljs-string>"Content-Type: application/octet-stream"</span> -X POST <span class=hljs-string>http:</span><span class=hljs-comment>//localhost:8080/</span></code></pre><p>Your application will happily try to handle this until one of 2 things happens, it will run out of disk space or memory. In order to mitigate these kind of attacks always specify the maximum allowed upload size:</p><pre><code class="hljs java"><span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>App</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>AbstractVerticle</span> </span>{

  <span class=hljs-keyword>private</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>final</span> <span class=hljs-keyword>int</span> KB = <span class=hljs-number>1024</span>;
  <span class=hljs-keyword>private</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>final</span> <span class=hljs-keyword>int</span> MB = <span class=hljs-number>1024</span> * KB;

  <span class=hljs-annotation>@Override</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>start</span><span class=hljs-params>()</span> </span>{

    Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create().setBodyLimit(<span class=hljs-number>50</span> * MB));</code></pre><h2 id=final-words>Final Words</h2><p>Although this is just a small list of things you should remember when implementing your application there are more comprehensive checklists to check:</p><ul><li><a href=https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project>OWASP Top Ten Project</a></li><li><a href=https://www.owasp.org/index.php/Preventing_SQL_Injection_in_Java>Preventing SQL Injection in Java</a></li><li><a href=https://www.owasp.org/index.php/Testing_for_NoSQL_injection>Testing for NoSQL injection</a></li></ul></article><hr></article><article class=blog-post><h2 class=blog-post-title><a href="http://vertx.io/blog/vert-x3-real-time-web-apps/">Vert.x3 real time web apps</a></h2><p class=blog-post-meta>31st August 2015 by <a href=http://github.com/pmlopes>pmlopes</a></p><article><p>One of the interesting features of Vert.x is the <a href=http://sockjs.org>SockJS</a> event bus bridge. This piece of software allows external applications to communicate with Vert.x event bus using Websockets and if your browser does not support it then it gracefully degrades to pooling AJAX calls.</p><p>WebSockets bring a new level of interaction to the web, they really bring real time to web applications due to the fact that its communication model is bi-directional in contrast to the traditional HTTP model where a client can initiate a data request to a server but not the other way around.</p><p>In this small post I will demonstrate how you can create a simple collaborative drawing app. The idea is simple, all users that open the app will be be presented with a empty canvas and what they draw or is drawn on other canvas is shared in real time on their screen.</p><p>For the sake of simplicity and making this post light there is no security involved so, everyone is free to listen to what is being drawn, however the external application has limited read write access to a single address on Vert.x event bus, ensuring that other services running on the cluster will not be exposed.</p><p>This is what you should expect to see:</p><p><img src=/assets/blog/vertx3-realtime-webapps/screencast.gif alt=Screencast></p><h2 id=bootstrap-a-project>Bootstrap a project</h2><p>If you followed the previous <a href=(/blog/my-first-vert-x-3-application/index.html>series</a> on Vert.x development, you saw that Java and Maven were the main topic, since Vert.x is polyglot I will focus on JavaScript and <a href="https://www.npmjs.com/">NPM</a> as my programming language and package management tool.</p><p>With NPM start by creating a <code>package.json</code>, in order to do this we should run:</p><pre><code class="hljs bash">npm init</code></pre><p>This will present a selection of questions and in the end you should have a basic <code>package.json</code> file. This configuration is very basic so you need to add a <a href=https://www.npmjs.com/package/vertx3-full>dependency</a> to Vert.x so you can run the application. You can add it to the <code>dependencies</code> property and it should look more or less like this:</p><pre><code class="hljs javascript">{
  <span class=hljs-string>"name"</span>: <span class=hljs-string>"draw"</span>,
  <span class=hljs-string>"private"</span>: <span class=hljs-literal>true</span>,
  <span class=hljs-string>"dependencies"</span>: {
    <span class=hljs-string>"vertx3-full"</span>: <span class=hljs-string>"3.0.0-1"</span>
  },
  <span class=hljs-string>"scripts"</span>: {
    <span class=hljs-string>"start"</span>: <span class=hljs-string>"vertx run server.js"</span>
  },
  <span class=hljs-string>"version"</span>: <span class=hljs-string>"1.0.0"</span>,
  <span class=hljs-string>"main"</span>: <span class=hljs-string>"server.js"</span>,
  <span class=hljs-string>"devDependencies"</span>: {},
  <span class=hljs-string>"author"</span>: <span class=hljs-string>""</span>,
  <span class=hljs-string>"license"</span>: <span class=hljs-string>"ISC"</span>,
  <span class=hljs-string>"description"</span>: <span class=hljs-string>"A Real Time Drawing App"</span>
}</code></pre><p>If you do not know why there is the dependency on <code>vertx3-full</code> or why the added <code>scripts</code> property please check the <a href=/blog/vert-x3-says-hello-to-npm-users/index.html>older</a> blog post about it.</p><h2 id=project-structure>Project Structure</h2><p>This post has no preference over project structure, so if you do not agree with the structure used here feel free to use what you feel best. For this example I will keep it to:</p><pre><code class=hljs>├── package<span class=hljs-class>.json</span>
├── server<span class=hljs-class>.js</span>
└── webroot
  ├── assets
  │   └── js
  │     ├── script<span class=hljs-class>.js</span>
  │     └── vertxbus<span class=hljs-class>.js</span>
  └── index<span class=hljs-class>.html</span>

<span class=hljs-number>3</span> directories, <span class=hljs-number>5</span> files</code></pre><p>As you can imagine <code>server.js</code> will be our Vert.x application and everything under <code>webroot</code> will be the client application.</p><p>The client application is not really Vert.x specific and could in theory be used by any other framework so I will go lightly over its code.</p><h3 id=client-application>Client Application</h3><p>Our application main entry point is as one can expect <code>index.html</code>. In the index file define the following HTML:</p><pre><code class="hljs html"><span class=hljs-doctype>&lt;!DOCTYPE html&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>html</span>&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>head</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>meta</span> <span class=hljs-attribute>charset</span>=<span class=hljs-value>"utf-8"</span>/&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>title</span>&gt;</span>Real time drawing App<span class=hljs-tag>&lt;/<span class=hljs-title>title</span>&gt;</span>
  <span class=hljs-comment>&lt;!--[if lt IE 9]&gt;
  &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>head</span>&gt;</span>

<span class=hljs-tag>&lt;<span class=hljs-title>body</span>&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>canvas</span> <span class=hljs-attribute>id</span>=<span class=hljs-value>"paper"</span> <span class=hljs-attribute>width</span>=<span class=hljs-value>"1900"</span> <span class=hljs-attribute>height</span>=<span class=hljs-value>"1000"</span>&gt;</span>
  Your browser needs to support canvas for this to work!
<span class=hljs-tag>&lt;/<span class=hljs-title>canvas</span>&gt;</span>

<span class=hljs-comment>&lt;!-- JavaScript includes. --&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>script</span> <span class=hljs-attribute>src</span>=<span class=hljs-value>"http://code.jquery.com/jquery-1.8.0.min.js"</span>&gt;</span><span class=javascript></span><span class=hljs-tag>&lt;/<span class=hljs-title>script</span>&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>script</span> <span class=hljs-attribute>src</span>=<span class=hljs-value>"//cdn.jsdelivr.net/sockjs/0.3.4/sockjs.min.js"</span>&gt;</span><span class=javascript></span><span class=hljs-tag>&lt;/<span class=hljs-title>script</span>&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>script</span> <span class=hljs-attribute>src</span>=<span class=hljs-value>'assets/js/vertxbus.js'</span>&gt;</span><span class=javascript></span><span class=hljs-tag>&lt;/<span class=hljs-title>script</span>&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>script</span> <span class=hljs-attribute>src</span>=<span class=hljs-value>"assets/js/script.js"</span>&gt;</span><span class=javascript></span><span class=hljs-tag>&lt;/<span class=hljs-title>script</span>&gt;</span>

<span class=hljs-tag>&lt;/<span class=hljs-title>body</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>html</span>&gt;</span></code></pre><p>As I previously wrote, the idea is to keep it as simple as possible so it is all about having a canvas element and a application main script <code>script.js</code>. All the rest are files served by CDNs that provide common web application libraries such as <code>jQuery</code>, <code>HTML5</code> shim for older browsers, <code>SockJS</code> client and <code>vertxbus</code> bridge.</p><p>The main code is on <code>script.js</code> file:</p><pre><code class="hljs javascript">$(<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-params>()</span> </span>{

  <span class=hljs-comment>// This demo depends on the canvas element</span>
  <span class=hljs-keyword>if</span> (!(<span class=hljs-string>'getContext'</span> <span class=hljs-keyword>in</span> <span class=hljs-built_in>document</span>.createElement(<span class=hljs-string>'canvas'</span>))) {
    alert(<span class=hljs-string>'Sorry, it looks like your browser does not support canvas!'</span>);
    <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;
  }

  <span class=hljs-keyword>var</span> doc = $(<span class=hljs-built_in>document</span>),
    canvas = $(<span class=hljs-string>'#paper'</span>),
    ctx = canvas[<span class=hljs-number>0</span>].getContext(<span class=hljs-string>'2d'</span>);

  <span class=hljs-comment>// Generate an unique ID</span>
  <span class=hljs-keyword>var</span> id = <span class=hljs-built_in>Math</span>.round($.now() * <span class=hljs-built_in>Math</span>.random());

  <span class=hljs-comment>// A flag for drawing activity</span>
  <span class=hljs-keyword>var</span> drawing = <span class=hljs-literal>false</span>;

  <span class=hljs-keyword>var</span> clients = {};
  <span class=hljs-comment>// create a event bus bridge to the server that served this file</span>
  <span class=hljs-keyword>var</span> eb = <span class=hljs-keyword>new</span> vertx.EventBus(
      <span class=hljs-built_in>window</span>.location.protocol + <span class=hljs-string>'//'</span> + <span class=hljs-built_in>window</span>.location.hostname + <span class=hljs-string>':'</span> + <span class=hljs-built_in>window</span>.location.port + <span class=hljs-string>'/eventbus'</span>);

  eb.onopen = <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-params>()</span> </span>{
    <span class=hljs-comment>// listen to draw events</span>
    eb.registerHandler(<span class=hljs-string>'draw'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-params>(data)</span> </span>{
      <span class=hljs-comment>// Is the user drawing?</span>
      <span class=hljs-keyword>if</span> (data.drawing &amp;&amp; clients[data.id]) {

        <span class=hljs-comment>// Draw a line on the canvas. clients[data.id] holds</span>
        <span class=hljs-comment>// the previous position of this user's mouse pointer</span>

        drawLine(clients[data.id].x, clients[data.id].y, data.x, data.y);
      }

      <span class=hljs-comment>// Saving the current client state</span>
      clients[data.id] = data;
      clients[data.id].updated = $.now();
    });
  };

  <span class=hljs-keyword>var</span> prev = {};

  canvas.on(<span class=hljs-string>'mousedown'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-params>(e)</span> </span>{
    e.preventDefault();
    drawing = <span class=hljs-literal>true</span>;
    prev.x = e.pageX;
    prev.y = e.pageY;
  });

  doc.bind(<span class=hljs-string>'mouseup mouseleave'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-params>()</span> </span>{
    drawing = <span class=hljs-literal>false</span>;
  });

  <span class=hljs-keyword>var</span> lastEmit = $.now();

  doc.on(<span class=hljs-string>'mousemove'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-params>(e)</span> </span>{
    <span class=hljs-keyword>if</span> ($.now() - lastEmit &gt; <span class=hljs-number>30</span>) {
      eb.publish(<span class=hljs-string>'draw'</span>, {
        <span class=hljs-string>'x'</span>: e.pageX,
        <span class=hljs-string>'y'</span>: e.pageY,
        <span class=hljs-string>'drawing'</span>: drawing,
        <span class=hljs-string>'id'</span>: id
      });
      lastEmit = $.now();
    }

    <span class=hljs-comment>// Draw a line for the current user's movement, as it is</span>
    <span class=hljs-comment>// not received in the eventbus</span>

    <span class=hljs-keyword>if</span> (drawing) {

      drawLine(prev.x, prev.y, e.pageX, e.pageY);

      prev.x = e.pageX;
      prev.y = e.pageY;
    }
  });

  <span class=hljs-comment>// Remove inactive clients after 10 seconds of inactivity</span>
  setInterval(<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-params>()</span> </span>{

    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> ident <span class=hljs-keyword>in</span> clients) {
      <span class=hljs-keyword>if</span> (clients.hasOwnProperty(ident)) {
        <span class=hljs-keyword>if</span> ($.now() - clients[ident].updated &gt; <span class=hljs-number>10000</span>) {
          <span class=hljs-comment>// Last update was more than 10 seconds ago.</span>
          <span class=hljs-comment>// This user has probably closed the page</span>
          <span class=hljs-keyword>delete</span> clients[ident];
        }
      }
    }

  }, <span class=hljs-number>10000</span>);

  <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>drawLine</span><span class=hljs-params>(fromx, fromy, tox, toy)</span> </span>{
    ctx.moveTo(fromx, fromy);
    ctx.lineTo(tox, toy);
    ctx.stroke();
  }

});</code></pre><p>The most important part in this code is all the code related to <code>eb</code>. The variable <code>eb</code> is our bridge to the event bus, Start by creating a bridge using the <code>vertx.EventBus</code> object and define where to connect, using the details of the current window location.</p><p>Then add a <code>onopen</code> listener that will subscribe to the address <code>draw</code> on the event bus so it can listen to all messages regarding drawing and perform the drawing actions. Since listening is not enough I also add a mouse listener to the document so when it moves it publishes events to the <code>draw</code> address.</p><p>Note that I am using <code>publish</code> and not <code>send</code>, the reason should be obvious, I want everyone to know this users mouse movements, I am not interested on sending the events to just a single user. You can see now that if you want to have a drawing app in a one on one user basis then instead of <code>publish()</code> you should use <code>send()</code>.</p><h3 id=server-application>Server Application</h3><p>The server code is quite straight forward, all you need is:</p><pre><code class="hljs javascript"><span class=hljs-keyword>var</span> Router = <span class=hljs-built_in>require</span>(<span class=hljs-string>"vertx-web-js/router"</span>);
<span class=hljs-keyword>var</span> SockJSHandler = <span class=hljs-built_in>require</span>(<span class=hljs-string>"vertx-web-js/sock_js_handler"</span>);
<span class=hljs-keyword>var</span> StaticHandler = <span class=hljs-built_in>require</span>(<span class=hljs-string>"vertx-web-js/static_handler"</span>);

<span class=hljs-keyword>var</span> router = Router.router(vertx);

<span class=hljs-comment>// Allow outbound traffic to the draw address</span>

<span class=hljs-keyword>var</span> options = {
  <span class=hljs-string>"outboundPermitteds"</span> : [{<span class=hljs-string>"address"</span> : <span class=hljs-string>"draw"</span>}],
  <span class=hljs-string>"inboundPermitteds"</span> :  [{<span class=hljs-string>"address"</span> : <span class=hljs-string>"draw"</span>}]
};

router.route(<span class=hljs-string>"/eventbus/*"</span>).handler(SockJSHandler.create(vertx).bridge(options).handle);

<span class=hljs-comment>// Serve the static resources</span>
router.route().handler(StaticHandler.create().handle);

vertx.createHttpServer().requestHandler(router.accept).listen(<span class=hljs-number>8080</span>);</code></pre><p>We start with the usual imports, we import a reference to the <code>Router</code> object and a couple of helper handlers <code>SockJSHandler</code> and <code>StaticHandler</code>. As their names should tell you one handler will be responsible to handle all <code>SockJS</code> data and the other all HTTP file serving requests.</p><p>We then add then to a router and start a HTTP server that will handle all incoming request using the handler accept function. Finally we listen on port <code>8080</code> and we are ready.</p><p>Note that there is a options object where a couple of properties are defined <code>outbound/inbound</code> permitted addresses. Without this configuration the external application will not be allowed to connect to the vert.x bus, in fact the default configuration of the SockJSHandler is deny all. So you must specify explicitly which address are allowed to receive messages from <code>SockJS</code> and which ones are allowed to send/publish to <code>SockJS</code>.</p><p>Now you can start your application, don’t forget to install the dependencies for the first time:</p><pre><code class="hljs bash">npm install</code></pre><p>And then run the application:</p><pre><code class="hljs bash">npm start</code></pre><p>If you now open 2 browser windows you will be able to draw nice pictures and see the drawing showing in “real time” on the other window, if you then draw on the second you should get the mirror effect on the first window.</p><p>Have fun!</p></article><hr></article><article class=blog-post><h2 class=blog-post-title><a href="http://vertx.io/blog/unit-and-integration-tests/">Unit and Integration Tests</a></h2><p class=blog-post-meta>3rd August 2015 by <a href=http://github.com/cescoffier>cescoffier</a></p><article><h2 id=previously-in-introduction-to-vert-x->Previously in “introduction to vert.x”</h2><p>Let’s refresh our mind about what we developed so far in the <em>introduction to vert.x</em> series. In <a href="http://vertx.io/blog/my-first-vert-x-3-application/">the first post</a>, we developed a very simple Vert.x 3 application, and saw how this application can be tested, packaged and executed. In <a href="http://vertx.io/blog/vert-x-application-configuration/">the second post</a>, we saw how this application became configurable and how we can use a random port in test, and use another configurable port in production. Finally, the <a href="http://vertx.io/blog/some-rest-with-vert-x/">previous post</a> has shown how to use vertx-web and how to implement a small REST API. However, we forgot an important task. We didn’t test the API. In this post we will increase the confidence we have on this application by implementing unit and integration tests.</p><p>The code of this post is available in the <a href=https://github.com/cescoffier/my-vertx-first-app/tree/post-4>post-4 branch</a> of the <a href=https://github.com/cescoffier/my-vertx-first-app>project</a>. The starting post, however is the code available in the <a href=https://github.com/cescoffier/my-vertx-first-app/tree/post-3>post-3 branch</a>.</p><h2 id=tests-tests-tests->Tests, Tests, Tests…</h2><p>This post is mainly about tests. We distinguish two types of tests: unit tests and integration tests. Both are equally important, but have different focus. Unit tests ensure that one <em>component</em> of your application, generally a class in the Java world, behaves as expected. The application is not tested as a whole, but pieces by pieces. Integration tests are more <em>black box</em> in the sense that the application is started and tested generally externally.</p><p>In this post we are going to start with some more unit tests as a warm up session and then focus on integration tests. If you already implemented integration tests, you may be a bit scared, and it makes sense. But don’t worry, with Vert.x there are no hidden surprises.</p><h2 id=warmup-some-more-unit-tests>Warmup: Some more unit tests</h2><p>Let’s start slowly. Remember in the first post we have implemented a unit test with <a href="http://vertx.io/docs/vertx-unit/java/">vertx-unit</a>. The test we did is dead simple:</p><ol><li>we started the application before the test</li><li>we checks that it replies “Hello”</li></ol><p>Just to refresh your mind, let’s have a look at the <a href=https://github.com/cescoffier/my-vertx-first-app/blob/post-4/src/test/java/io/vertx/blog/first/MyFirstVerticleTest.java>code</a></p><pre><code class="hljs java"><span class=hljs-annotation>@Before</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>setUp</span><span class=hljs-params>(TestContext context)</span> <span class=hljs-keyword>throws</span> IOException </span>{
  vertx = Vertx.vertx();
  ServerSocket socket = <span class=hljs-keyword>new</span> ServerSocket(<span class=hljs-number>0</span>);
  port = socket.getLocalPort();
  socket.close();
  DeploymentOptions options = <span class=hljs-keyword>new</span> DeploymentOptions()
      .setConfig(<span class=hljs-keyword>new</span> JsonObject().put(<span class=hljs-string>"http.port"</span>, port)
      );
  vertx.deployVerticle(MyFirstVerticle.class.getName(), options, context.asyncAssertSuccess());
}</code></pre><p>The <code>setUp</code> method is invoked before each test (as instructed by the <code>@Before</code> annotation). It, first, creates a new instance of Vert.x. Then, it gets a free port and then deploys our verticle with the right configuration. Thanks to the <code>context.asyncAssertSuccess()</code> it waits until the successful deployment of the verticle.</p><p>The <code>tearDown</code> is straightforward and just closes the Vert.x instance. It automatically un-deploys the verticles:</p><pre><code class="hljs java"><span class=hljs-annotation>@After</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>tearDown</span><span class=hljs-params>(TestContext context)</span> </span>{
  vertx.close(context.asyncAssertSuccess());
}</code></pre><p>Finally, our single test is:</p><pre><code class="hljs java"><span class=hljs-annotation>@Test</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>testMyApplication</span><span class=hljs-params>(TestContext context)</span> </span>{
  <span class=hljs-keyword>final</span> Async async = context.async();
  vertx.createHttpClient().getNow(port, <span class=hljs-string>"localhost"</span>, <span class=hljs-string>"/"</span>, response -&gt; {
    response.handler(body -&gt; {
      context.assertTrue(body.toString().contains(<span class=hljs-string>"Hello"</span>));
      async.complete();
    });
  });
 }</code></pre>It is only checking that the application replies "Hello" when we emit a HTTP request on `/`. Let's now try to implement some unit tests checkin that our web application and the REST API behave as expected. Let's start by checking that the `index.html` page is correctly served. This test is very similar to the previous one:<pre><code class="hljs java"><span class=hljs-annotation>@Test</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>checkThatTheIndexPageIsServed</span><span class=hljs-params>(TestContext context)</span> </span>{
  Async async = context.async();
  vertx.createHttpClient().getNow(port, <span class=hljs-string>"localhost"</span>, <span class=hljs-string>"/assets/index.html"</span>, response -&gt; {
    context.assertEquals(response.statusCode(), <span class=hljs-number>200</span>);
    context.assertEquals(response.headers().get(<span class=hljs-string>"content-type"</span>), <span class=hljs-string>"text/html"</span>);
    response.bodyHandler(body -&gt; {
      context.assertTrue(body.toString().contains(<span class=hljs-string>"&lt;title&gt;My Whisky Collection&lt;/title&gt;"</span>));
      async.complete();
    });
  });
}</code></pre><p>We retrieve the <code>index.html</code> page and check:</p><ol><li>it’s there (status code 200)</li><li>it’s a HTML page (content type set to “text/html”)</li><li>it has the right title (“My Whisky Collection”)</li></ol><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=title>Retrieving content</span><br><span class=content>As you can see, we can test the status code and the headers directly on the HTTP response, but ensure that the body is right, we need to retrieve it. This is done with a body handler that receives the complete body as parameter. Once the last check is made, we release the <code>async</code> by calling <code>complete</code>.</span></td></tr></tbody></table></div></p><p>Ok, great, but this actually does not test our REST API. Let’s ensure that we can add a bottle to the collection. Unlike the previous tests, this one is using <code>post</code> to <em>post</em> data to the server:</p><pre><code class="hljs java"><span class=hljs-annotation>@Test</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>checkThatWeCanAdd</span><span class=hljs-params>(TestContext context)</span> </span>{
  Async async = context.async();
  <span class=hljs-keyword>final</span> String json = Json.encodePrettily(<span class=hljs-keyword>new</span> Whisky(<span class=hljs-string>"Jameson"</span>, <span class=hljs-string>"Ireland"</span>));
  <span class=hljs-keyword>final</span> String length = Integer.toString(json.length());
  vertx.createHttpClient().post(port, <span class=hljs-string>"localhost"</span>, <span class=hljs-string>"/api/whiskies"</span>)
      .putHeader(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"application/json"</span>)
      .putHeader(<span class=hljs-string>"content-length"</span>, length)
      .handler(response -&gt; {
        context.assertEquals(response.statusCode(), <span class=hljs-number>201</span>);
        context.assertTrue(response.headers().get(<span class=hljs-string>"content-type"</span>).contains(<span class=hljs-string>"application/json"</span>));
        response.bodyHandler(body -&gt; {
          <span class=hljs-keyword>final</span> Whisky whisky = Json.decodeValue(body.toString(), Whisky.class);
          context.assertEquals(whisky.getName(), <span class=hljs-string>"Jameson"</span>);
          context.assertEquals(whisky.getOrigin(), <span class=hljs-string>"Ireland"</span>);
          context.assertNotNull(whisky.getId());
          async.complete();
        });
      })
      .write(json)
      .end();
}</code></pre><p>First we create the content we want to add. The server consumes JSON data, so we need a JSON string. You can either write your JSON document manually, or use the Vert.x method (<code>Json.encodePrettily</code>) as done here. Once we have the content, we create a <code>post</code> request. We need to configure some headers to be correctly read by the server. First, we say that we are sending JSON data and we also set the content length. We also attach a response handler very close to the checks made in the previous test. Notice that we can rebuild our object from the JSON document send by the server using the <code>JSON.decodeValue</code> method. It’s very convenient as it avoids lots of boilerplate code. At this point the request is not emitted, we need to write the data and call the <code>end()</code> method. This is made using <code>.write(json).end();</code>.</p><p>The order of the methods is important. You cannot <em>write</em> data if you don’t have a response handler configured. Finally don’t forget to call <code>end</code>.</p><p>So, let’s try this. You can run the test using:</p><pre><code class="hljs bash">mvn clean test</code></pre><p>We could continue writing more unit test like that, but it could become quite complex. Let’s see how we could continue our tests using integration tests.</p><h2 id=it-hurts>IT hurts</h2><p>Well, I think we need to make that clear, integration testing hurts. If you have experience in this area, can you remember how long did it take to setup everything correctly? I get new white hairs by just thinking about it. Why are integration tests more complicated? It’s basically because of the setup:</p><ol><li>We must start the application in a <em>close to production</em> way</li><li>We must then run the tests (and configure them to hit the right application instance)</li><li>We must stop the application</li></ol><p>That does not sound unconquerable like that, but if you need Linux, MacOS X and Windows support, it quickly get messy. There are plenty of great frameworks easing this such as <a href=http://arquillian.org>Arquillian</a>, but let’s do it without any framework to understand how it works.</p><h2 id=we-need-a-battle-plan>We need a battle plan</h2><p>Before rushing into the complex configuration, let’s think a minute about the tasks:</p><p><strong>Step 1 - Reserve a free port</strong> We need to get a free port on which the application can <em>listen</em>, and we need to inject this port in our integration tests.</p><p><strong>Step 2 - Generate the application configuration</strong> Once we have the free port, we need to write a JSON file configuring the application HTTP Port to this port.</p><p><strong>Step 3 - Start the application</strong> Sounds easy right? Well it’s not that simple as we need to launch our application in a background process.</p><p><strong>Step 4 - Execute the integration tests</strong> Finally, the central part, run the tests. But before that we should implement some integration tests. Let’s come to that later.</p><p><strong>Step 5 - Stop the application</strong> Once the tests have been executed, regardless if there are failures or errors in the tests, we need to stop the application.</p><p>There are multiple way to implement this plan. We are going to use a <em>generic</em> way. It’s not necessarily the better, but can be applied almost everywhere. The approach is tight to Apache Maven. If you want to propose an alternative using Gradle or a different tool, I will be happy to add your way to the post.</p><h2 id=implement-the-plan>Implement the plan</h2><p>As said above, this section is Maven-centric, and most of the code goes in the <a href=https://github.com/cescoffier/my-vertx-first-app/blob/post-4/pom.xml>pom.xml</a> file. If you never used the different Maven lifecycle phases, I recommend you to look at the <a href=https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html>introduction to the Maven lifecycle</a>.</p><p>We need to add and configure a couple of plugins. Open the <code>pom.xml</code> file and in the <code>&lt;plugins&gt;</code> section add:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>plugin</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>org.codehaus.mojo<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>build-helper-maven-plugin<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>1.9.1<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>executions</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>id</span>&gt;</span>reserve-network-port<span class=hljs-tag>&lt;/<span class=hljs-title>id</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>reserve-network-port<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>phase</span>&gt;</span>process-sources<span class=hljs-tag>&lt;/<span class=hljs-title>phase</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>portNames</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>portName</span>&gt;</span>http.port<span class=hljs-tag>&lt;/<span class=hljs-title>portName</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>portNames</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>executions</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>plugin</span>&gt;</span></code></pre><p>We use the <code>build-helper-maven-plugin</code> (a plugin to know if you are often using Maven) to pick up a free port. Once found, the plugin assigns the <code>http.port</code> variable to the picked port. We execute this plugin early in the build (during the <code>process-sources</code> phase), so we can use the <code>http.port</code> variable in the other plugin. This was for the first step.</p><p>Two actions are required for the second step. First, in the <code>pom.xml</code> file, just below the <code>&lt;build&gt;</code> opening tag, add:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>testResources</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>testResource</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>directory</span>&gt;</span>src/test/resources<span class=hljs-tag>&lt;/<span class=hljs-title>directory</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>filtering</span>&gt;</span>true<span class=hljs-tag>&lt;/<span class=hljs-title>filtering</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>testResource</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>testResources</span>&gt;</span></code></pre><p>This instructs Maven to <em>filter</em> resources from the <code>src/test/resources</code> directory. <em>Filter</em> means replacing placeholders by actual values. That’s exactly what we need as we now have the <code>http.port</code> variable. So create the <code>src/test/resources/my-it-config.json</code> file with the following content:</p><pre><code class="hljs javascript">{
  <span class=hljs-string>"http.port"</span>: ${http.port}
}</code></pre><p>This configuration file is similar to the one we did in previous posts. The only difference is the <code>${http.port}</code> which is the (default) Maven syntax for filtering. So, when Maven is going to process or file it will replace <code>${http.port}</code> by the selected port. That’s all for the second step.</p><p>The step 3 and 5 are a bit more tricky. We should start and stop the application. We are going to use the <code>maven-antrun-plugin</code> to achieve this. In the <code>pom.xml</code> file, below the <code>build-helper-maven-plugin</code>, add:</p><pre><code class="hljs xml"><span class=hljs-comment>&lt;!-- We use the maven-antrun-plugin to start the application before the integration tests
and stop them afterward --&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>plugin</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>maven-antrun-plugin<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>1.8<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>executions</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>id</span>&gt;</span>start-vertx-app<span class=hljs-tag>&lt;/<span class=hljs-title>id</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>phase</span>&gt;</span>pre-integration-test<span class=hljs-tag>&lt;/<span class=hljs-title>phase</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>run<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>target</span>&gt;</span>
          <span class=hljs-comment>&lt;!--
          Launch the application as in 'production' using the fatjar.
          We pass the generated configuration, configuring the http port to the picked one
          --&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>exec</span> <span class=hljs-attribute>executable</span>=<span class=hljs-value>"${java.home}/bin/java"</span>
                <span class=hljs-attribute>dir</span>=<span class=hljs-value>"${project.build.directory}"</span>
                <span class=hljs-attribute>spawn</span>=<span class=hljs-value>"true"</span>&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"-jar"</span>/&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"${project.artifactId}-${project.version}-fat.jar"</span>/&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"-conf"</span>/&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"${project.build.directory}/test-classes/my-it-config.json"</span>/&gt;</span>
          <span class=hljs-tag>&lt;/<span class=hljs-title>exec</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>target</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>id</span>&gt;</span>stop-vertx-app<span class=hljs-tag>&lt;/<span class=hljs-title>id</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>phase</span>&gt;</span>post-integration-test<span class=hljs-tag>&lt;/<span class=hljs-title>phase</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>run<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
        <span class=hljs-comment>&lt;!--
          Kill the started process.
          Finding the right process is a bit tricky. Windows command in in the windows profile (below)
          --&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>target</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>exec</span> <span class=hljs-attribute>executable</span>=<span class=hljs-value>"bash"</span>
                <span class=hljs-attribute>dir</span>=<span class=hljs-value>"${project.build.directory}"</span>
                <span class=hljs-attribute>spawn</span>=<span class=hljs-value>"false"</span>&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"-c"</span>/&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"ps ax | grep -i '${project.artifactId}' | awk 'NR==1{print $1}' | xargs kill -SIGTERM"</span>/&gt;</span>
          <span class=hljs-tag>&lt;/<span class=hljs-title>exec</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>target</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>executions</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>plugin</span>&gt;</span></code></pre><p>That’s a huge piece of XML, isn’t it ? We configure two executions of the plugin. The first one, happening in the <code>pre-integration-test</code> phase, executes a set of bash command to start the application. It basically executes:</p><pre><code class="hljs bash">java -jar my-first-app-<span class=hljs-number>1.0</span>-SNAPSHOT-fat.jar -conf .../my-it-config.json</code></pre><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=title>Is the fatjar created ?</span><br><span class=content>The fat jar embedding our application is created in the <code>package</code> phase, preceding the <code>pre-integration-test</code>, so yes, the fat jar is created.</span></td></tr></tbody></table></div></p><p>As mentioned above, we launch the application as we would in a production environment.</p><p>Once, the integration tests are executed (step 4 we didn’t look at it yet), we need to stop the application (so in the the <code>post-integration-test</code> phase). To close the application, we are going to invoke some shell magic command to find our process in with the <code>ps</code> command and send the <code>SIGTERM</code> signal. It is equivalent to:</p><pre><code class="hljs bash">ps
.... -&gt; find your process id
kill your_process_id -SIGTERM</code></pre><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=title>And Windows ?</span><br><span class=content>I mentioned it above, we want Windows to be supported and these commands are not going to work on Windows. Don’t worry, Windows configuration is below….</span></td></tr></tbody></table></div></p><p>We should now do the fourth step we (silently) skipped. To execute our integration tests, we use the <code>maven-failsafe-plugin</code>. Add the following plugin configuration to your <code>pom.xml</code> file:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>plugin</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>org.apache.maven.plugins<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>maven-failsafe-plugin<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>2.18.1<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>executions</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>integration-test<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>verify<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>systemProperties</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>http.port</span>&gt;</span>${http.port}<span class=hljs-tag>&lt;/<span class=hljs-title>http.port</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>systemProperties</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>executions</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>plugin</span>&gt;</span></code></pre><p>As you can see, we pass the <code>http.port</code> property as a system variable, so our tests are able to connect on the right port.</p><p>That’s all! Wow… Let’s try this (for windows users, you will need to be patient or to jump to the last section).</p><pre><code class="hljs bash">mvn clean verify</code></pre><p>We should not use <code>mvn integration-test</code> because the application would still be running. The <code>verify</code> phase is after the <code>post-integration-test</code> phase and will analyse the integration-tests results. Build failures because of integration tests failed assertions are reported in this phase.</p><h2 id=hey-we-don-t-have-integration-tests->Hey, we don’t have integration tests !</h2><p>And that’s right, we set up everything, but we don’t have a single integration test. To ease the implementation, let’s use two libraries: <a href="http://joel-costigliola.github.io/assertj/">AssertJ</a> and <a href=https://github.com/jayway/rest-assured>Rest-Assured</a>.</p><p>AssertJ proposes a set of assertions that you can chain and use fluently. Rest Assured is a framework to test REST API.</p><p>In the <code>pom.xml</code> file, add the two following dependencies just before <code>&lt;/dependencies&gt;</code>:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>dependency</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>com.jayway.restassured<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>rest-assured<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>2.4.0<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>scope</span>&gt;</span>test<span class=hljs-tag>&lt;/<span class=hljs-title>scope</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>dependency</span>&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>dependency</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>org.assertj<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>assertj-core<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>2.0.0<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>scope</span>&gt;</span>test<span class=hljs-tag>&lt;/<span class=hljs-title>scope</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>dependency</span>&gt;</span></code></pre><p>Then, create the <code>src/test/java/io/vertx/blog/first/MyRestIT.java</code> file. Unlike unit test, integration test ends with <code>IT</code>. It’s a convention from the Failsafe plugin to distinguish unit (starting or ending with <em>Test</em>) from integration tests (starting or ending with <em>IT</em>). In the created file add:</p><pre><code class="hljs java"><span class=hljs-keyword>package</span> io.vertx.blog.first;

<span class=hljs-keyword>import</span> com.jayway.restassured.RestAssured;
<span class=hljs-keyword>import</span> org.junit.AfterClass;
<span class=hljs-keyword>import</span> org.junit.BeforeClass;

<span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>MyRestIT</span> </span>{

  <span class=hljs-annotation>@BeforeClass</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>void</span> <span class=hljs-title>configureRestAssured</span><span class=hljs-params>()</span> </span>{
    RestAssured.baseURI = <span class=hljs-string>"http://localhost"</span>;
    RestAssured.port = Integer.getInteger(<span class=hljs-string>"http.port"</span>, <span class=hljs-number>8080</span>);
  }

  <span class=hljs-annotation>@AfterClass</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>void</span> <span class=hljs-title>unconfigureRestAssured</span><span class=hljs-params>()</span> </span>{
    RestAssured.reset();
  }
}</code></pre><p>The methods annotated with <code>@BeforeClass</code> and <code>@AfterClass</code> are invoked once before / after all tests of the class. Here, we just retrieve the http port (passed as a system property) and we configure REST Assured.</p><p>It’s now time to implement a real test. Let’s check we can retrieve an individual product:</p><pre><code class="hljs java"><span class=hljs-annotation>@Test</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>checkThatWeCanRetrieveIndividualProduct</span><span class=hljs-params>()</span> </span>{
  <span class=hljs-comment>// Get the list of bottles, ensure it's a success and extract the first id.</span>
  <span class=hljs-keyword>final</span> <span class=hljs-keyword>int</span> id = get(<span class=hljs-string>"/api/whiskies"</span>).then()
      .assertThat()
      .statusCode(<span class=hljs-number>200</span>)
      .extract()
      .jsonPath().getInt(<span class=hljs-string>"find { it.name=='Bowmore 15 Years Laimrig' }.id"</span>);
  <span class=hljs-comment>// Now get the individual resource and check the content</span>
  get(<span class=hljs-string>"/api/whiskies/"</span> + id).then()
      .assertThat()
      .statusCode(<span class=hljs-number>200</span>)
      .body(<span class=hljs-string>"name"</span>, equalTo(<span class=hljs-string>"Bowmore 15 Years Laimrig"</span>))
      .body(<span class=hljs-string>"origin"</span>, equalTo(<span class=hljs-string>"Scotland, Islay"</span>))
      .body(<span class=hljs-string>"id"</span>, equalTo(id));
}</code></pre><p>Here you can appreciate the power and expressiveness of Rest Assured. We retrieve the list of product, ensure the response is correct, and extract the <em>id</em> of a specific bottle using a JSON (Groovy) Path expression.</p><p>Then, we try to retrieve the metadata of this individual product, and check the result.</p><p>Let’s now implement a more sophisticated scenario. Let’s add and delete a product:</p><pre><code class="hljs java"><span class=hljs-annotation>@Test</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>checkWeCanAddAndDeleteAProduct</span><span class=hljs-params>()</span> </span>{
  <span class=hljs-comment>// Create a new bottle and retrieve the result (as a Whisky instance).</span>
  Whisky whisky = given()
      .body(<span class=hljs-string>"{\"name\":\"Jameson\", \"origin\":\"Ireland\"}"</span>).request().post(<span class=hljs-string>"/api/whiskies"</span>).thenReturn().as(Whisky.class);
  assertThat(whisky.getName()).isEqualToIgnoringCase(<span class=hljs-string>"Jameson"</span>);
  assertThat(whisky.getOrigin()).isEqualToIgnoringCase(<span class=hljs-string>"Ireland"</span>);
  assertThat(whisky.getId()).isNotZero();
  <span class=hljs-comment>// Check that it has created an individual resource, and check the content.</span>
  get(<span class=hljs-string>"/api/whiskies/"</span> + whisky.getId()).then()
      .assertThat()
      .statusCode(<span class=hljs-number>200</span>)
      .body(<span class=hljs-string>"name"</span>, equalTo(<span class=hljs-string>"Jameson"</span>))
      .body(<span class=hljs-string>"origin"</span>, equalTo(<span class=hljs-string>"Ireland"</span>))
      .body(<span class=hljs-string>"id"</span>, equalTo(whisky.getId()));
  <span class=hljs-comment>// Delete the bottle</span>
  delete(<span class=hljs-string>"/api/whiskies/"</span> + whisky.getId()).then().assertThat().statusCode(<span class=hljs-number>204</span>);
  <span class=hljs-comment>// Check that the resrouce is not available anymore</span>
  get(<span class=hljs-string>"/api/whiskies/"</span> + whisky.getId()).then()
      .assertThat()
      .statusCode(<span class=hljs-number>404</span>);
}</code></pre>So, now we have integration tests let's try:<pre><code class="hljs bash">mvn clean verify</code></pre><p>Simple no? Well, simple once the setup is done right… You can continue implementing other integration tests to be sure that everything behave as you expect.</p><h2 id=dear-windows-users->Dear Windows users…</h2><p>This section is the bonus part for Windows user, or people wanting to run their integration tests on Windows machine too. The command we execute to stop the application is not going to work on Windows. Luckily, it’s possible to extend the <code>pom.xml</code> with a profile executed on Windows.</p><p>In your <code>pom.xml</code>, just after <code>&lt;/build&gt;</code>, add:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>profiles</span>&gt;</span>
  <span class=hljs-comment>&lt;!-- A profile for windows as the stop command is different --&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>profile</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>id</span>&gt;</span>windows<span class=hljs-tag>&lt;/<span class=hljs-title>id</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>activation</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>os</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>family</span>&gt;</span>windows<span class=hljs-tag>&lt;/<span class=hljs-title>family</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>os</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>activation</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>build</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>plugins</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>plugin</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>maven-antrun-plugin<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>1.8<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>executions</span>&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
              <span class=hljs-tag>&lt;<span class=hljs-title>id</span>&gt;</span>stop-vertx-app<span class=hljs-tag>&lt;/<span class=hljs-title>id</span>&gt;</span>
              <span class=hljs-tag>&lt;<span class=hljs-title>phase</span>&gt;</span>post-integration-test<span class=hljs-tag>&lt;/<span class=hljs-title>phase</span>&gt;</span>
              <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
                <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>run<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
              <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
              <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
                <span class=hljs-tag>&lt;<span class=hljs-title>target</span>&gt;</span>
                  <span class=hljs-tag>&lt;<span class=hljs-title>exec</span> <span class=hljs-attribute>executable</span>=<span class=hljs-value>"wmic"</span>
                      <span class=hljs-attribute>dir</span>=<span class=hljs-value>"${project.build.directory}"</span>
                      <span class=hljs-attribute>spawn</span>=<span class=hljs-value>"false"</span>&gt;</span>
                    <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"process"</span>/&gt;</span>
                    <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"where"</span>/&gt;</span>
                    <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"CommandLine like '%${project.artifactId}%' and not name='wmic.exe'"</span>/&gt;</span>
                    <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"delete"</span>/&gt;</span>
                  <span class=hljs-tag>&lt;/<span class=hljs-title>exec</span>&gt;</span>
                <span class=hljs-tag>&lt;/<span class=hljs-title>target</span>&gt;</span>
              <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
            <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
          <span class=hljs-tag>&lt;/<span class=hljs-title>executions</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>plugin</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>plugins</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>build</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>profile</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>profiles</span>&gt;</span></code></pre><p>This profile replaces the actions described above to stop the application with a version working on windows. The profile is automatically enabled on Windows. As on others operating systems, execute with:</p><pre><code class="hljs bash">mvn clean verify</code></pre><h2 id=conclusion>Conclusion</h2><p>Wow, what a trip ! We are done… In this post we have seen how we can gain confidence in Vert.x applications by implementing both unit and integration tests. Unit tests, thanks to vert.x unit, are able to check the asynchronous aspect of Vert.x application, but could be complex for large scenarios. Thanks to Rest Assured and AssertJ, integration tests are dead simple to write… but the setup is not straightforward. This post have shown how it can be configured easily. Obviously, you could also use AssertJ and Rest Assured in your unit tests.</p><p>Next time, we are going to replace the <em>in memory</em> backend with a database, and use asynchronous integration with this database.</p><p>Stay Tuned &amp; Happy Coding !</p></article><hr></article><nav class=pagination><a href=http://vertx.io/blog/page-2.html class=pagination__link--older>&lt; Older</a></nav></div><div class="col-sm-4 blog-sidebar"><div class=blog-contribute><h4>Recent Posts</h4><ul><li><a href="/blog/vert-x-3-1-0-is-released/">Vert.x 3.1.0 is released !</a></li><li><a href="/blog/contract-driven-rest-services-with-vert-x3/">Contract Driven REST Services with Vert.x3</a></li><li><a href="/blog/writing-secure-vert-x-web-apps/">Writing secure Vert.x Web apps</a></li><li><a href="/blog/vert-x3-real-time-web-apps/">Vert.x3 real time web apps</a></li><li><a href="/blog/unit-and-integration-tests/">Unit and Integration Tests</a></li><li><a href="/blog/some-rest-with-vert-x/">Some Rest with Vert.x</a></li></ul><hr><p>Have something interesting to say about Vert.x? Want to contribute to this blog? Just check the <a href=https://github.com/vert-x3/vertx-web-site/blob/web-site-3.0.0/BLOG.md>instructions</a>.</p><p></p></div></div></div></div><footer><div class=container><div class=row><div class="col-xs-6 col-sm-3 col-md-3 col-lg-2"><h2>Vert.x</h2><ul class=list-unstyled><li><a href="http://vertx.io/">Home</a></li><li><a href=https://bintray.com/vertx/downloads/distribution/3.1.0/view>Download</a></li><li><a href="http://vertx.io/docs/">Documentation</a></li><li><a href=https://github.com/vert-x3/wiki/wiki>Wiki</a></li><li><a href="http://vertx.io/blog/">Blog</a></li><li><a href="http://vertx.io/vertx2/" class=vertx-2-link>Vert.x 2</a></li></ul></div><div class="col-xs-6 col-sm-3 col-md-3 col-lg-2"><h2>Community</h2><ul class=list-unstyled><li><a href="http://vertx.io/community/">Help &amp; Contributors</a></li><li><a href=https://groups.google.com/forum/?fromgroups#!forum/vertx>User Group</a></li><li><a href=https://groups.google.com/forum/?fromgroups#!forum/vertx-dev>Developer Group</a></li></ul></div><div class="col-xs-12 col-sm-6 col-lg-offset-2 col-md-6 copyright"><p>Vert.x is open source and dual licensed under the <a href=https://www.eclipse.org/org/documents/epl-v10.php>Eclipse Public License 1.0</a> and <a href=https://www.apache.org/licenses/LICENSE-2.0.html>Apache License 2.0</a>.</p><p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>Design by <a href=http://www.michel-kraemer.com>Michel Kr&auml;mer</a>. <a href=http://www.entypo.com>Entypo pictograms</a> by Daniel Bruce.</p><div class=row><div class="col-xs-12 col-lg-offset-2 col-md-5"><img class="logo eclipse-logo" src=http://vertx.io/assets/eclipse_logo_grey_small.png width=204 height=48></div><div class="col-xs-12 col-md-offset-2 col-lg-offset-0 col-md-5"><img class="logo cloudbees-logo" src=http://vertx.io/assets/Button-Built-on-CB-1-grey.png width=184 height=48></div></div></div></div></div></footer><script src=http://static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.min.js></script><script src=http://vertx.io/javascripts/bootstrap.min.js></script><script src=http://vertx.io/javascripts/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>